# 第 1 章 又一个令人愉快的星期六

## 1.1 一切尽在计划之中

除了完全冲动的或者精神病患者的行为外，人类的任何一个决策都可以归结为二选一。

在超市购物，面对很多产品，我们这样挑选，这个？不行。这个？不行。这个？可以，放进购物车？

你取下一条蓝色的短裤，然后走到袜子抽屉旁边，突然发现没有蓝色的袜子。**这就是一个测试。**

当你考虑单个决策或者也许在两个决策（例如，在现存的库存货物中，选择同样颜色的裤子和袜子）之间纠结的时候，实际上你思考的应该是一系列小的决策，本质上经常是二进制的：选或则不选，找到或者没找到。



## 1.2 地址

汇编语言的关键是理解内存地址。

内存寻址大概是汇编语言中最为棘手的部分，但是一旦掌握了它，你就已经掌握了汇编语言的真谛。



# 第 2 章 外星基数 拥抱二进制和十六进制

## 2.1 新数学怪物归来

汇编语言的所有知识都取决于对这两种数字基数的彻底理解（二进制数和十六进制数），所以

，在开始其他事情之前，我们将学习如何计数——这次是在火星上。



## 2.2 在火星上计数

每一列代表的**权值**等于**基数**乘以**右侧列的权值**。

最右侧的数代表是以1为单位的各位，左边的代表的是**基数乘以1**，再往左边的一列是**基数乘以基数乘以1**



## 2.3 数字基数的本质

在任意给定的基数制系统中，基数本身都不能用一个简单的单个数表示。



由于任意数字的零次幂都是1，所以在以任意数字为基础的数制系统中，第一列的值总是1，并且通常称为单位列。第二列的权值是数字基数的2-1次幂，即这个数字基数本身。



## 2.4 二进制简写方式：十六进制

**十六进制是程序员对于计算机二进制的简写方式。**



# 第 3 章 摘下面具 探索计算机的真正面目

一个基于Windows的COSMAC ELF模拟软件非，它能够接收和执行COSMAC程序：

https://billr.incolor.com/computer_simulators.htm



## 3.1 晶体管开关

晶体管是很小的硅晶体，它利用硅独特的电子属性来充当开关，有空理解那些独特的电子属性。

让我们把晶体管看作是一种类型的用电驱动的黑盒子，并用输入和输出这两个属于来描述它。



下图展示了一个晶体管开关（它是一个场效应晶体管，实际上它只是一种类型的晶体管，但确实我们当前计算机所使用的类型）当电压被加到管脚1时，电流在管脚2和管脚3之间流动。当电压被从管脚1中移除时，电流停止在管脚2和管脚3之间流动。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-04 上午11.13.02.png" alt="截屏2021-06-04 上午11.13.02" style="zoom:50%;" />



在现实生活中，少数其他部件（最典型的是二极管和电容）也是必要的，它们可以使计算机存储器工作得更加稳定。

晶体管开关及其支持部件合在一起称为存储单元。



## 3.2 随机访问

某种古老的存储器，它们被放在某种电磁机器上，旋转磁鼓存储器发出一个圆形的，位于磁性传感器下方的比特集合。传感器下方每次通过一个比特，如果错过了想要的那个比特，就需要重新再扫描一次。它们以固定的顺序向我们展示比特，一次展示一个，你必须按照它的顺序来等待你需要的比特。

随机访问是这样工作的：在芯片内部，每一个比特都存放在它自己的存储单元中，每一个此类存储单元都有一个独一无二的编号，这个编号就是一个单元（一个比特）的地址。



每个芯片都有很多从它引出的管脚，称为地址管脚。每个管脚叫做一个数据管脚，如下图所示，这些地址管脚是传递二进制地址码的电引线。地址是一个只用0合1表示的二进制数字。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-04 下午3.15.16.png" alt="截屏2021-06-04 下午3.15.16" style="zoom: 67%;" />



RAM芯片内部专用电路将地址解码成芯片内部的大量存储单元中的一个选定的输入。对于任意应用到这个地址管脚的给定地址而言，只有一个选定的输入会被提高到5v，进而实现对那个内存单元的选择。

根据打算读取一个比特还是写入一个比特，数据管脚会在存储单元的输入或输出之间进行切换。

这些都是在芯片内部完成的。而在芯片外面呈现的效果是；一旦一个内存地址被应用到地址管脚上，数据管脚就会马上发生变化。



每次访问内存的时间很短，通常30纳秒，但计算机需要访问成百上千，数百万或数十亿计次存储器，积少成多，也会耗费很长时间。编程高手给出的建议：**只要能不介入内存，就不介入内存**（但会非常难）



## 3.3 字节，字，双字，四字

除了非常古怪和特殊类型（比如，比如某些职能食品加工机）的计算机外，没有计算机处理比1个字节还小的信息。事实上，当今大多数计算机一次处理双字（4字节或32位）的信息。自从2003年来，pc兼容机已经能够一次性处理4字（64位）的信息。



## 3.4 精致的芯片排成一行

下图是一个存储器系统，它把一个存储的字节分布在8个单独的RAM芯片上。每一个黑色矩形代表如图3-2所示的RAM芯片。这8个芯片每一个存放字节中的一位，而且采用同一地址。8个芯片的20根地址管脚被连在一起（并联）。当计算机 把一个存储器地址应用到这20根地址线时，地址同时出现在存储器系统的所有8个芯片的地址管脚上，在八位数据总线上同时传递8个比特的数据，每一个来自于其中一个芯片。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-04 下午3.52.19.png" alt="截屏2021-06-04 下午3.52.19" style="zoom:50%;" />



这样简单的存储芯片已经不复存在，大多数存储器芯片在每一个地址不止存放一个比特的数据。每个地址存放1个，2个，3个，4个和8个比特数据的芯片相对普遍。如图3-3，每个地址存放8个比特。



计算机中每个字节的存储器都有它唯一的地址，即使是在一次处理2，4或8个字节信息的计算机中。

在32位和64位计算机中，每个字节都有它自己的地址，但是当一台32位计算机访问一个字节时，它实际一次读取从这个字节开始的4个字节，你可以使用剩余的3个字节，或者如果不需要，干脆忽略它们。

如图3-3，将每个黑色矩形与8个数据线相连，每次就能传输64比特信息。



如图3-3所示，这是1个8位存储系统，每个地址能访问1字节数据。



## 3.5 车间工厂和流水线

也许有些人会说，CPU是实际完成工作的部件，但这种观念过于单纯化了，很多实际的工作是在存储系统和我们称之为外设的设备中完成的，如显卡，USB和网络端口等。



## 3.6 对话内存

CPU芯片最重要的工作就是与计算机存储器系统进行通信。如图3-4所示，当CPU需要从内存中读如一个字节（一个字，双字，四字时），它把该字节的内存地址放到它的地址管脚上，编码成一个二进制数。几纳秒之后，所需的字节就出现存储器芯片的数据管脚上。CPU芯片也有数据管脚，它通过自己的数据管脚读取存储器芯片提交的字节。



这个过程可以反向进行，为了向内存中写入一个字，CPU首先把它想写入的存储器地址放到它的地址管脚上，几纳秒以后，CPU把它想写入的字节放到自己的数据管脚上，存储器芯片就乖乖地把这个字节的数据放到请求的地址中。

<img src="/Users/wangjun/Desktop/截图/截屏2021-06-04 下午6.33.45.png" alt="截屏2021-06-04 下午6.33.45" style="zoom:50%;" />



## 3.7 驾驭数据总线

显卡，硬盘，USB和网络端口是个人电脑最常用外设。像CPU和存储器一样，它们都是靠电驱动的设备。大多数现代外设包含一到两个大芯片，也许包含一对支持大芯片的小芯片。这些外设都包含地址管脚和数据管脚。一些外设（尤其是图形卡）还拥有自己的存储器芯片，目前他们使用专用的CPU。（现代图形卡是一个拥有自主权的高性能计算机，尽管它只拥有一个特定而有限的使命）。

外设能够与CPU“谈话”，有时也相互通信。所有计算机中的外设都有通用的管脚。这些电线被称为数据总线，它们形成了一种类型的合用线，把CPU连接到计算机的所有其他部件上。一个复杂的电仲裁系统决定这些不同的设备能够在什么时间以什么顺序使用这根合用线来互相“交谈”，但是它经常以同样的方式发生：地址被放到总线上，后面跟着一些数据（一次多少数据取决于所设计的外设）。总线上发出一些特定的信号，用于指明该地址是代表存储器中的一个位置，还是绑定到地址线中的外设。为了和前面一直讨论的存储器地址区分开来，我们将外设地址称为I/O地址。

在大多数个人计算机中，数据总线是出现在扩展槽中的主要元素，而很多外设（尤其是图形卡）就是这些插入扩展槽中的印刷电路板。通过数据总线在扩展槽中的电路管脚实现的连接，外设可以与CPU和内存进行对话。

尽管扩展槽使用起来方便，但它们在计算机内部也会产生一些延迟。简单来说，外设只是计算机内部的主要电路板（主板）上的某个角落处的几个芯片。



## 3.8 车间工长的口袋

即寄存器。

CPU的即时工作过程在名为寄存器的临时存储容器中进行。

大多数外设也有寄存器，外设寄存器的使用范围比CPU寄存器的使用范围更小一些。



## 3.9 流水线

如果CPU是车间工长，那么外设就是流水线上的工人，数据总线就是流水线本身。

问题是：是谁告诉车间工长及其手下员工该做什么事情？是你。你应该怎么做到呢？你编写一个程序。程序从哪里来呢？它在存储器中，与很多存放在存储器中的数据一起。实际上，程序也是数据，它是我们所知的整个编程思想的核心。



## 3.10 遵循计划行事的盒子

正如字母表和数字代表对我们人类有意义的某些内容一样，代码集对CPU也意味着这些内容，这些代码被称为机器指令。并且它们的名字可以通过其实际内容来进行记忆。当 CPU 正在执行一个程序时，它从数据总线上取出一系列数字，每次取出一个。每个数字告诉 CPU 做某件事情。当执行完某条指令时，它取出下一条指令并执行。它继续执行到某些东西（程序中一条指令，或诸如复位按钮的之类的电信号）告诉它停下来。

例如，对于Intel的现代CPU通用的例子：8位二进制编码 01000000(40H)对于CPU来说，意味着一条命令：**向寄存器AX中的值加一，并将其和存回AX**。大多数机器指令不只占用一个字节，很多指令占用2个字节或4个字节。二进制代码1101011001110011 (0B6H 073H)构成另一条指令：把数值73H加载到寄存器DH中。而二进制编码 1111001110100100  (0F3H 0A4H)则能够引导CPU完成以下事情：**开始把由CX寄存器指定数量的字节从存放在DS和SI中的32位地址中取出来，并存入存放在SI和DI中的32位地址处，每移动一个字节，同时更新SI和DI中的地址，并将CX中的值减一，最后当CX中值变为0时，停止执行。**

Intel IA-32 :英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。

Intel IA-32所能理解的其余几百条指令的复杂性和功能大致在这两条指令之间。

**每一条指令一般情况下高速计算机执行一个较小且有限的任务。很多指令被按顺序提交给CPU，以引导其完成更复杂的任务。而写出这些指令序列实际上就是汇编语言编程。**



## 3.11 取址和执行

CPU 一执行完一条指令，就转到存储器，按顺序取出下一条指令。在CPU内部，有一个特殊的寄存器，名为指令指针寄存器，它包含下一条即将从内存中取出和执行的指令的地址。每当一条指令执行完毕后，这个指令指针都被更新为指向内存中的下一条指令。

所有这些都像时钟一样规规矩矩地指向。计算机有一个以电驱动的子系统，叫做时钟系统（system clock），它实际上是一个能够以非常精确的时间间隔发出方波脉冲的震荡器，CPU内部的很多极小的晶体管开关根据系统时钟产生的脉冲来协调它们的行为。

CPU的运行过程是这样的：取指和执行；取指和执行。CPU在指令指针寄存器的指引下在内存中行进。

**计算机程序是存储在内存中的二进制机器指令的列表。在内存中，它们与其他数据字节的列表没有任何区别，只是当被取出时，CPU对它们的解释有所不同。**



## 3.12 车间工长的内脏

大部分CPU内部的开关包含不只一个手柄。这些开关，称为门(gate)，它们根据逻辑规则进行工作。为了让某个开关通过门来实现“关闭”，也许需要两三个或更多个“打开”开关投掷同时到达某个特定的门。

这些门被用于在CPU内建造复杂的内部机制。



## 3.13 改变航向

计算机本质的第一个魅力是：内存中的一串二进制编码一步一步地高速计算机做哪些事情。第二个魅力是皇冠上的真正宝石：有一些机器指令能够改变机器指令被取出和执行的顺序。



## 3.14 是什么 vs 怎么做：体系结构和微体系结构

CPU 的灵魂被清楚地分为两个部分：CPU 做什么事情； CPU如何做这些事情。程序员从外面来看它：CPU做什么事情。设计计算机主板和其他包含Intel处理器硬件系统的电子工程师和系统设计人员需要知道其余内容，但是他们是极少数非常吃苦耐劳的一群人，他们知道自己是谁。



### 3.14.1 体系结构的演变

除了向指令集周期性地添加内容外，体系结构本身也在突飞猛进。这些飞跃的典型情况体现在CPU的“宽度”上。1986年，随着80386 CPU 的引入，Intel的16位体系结构扩展到了 32 位，并且添加了大量的指令和操作模式，CPU寄存器的宽度也怎加到原来的两倍。2003年，X86体系结构继续扩展，这次是到64位，而且又添加了很多新的指令，操作模式和扩展寄存器。



### 3.14.2 地下室里的秘密机制

由于涉及向后兼容问题，除非有非常好的理由，否则 CPU 的设计者们不会再添加新的指令或寄存器到体系结构中。有一些其他的更好的方法来改善 CPU 家族。这些方法最重要的是要提高处理器的吞吐量，它不仅仅是单纯地提高 CPU 时钟频率的问题。另一个是要降低电量消耗。

提高处理器的吞吐量意味着提高同一时间段内 CPU 执行的指令数目。很多神秘的技术与提高吞吐量有关，例如：预读取，L1高速缓存，L2高速缓存，分支预测，超管道和微操作熔合等。

总的来说， CPU 为了完成指令让它做的事情而依赖的所有电机制通称为 CPU 的微体系结构。



## 3.15 操作系统：角落办公室

实际上，我们早期的微机操作系统并不是很强大，也做不了太多事情。它们旋转磁盘，处理存储在磁盘驱动器中的数据，当需要时，将数据送回磁盘。它们接收来自键盘按键的敲击，然后把字符发送到显示器。另一种较少的情况是，它们能够把字符发送给打印机。这就是操作系统。

早期的操作系统，加载应用程序时，系统将会放到软驱中，因为内存空间有限。应用程序执行完比后，操作系统重新加载入内存，等待下一条命令。



### 3.15.1 BIOS：是软件，但并不软

IBM已经将处理键盘，显示器和磁盘驱动器的程序代码单独拿出来并烧制到一种特殊类型的，名为只读存储器（ROM）的存储器芯片上。一般的随机存储器在断电时内容就消失了。而ROM不管有没有电都会保持它的内容，这样成千上万条机器指令就不用从磁盘中加载了，因为它们总是位于一个焊在主板上的ROM芯片里。**ROM上软件称为基本输入输出系统（basic input output system），简写为BIOS，因为它能处理计算机的输入设备（例如键盘）和输出设备（例如显示器和打印机）**



### 3.15.2 多任务魔术

windows95 拥有一些以前PC世界中从未见过的内容：**抢先式多任务处理器(preemptive multitasking)**

windows95营造了一种令人相信的错觉：内存中的所有程序在同一时间内运行。这是通过每一个加载到内存中的程序赋予一个CPU时间片来完成的。程序在CPU上开始运行，它的若干条机器指令将会得到执行。运行一个程序时，经过一段时间之后（通常是几分之一秒），windows95 从第一个程序中“抢回” 对 CPU 的控制权，然后将其交给列表中第二个程序。如此循环。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-04 下午11.22.53.png" alt="截屏2021-06-04 下午11.22.53" style="zoom: 33%;" />



操作系统能够为列表中的每一个程序赋予一个优先级，以便有些程序能够比其他程序获取更多的执行时间。



### 3.15.3 内核提升

Linux 没有像 windows 95 一样精美饿图形用户界面，但是它能够处理多任务，而且内部具有更为强大的结构。Linux的核心是一个名为内核（kernel）的代码块，它充分利用了IA-32 保护模式的优点。Linux 内核与图形用户界面是完全分开的，它被保护起来以防被系统某处非正常工作的程序损坏。系统存储器或者被标示为内核空间（kernel space），或者标示为用户空间，运行在用户空间的任何内容都不能被写入（一般情况下也不能从内核空间读取）存放在内核空间的任何内容中。内核空间和用户空间之间的通信通过严格控制的系统调用来进行处理。

只有运行在内核空间的软件才能直接访问物理硬件（包括内存，显存，外设）。希望使用系统外设的程序只能通过内核模式设备驱动来实现访问。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-04 下午11.39.29.png" alt="截屏2021-06-04 下午11.39.29" style="zoom:67%;" />



### 3.15.4 内核爆炸

2000年初，拥有两个 CPU 插口的台式 PC 开始销售。通过使用“对称多处理(SMP)”机制，Window 2000/xp/7 和Linux都支持在一个单系统中使用多个 CPU。当所有处理器都一样时，处理器是“对称的”。当可以使用两个CPU时，操作系统在大多数情况下在一个 CPU 上运行自己的代码，而在另一个 CPU上运行用户模式应用程序。

随着技术的进步，出现了多核心 CPU，四核以上 CPU是可能的，但是，如何使用这样一笔令人为难的财富仍然需要更多的讨论。



### 3.15.5 计划

计算机是一个能够执行计划的盒子。

这个计划（即内存中的机器指令列表）就是汇编语言程序。本书的核心内容就是学会如何将这些机器指令正确地排列到内存中供CPU使用。

是时候开始近距离观察机器指令引导 CPU执行的操作的本质。如同计算中所有内容一样，操作大部分是在存储器中完成的，这些存储器包括主板上的常规内存，又包括那些记忆之王——CPU 寄存器。



# 第 4 章 位置 位置 位置 寄存器、内存寻址以及了解数据存储位置

## 4.1 内存模式的乐趣

在 32 位 Linux 下编程基本上只限于一种内存模式，一旦对内存寻址深入理解之后，你将会非常喜欢它。

* 最古老的内存模式叫**实模式平面模型**（real mode flat model），它完全僵化，但是相对简单。

* 年纪较大的（现在已经退休了的）内存模式叫**实模式段模型**（real mode segmented model）,这可能是编程语言里学到的最令人讨厌的东西。DOS 编程的最高境界会用到这种实模式段模型，其结果是使程序员们备受折磨。

* 最新的内存模式叫**保护模式平面模型**（protected mode flat model）,它是很多现代操作系统（如windows200/XP/Vista 和 Linux）背后的内存模型。

保护模式平面模型只能用于IA-32 体系结构的 386 及更新的 CPU 中。8086、8088 和 80286不支持。

*实模式平面模型非常像保护模式平面模型的缩影*。 



### 4.1.1 16位将带来 64 k 存储空间

8080 拥有一个 8 位的 CPU（即寄存器的位数），这意味着它一次能够处理八位的信息，然而它却拥有 16 根地址线。CPU 的位数——它的通用寄存器应该包含多少个位，它非常重要。在我看来，衡量  CPU 效率的最重要的标准是它一次操作能够调集多少根地址线

16 根地址线可以寻址 64k 字节，从二进制角度看，可以从0计数到65535。（口语中的“64K” 就是 65536的简称）

。意味着65536个单独的内存位置中任意一个都拥有唯一一个从 0 到 65535 之间的地址。

8080的内存寻址方案非常简单：把一个 16 位地址放到地址线上，然后取出存放在那个位置处的 8 位值。注意：**内存系统中的地址线的根数和存放在每个位置上的数据的位数之间没有必要的关系。**8080在每个位置存放8位二进制数，但是它也能够在每个位置存放 16 位或者 32 位数据，并前仍然使用 16 根内存地址线。



8080 主要使用的操作系统是 CP/M-80。CP/M-80出现在安装内存的顶部，有时为了便于包含在 ROM 中，但更主要的是为了让路，从而允许临时程序拥有一致的内存起点，临时程序被加载到内存中，只有需要的时候才运行。当CP/M-80 从磁盘读如一个程序并运行时，它将程序加载到距离内存底部256个字节的地址为0100H的地方。内存的前 256 **个字节叫程序段前缀**（Program Segment Prefix，简称为PSP），里面包含着各种零碎消息和一个用于程序磁盘输入输出的通用内存缓冲区。

当英特尔创建它的第一个 16 位 CPU——8086时，它想让人们更加容易地将较老的CM/M-80 软件从8080 翻译到 8086——这个过程叫移植。要想做这件事，一种方法是确保 16 位寻址系统（例如8080中的寻址系统）仍能够工作。尽管 8086能够寻址的范围是8080的16倍（16*64KB=1MB）,英特尔将 8086创建为可让程序只占用那 1M 内存里的 64K 字段，并前完全在它里面运行，就好像是小型的 8080 内存系统一样。下图是8080内存模式。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午12.36.35.png" alt="截屏2021-06-05 下午12.36.35" style="zoom: 67%;" />



这是通过使用段寄存器（segment register）来完成的，从根本上来讲，它们是位于 CPU 寄存器内部的内存指针，指向内存中事情开始的位置，这里所说的“事情”，可能是数据存储，也可能是代码执行或其他内容。

在8086内存的1M字节内，一个从8080世界移植过来的程序即将开始运行，如图4-2.

考虑名为CS的寄存器——它代表代码段（Code segment），它是指向8086的1M字节内存中的某一位置的指针。这个指针作为 64k 内存区域的起始点，在这个区域中，一个快速转换的 CP/M-80 程序能流畅地运行。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午3.16.35.png" alt="截屏2021-06-05 下午3.16.35" style="zoom:50%;" />




短期内来看，这是一个非常明智的考虑，同时，从长期来看，这也是一种非常糟糕的设想。两年之内，许多 CP/M-80程序被转换成了 8086 程序。但是，当程序员们企图从头开始创建全新的，与 8080 从未谋面且不需要段模型的程序时，问题变得严重。段模型控制着 8086 的体系结构。一些一次需要大于 64KB内存的程序不得不使用64KB的内存块，通过切换进入和离开段寄存器的值来实现在这些内存块之间的切换。

这是一场噩梦，没有好的理由要学习它。



### 4.1.2 兆字节的本质

当运行在分段实模式下时，x86 CPU 最多能使用1MB 的可直接寻址内存。这个内存也叫实模式内存（real mode memory）。

1MB内存包含 1048576 字节，地址从00000H到0FFFFFH。

这就是 1M 字节内存：由包含 20 根电线的地址总线所连接的，计算机内部的一些内存芯片组合。通过向那 20 根地址线提供 20 位地址来标示 1MB 中的一个字节。



### 4.1.3 向后兼容和虚拟 86 模式

现代的x86 CPU（例如：奔腾）能够在比这更大的内存范围内进行寻址。对于 8086 和 8088 CPU而言，计算机真正拥有 20 根地址线和1兆内存。386 及其之后的英特尔 CPU 能够寻址4兆内存，而不必把它分成更小的段。当 32 位 CPU工作在保护模式实模型下时，一个段是4GB——所以大多数情况下，一个内存段足够。

然而，很多使用分段技术编写的DOS软件仍然随处可见，我们必须对其加以处理。所以，为了与 8086 和 8088 之前的CPU相互兼容，较新的 CPU 被赋予一种权利，使其能够将自己限制在老式CPU 能够寻址和执行的范围。当一个奔腾级别的 CPU 需要运行为实模式段模型编写的软件时，它将采用一项简洁的技术，暂时把自己变成一个8086，这叫虚拟86模式（virtual-86 mode），他对DOS软件提供了非常好的向后兼容性。



### 4.1.4 16位眼罩

在实模式段模型里，X86 CPU 可以“看到”整整 1MB 的内存。也就是说，CPU 芯片能够将自己设置为只能使用32个地址引脚中的20个，进而向存储器系统传递 20 位的地址。对于实模式段模型，虽然这些 CPU 可以看到整整 1M 字节内存，但是它们被限制为只能使用 16 位眼罩来看那 1 M字节。

CPU 看到的实模式段模型下的内存很特殊。它被限制为以块的方式查看内存，这些块中的长度都不超过 65536 字节，也就是我们所说的“64KB”。利用这些块——也就是说，知道目前正在使用哪一块以及如何从一个块移动到另一个块——是实模式段模型编程所面临的真正挑战。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午4.57.43.png" alt="截屏2021-06-05 下午4.57.43" style="zoom:50%;" />



## 4.2 段本质

段是一个内存区域，它从一个段落边界开始，并且扩展一定数量的字节。在实模式分段模型中，这个数量小于或者等于 64K（65536）。

现在来上一段古老的86家族琐事的课。段落(paragraph)是一个内存度量，等于 16 个字节大小，它是用于描述不同内存容量的众多技术术语之一。我们之前已经见过了其中一些，它们都是1个字节的偶数倍。请记住：字节是原子数据；松散的内存位更像是亚原子粒子，如果包含它们的一个字节（或更多字节）“缺席”，这些内存位就根本不存在。有些术语使用频率较其他的高，例如下表：

| 名称 | 十进制值 | 16 进制值 |
| ---- | -------- | --------- |
| 字节 | 1        | 01H       |
| 字   | 2        | 02H       |
| 双字 | 4        | 04H       |
| 四字 | 8        | 08H       |
| 十字 | 10       | 0AH       |
| 段落 | 16       | 10H       |
| 页   | 256      | 100H      |
| 段   | 65536    | 10000H    |

任何能被 16 整除的内存地址称为一个段落边界（paragraph boundary）。第一个段落边界是地址0；第二个是地址 10H；第三个是地址20H。任何一个段落边界都可以被认为是另一个段落边界的开始。

在实模式段模型中，一个程序可能只使用四五个段，但是这些段中的每一个可能开始于65536个段落边界之中的任何一个，当然，这些段落边界位于这1MB在实模式段模型中可用的内存里。

每一个段都有一个编号，这些编号从0开始，一直到64k-1，用十进制表示是 65535，用十六进制表示是 0FFFFH。因为一个段落可能开始于任一段落边界，所以把段开始的那个段落边界的编号叫做段的段地址。如图4-4，每个阴影都是一个段地址，没16个字节开始的一个段。最高段的段地址为0FFFFH，它距离实模式1MB内存的最顶部16个字节。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午5.47.48.png" alt="截屏2021-06-05 下午5.47.48" style="zoom:50%;" />



总之，段可以开始于任意段地址。共有 65536个段地址均匀地分布在实模式下的满满 1MB 内存中，每两个段之间相隔 16 个字节。以其说段地址是一个强制，不如说它是一个许可；对于所有64K个可能的段地址而言，只有五六个在某一时段被真正用作段的开始。

关于段的理解，最重要的一点是，它最大可达 64K 字节，但不一定非要那么大，一个段可能只有一个字节长，或者 256个字节长， 或者21378个字节长，或者任意小于64K的字节长。



### 4.2.1 一个界限，而非一个位置

一种对段的错误的认识就是：段是某种类型的内存位置，一旦预留出来用于某些特定应用的，两侧都有墙壁保护内存区域。

这个观点完全不正确。在实模式下，段内的任何内容都不受保护，而且段并没有被预留出来供某些特定的寄存器或访问方式使用。段也可以重叠。

我的观念是这样的：段是内存中安装 CPU 的64KB 眼罩的位置。通过这个眼罩查看内存，能够看到从段地址开始，一直到眼罩组织你的沿途所有字节，一共64KB。



### 4.2.2 用两个 16 位寄存器构成 20 位地址

寄存能够做很多工作，但最重要的一项也许就是存放内存中某些重要位置的地址。8086 和 8088 有 20 个地址引脚，它们的 1M 字节内存（它是我们正在谈论的实模式分段内存）需要 20 位大小的地址。

无法把一个 20 位的地址放到一个 16 位的寄存器中。但可以把一个 20 位的地址放入两个 16位 的寄存器中。内存中的每个字节都假设位于某个段中。那么，一个字节的完整地址包含它所在段的地址，还有该字节距离那个段的起始位置的的字节数是它的偏移地址。两个地址都指定才能完整描述实模式下整整一兆内存中的任意个字节的地址。在书写时，段地址写在前面，偏移地址写在后面，两者用“:”隔开。x86编程公约规定，当用这种形式表示一个地址时，不用在这两个十六进制数的结尾加上字母H。

发生的意外情况是：所有位于实模式下的 1MB 内存中的存储位置不是只有一个地址。如下图所示，一个我们称之为“MyByte”的字节数据存放在内存中用黑色标示出来的位置

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午6.28.41.png" alt="截屏2021-06-05 下午6.28.41" style="zoom:50%;" />



严格来说，它实际位于哪一个段只是一个习惯问题。

这很尴尬，但它是多年以来我们能够做到的最佳方式。



## 4.3 16位和32位寄存器

段地址可被看作实模式下的 64KB 眼罩的起始位置。通常情况下，你会移动眼罩以找到希望工作的位置，然后把眼罩留在一个地方，在它周围的 64K 限制以内的空间范围移动。

这正是寄存器在实模式段模型下汇编语言中的用法。在8088，8086和80286中，有 4 个专门设计用于存放段地址的段寄存器。386 及后来的处理器又多了两个，它们也可以在实模式下使用。

段寄存器拥有反应其一般功能的名字：CS，DS，SS，ES，FS和GS。FS和GS只出现在386及更高版本的 Intel x86 CPU中，但大小仍然是32位。

* CS（code segment）代表代码段。机器指令存放在代码段的某些偏移位置处。CS中包含当前执行指令的代码段的段地址。
* DS（date segment）代表数据段。变量和其他数据存放在数据段的某些偏移位置处。也会有很多个数据段，，但 CPU 一次只能使用一个，这是通过将该段的段地址放入寄存器DS来实现的。
* SS（stack segment）代表堆栈段。堆栈是 CPU 用来暂时存放数据和地址的一个非常重要的部件。堆栈也是一个段地址，这个地址存放在SS中。
* ES（extra segment）代表附加段寄存器。附加段寄存器是一个可用于指定内存中某一位置的备用段。
* FS和GS是ES的克隆。它们都是额外的段，没有特殊的工作或专长，它们只存在于386 及后来的x86 CPU 中。



### 4.3.1 通用寄存器 

x86 有很多通用寄存器，它们用来做汇编语言计算的其余工作，在很多其他事情（除了计算之外的），这些通用寄存器用来存放偏移地址，它必须与段地址成对出现。它们还经常用于存放算术运算值。

从386开始的较新的 32 位 x86 处理器之间最大，最明显的区别之一：通用寄存器的大小。像段寄存器一样，通用寄存器也是 CPU 芯片本省内部的存储位置；也像段寄存器一样，它们都拥有自己的名字。

通用寄存器真的是通才，但是有些寄存器只能完成某些特殊的功能。有些特殊功能只是在老式的 16 位 CPU 中才会受到限制。

在32位世界中，通用寄存器分为三个一般类：16位通用寄存器，32位扩展通用寄存器和8位的半寄存器。这三类并不代表三个完全不同的寄存器。16位和8位寄存器实际上是32位寄存器内部的一块区域的名字。

有 8 个 16 位通用寄存器：AX，BX，CX，DX，BP，SI，DI和SP。（SP 不如其他通用寄存器通用性强，但有时会用到）。

当 Intel 于1986年将其 x86 体系结构扩展为32位时，它把所有 8 个寄存器的大小增加了一倍，并且通过在原有的名字前面加上前缀 E 来对他们进行重新命名，形成了EAX，EBX，ECX，EDX，EBP，ESI，EDI和ESP。

虽然扩展了新寄存器，但老寄存器一点没丢。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午9.14.24.png" alt="截屏2021-06-05 下午9.14.24" style="zoom:50%;" />





上图展示的 4 个寄存器都完全是 32 位大小。然而，在每个寄存器里，低 16 位都拥有自己的名字。例如，ESI的较低的 16 位可以用 SI 来进行引用。

32位通用寄存器的高 16 位没有自己的名字。



### 4.3.2 半寄存器

有 4 个通用寄存器（EAX，EBX，ECX和EDX），它们的低 16 位本身被分成了两个 8 位寄存器，所以我们不是拥有两个寄存器，而是拥有三个级别的寄存器。16 位寄存器AX，BX，CX和DX作为EAX，EBX，ECX和EDX的低16位而存在，而AX，BX，CX和DX又被分为 8 位的半寄存器，编译程序能够识别这两个“半寄存器”的特殊名字。

字母A，B，C和D仍然保留，但是，半寄存器不再使用X，而是用一个H（高半寄存器）和L（低半寄存器）来表示它。每个半寄存器的大小都是一个字节（8位）。因此，字节大小的半寄存器 AH 和 AL 构成了 16 位寄存器 AX。依次类推。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-05 下午9.29.10.png" alt="截屏2021-06-05 下午9.29.10" style="zoom:50%;" />



### 4.3.3 指针指令寄存器

代码段（code segment）是一块存储机器指令的内存区域。程序执行的测试和步骤就包含在代码中。根据使用的编程模型，一个程序可能有多个代码段或者只有一个。当前代码段（current code segment）是指段地址当前正存放在代码段寄存器CS中的那段代码。在任意给定的时间里，当前正在执行的指令都出现在当前代码段中。在实模式段模型里，CS 中的值经常变化。在两个平面模型里，CS中的值（几乎）从来没有变化，当然，在保护模式下的所有段寄存器都“隶属于” 操作系统，一般应用程序不能修改它。

当执行程序时，CPU 使用 IP 来跟踪位于当前代码段中的位置。每执行一条指令后，IP 就递增一定数量的字节，这个字节刚好是执行的那条指令的大小，最终的结果是，IP 跳到了更远的地方，指向了下一条即将执行的指令的开始位置。指令有不同的大小，典型的大小是1到6个字节，（其中有些更神秘的指令的更神秘的形式可能更大些）。CPU 谨慎地将 IP 怎加正确数量的字节数，因此，它实际最终指向下一条指令的起始位置。

CS 和 IP 一起，保存下一条即将执行的指令的完整地址。

地址的本质取决于使用的 CPU，以及正在使用的针对该 CPU 的编程模型。在 8088，8086和80286中，IP的大小是 16 位的。在 386 及更高的 CPU 中IP（像除段寄存器之外的其他所有寄存器一样）增加到 32 位的规模，变成EIP。

在实模式段模型中，CS 和 IP 一起工作，带来了一个 20 位的地址，指向实模式内存中的 1048576 个字节之一。

在两种平面模型中，CS 由操作系统设置并且保持不变，IP完成你（程序员）必须处理的所有指令指向。在 16 位平面模型中（实模式平面模型），这意味着IP可以跟踪所有 64K 内存段内的指令执行。 32 位平面模型做的远远超过其一倍，32位可以代表 4294967296 个不同的内存地址。因此在 32 位平面模型（即，保护模式平面模型）中，IP可以追踪 4GB 内存范围内的指令执行。

 IP是唯一不能直接读出，也不能直接写入的寄存器。有一些技巧可以用来获取当前 IP 寄存器的值。



### 4.3.3 标志寄存器

在8086，8088和80286中，它的大小是16位，并且它的正式名称是FLAGS。在 386 及更高的 CPU 中，它的大小是32位，正式名称是EFLAGS。标志寄存器的大多数位都可以作为名为标志位的一位寄存器来使用，这些单个标志位都有一个名字，例如CF，DF，OF等，并且每一个在CPU 内部都有一个特殊的含义。
