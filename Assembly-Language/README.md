# 第 1 章 又一个令人愉快的星期六

## 1.1 一切尽在计划之中

除了完全冲动的或者精神病患者的行为外，人类的任何一个决策都可以归结为二选一。

在超市购物，面对很多产品，我们这样挑选，这个？不行。这个？不行。这个？可以，放进购物车？

你取下一条蓝色的短裤，然后走到袜子抽屉旁边，突然发现没有蓝色的袜子。**这就是一个测试。**

当你考虑单个决策或者也许在两个决策（例如，在现存的库存货物中，选择同样颜色的裤子和袜子）之间纠结的时候，实际上你思考的应该是一系列小的决策，本质上经常是二进制的：选或则不选，找到或者没找到。



## 1.2 地址

汇编语言的关键是理解内存地址。

内存寻址大概是汇编语言中最为棘手的部分，但是一旦掌握了它，你就已经掌握了汇编语言的真谛。



# 第 2 章 外星基数 拥抱二进制和十六进制

## 2.1 新数学怪物归来

汇编语言的所有知识都取决于对这两种数字基数的彻底理解（二进制数和十六进制数），所以

，在开始其他事情之前，我们将学习如何计数——这次是在火星上。



## 2.2 在火星上计数

每一列代表的**权值**等于**基数**乘以**右侧列的权值**。

最右侧的数代表是以1为单位的各位，左边的代表的是**基数乘以1**，再往左边的一列是**基数乘以基数乘以1**



## 2.3 数字基数的本质

在任意给定的基数制系统中，基数本身都不能用一个简单的单个数表示。



由于任意数字的零次幂都是1，所以在以任意数字为基础的数制系统中，第一列的值总是1，并且通常称为单位列。第二列的权值是数字基数的2-1次幂，即这个数字基数本身。



## 2.4 二进制简写方式：十六进制

**十六进制是程序员对于计算机二进制的简写方式。**



# 第 3 章 摘下面具 探索计算机的真正面目

一个基于Windows的COSMAC ELF模拟软件非，它能够接收和执行COSMAC程序：

https://billr.incolor.com/computer_simulators.htm



## 3.1 晶体管开关

晶体管是很小的硅晶体，它利用硅独特的电子属性来充当开关，有空理解那些独特的电子属性。

让我们把晶体管看作是一种类型的用电驱动的黑盒子，并用输入和输出这两个属于来描述它。



下图展示了一个晶体管开关（它是一个场效应晶体管，实际上它只是一种类型的晶体管，但确实我们当前计算机所使用的类型）当电压被加到管脚1时，电流在管脚2和管脚3之间流动。当电压被从管脚1中移除时，电流停止在管脚2和管脚3之间流动。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8A%E5%8D%88111.png" alt="截屏2021-06-04 上午111" style="zoom: 33%;" />



在现实生活中，少数其他部件（最典型的是二极管和电容）也是必要的，它们可以使计算机存储器工作得更加稳定。

晶体管开关及其支持部件合在一起称为存储单元。



## 3.2 随机访问

某种古老的存储器，它们被放在某种电磁机器上，旋转磁鼓存储器发出一个圆形的，位于磁性传感器下方的比特集合。传感器下方每次通过一个比特，如果错过了想要的那个比特，就需要重新再扫描一次。它们以固定的顺序向我们展示比特，一次展示一个，你必须按照它的顺序来等待你需要的比特。

随机访问是这样工作的：在芯片内部，每一个比特都存放在它自己的存储单元中，每一个此类存储单元都有一个独一无二的编号，这个编号就是一个单元（一个比特）的地址。



每个芯片都有很多从它引出的管脚，称为地址管脚。每个管脚叫做一个数据管脚，如下图所示，这些地址管脚是传递二进制地址码的电引线。地址是一个只用0合1表示的二进制数字。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%883.png" alt="截屏2021-06-04 下午3" style="zoom:50%;" />



RAM芯片内部专用电路将地址解码成芯片内部的大量存储单元中的一个选定的输入。对于任意应用到这个地址管脚的给定地址而言，只有一个选定的输入会被提高到5v，进而实现对那个内存单元的选择。

根据打算读取一个比特还是写入一个比特，数据管脚会在存储单元的输入或输出之间进行切换。

这些都是在芯片内部完成的。而在芯片外面呈现的效果是；一旦一个内存地址被应用到地址管脚上，数据管脚就会马上发生变化。



每次访问内存的时间很短，通常30纳秒，但计算机需要访问成百上千，数百万或数十亿计次存储器，积少成多，也会耗费很长时间。编程高手给出的建议：**只要能不介入内存，就不介入内存**（但会非常难）



## 3.3 字节，字，双字，四字

除了非常古怪和特殊类型（比如，比如某些职能食品加工机）的计算机外，没有计算机处理比1个字节还小的信息。事实上，当今大多数计算机一次处理双字（4字节或32位）的信息。自从2003年来，pc兼容机已经能够一次性处理4字（64位）的信息。



## 3.4 精致的芯片排成一行

下图是一个存储器系统，它把一个存储的字节分布在8个单独的RAM芯片上。每一个黑色矩形代表如图3-2所示的RAM芯片。这8个芯片每一个存放字节中的一位，而且采用同一地址。8个芯片的20根地址管脚被连在一起（并联）。当计算机 把一个存储器地址应用到这20根地址线时，地址同时出现在存储器系统的所有8个芯片的地址管脚上，在八位数据总线上同时传递8个比特的数据，每一个来自于其中一个芯片。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%883.52.19.png" alt="截屏2021-06-04 下午3.52.19" style="zoom:50%;" />



这样简单的存储芯片已经不复存在，大多数存储器芯片在每一个地址不止存放一个比特的数据。每个地址存放1个，2个，3个，4个和8个比特数据的芯片相对普遍。如图3-3，每个地址存放8个比特。



计算机中每个字节的存储器都有它唯一的地址，即使是在一次处理2，4或8个字节信息的计算机中。

在32位和64位计算机中，每个字节都有它自己的地址，但是当一台32位计算机访问一个字节时，它实际一次读取从这个字节开始的4个字节，你可以使用剩余的3个字节，或者如果不需要，干脆忽略它们。

如图3-3，将每个黑色矩形与8个数据线相连，每次就能传输64比特信息。



如图3-3所示，这是1个8位存储系统，每个地址能访问1字节数据。



## 3.5 车间工厂和流水线

也许有些人会说，CPU是实际完成工作的部件，但这种观念过于单纯化了，很多实际的工作是在存储系统和我们称之为外设的设备中完成的，如显卡，USB和网络端口等。



## 3.6 对话内存

CPU芯片最重要的工作就是与计算机存储器系统进行通信。如图3-4所示，当CPU需要从内存中读如一个字节（一个字，双字，四字时），它把该字节的内存地址放到它的地址管脚上，编码成一个二进制数。几纳秒之后，所需的字节就出现存储器芯片的数据管脚上。CPU芯片也有数据管脚，它通过自己的数据管脚读取存储器芯片提交的字节。



这个过程可以反向进行，为了向内存中写入一个字，CPU首先把它想写入的存储器地址放到它的地址管脚上，几纳秒以后，CPU把它想写入的字节放到自己的数据管脚上，存储器芯片就乖乖地把这个字节的数据放到请求的地址中。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%885.16.32.png" alt="截屏2021-06-08 下午5.16.32" style="zoom:50%;" />



## 3.7 驾驭数据总线

显卡，硬盘，USB和网络端口是个人电脑最常用外设。像CPU和存储器一样，它们都是靠电驱动的设备。大多数现代外设包含一到两个大芯片，也许包含一对支持大芯片的小芯片。这些外设都包含地址管脚和数据管脚。一些外设（尤其是图形卡）还拥有自己的存储器芯片，目前他们使用专用的CPU。（现代图形卡是一个拥有自主权的高性能计算机，尽管它只拥有一个特定而有限的使命）。

外设能够与CPU“谈话”，有时也相互通信。所有计算机中的外设都有通用的管脚。这些电线被称为数据总线，它们形成了一种类型的合用线，把CPU连接到计算机的所有其他部件上。一个复杂的电仲裁系统决定这些不同的设备能够在什么时间以什么顺序使用这根合用线来互相“交谈”，但是它经常以同样的方式发生：地址被放到总线上，后面跟着一些数据（一次多少数据取决于所设计的外设）。总线上发出一些特定的信号，用于指明该地址是代表存储器中的一个位置，还是绑定到地址线中的外设。为了和前面一直讨论的存储器地址区分开来，我们将外设地址称为I/O地址。

在大多数个人计算机中，数据总线是出现在扩展槽中的主要元素，而很多外设（尤其是图形卡）就是这些插入扩展槽中的印刷电路板。通过数据总线在扩展槽中的电路管脚实现的连接，外设可以与CPU和内存进行对话。

尽管扩展槽使用起来方便，但它们在计算机内部也会产生一些延迟。简单来说，外设只是计算机内部的主要电路板（主板）上的某个角落处的几个芯片。



## 3.8 车间工长的口袋

即寄存器。

CPU的即时工作过程在名为寄存器的临时存储容器中进行。

大多数外设也有寄存器，外设寄存器的使用范围比CPU寄存器的使用范围更小一些。



## 3.9 流水线

如果CPU是车间工长，那么外设就是流水线上的工人，数据总线就是流水线本身。

问题是：是谁告诉车间工长及其手下员工该做什么事情？是你。你应该怎么做到呢？你编写一个程序。程序从哪里来呢？它在存储器中，与很多存放在存储器中的数据一起。实际上，程序也是数据，它是我们所知的整个编程思想的核心。



## 3.10 遵循计划行事的盒子

正如字母表和数字代表对我们人类有意义的某些内容一样，代码集对CPU也意味着这些内容，这些代码被称为机器指令。并且它们的名字可以通过其实际内容来进行记忆。当 CPU 正在执行一个程序时，它从数据总线上取出一系列数字，每次取出一个。每个数字告诉 CPU 做某件事情。当执行完某条指令时，它取出下一条指令并执行。它继续执行到某些东西（程序中一条指令，或诸如复位按钮的之类的电信号）告诉它停下来。

例如，对于Intel的现代CPU通用的例子：8位二进制编码 01000000(40H)对于CPU来说，意味着一条命令：**向寄存器AX中的值加一，并将其和存回AX**。大多数机器指令不只占用一个字节，很多指令占用2个字节或4个字节。二进制代码1101011001110011 (0B6H 073H)构成另一条指令：把数值73H加载到寄存器DH中。而二进制编码 1111001110100100  (0F3H 0A4H)则能够引导CPU完成以下事情：**开始把由CX寄存器指定数量的字节从存放在DS和SI中的32位地址中取出来，并存入存放在SI和DI中的32位地址处，每移动一个字节，同时更新SI和DI中的地址，并将CX中的值减一，最后当CX中值变为0时，停止执行。**

Intel IA-32 :英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。

Intel IA-32所能理解的其余几百条指令的复杂性和功能大致在这两条指令之间。

**每一条指令一般情况下高速计算机执行一个较小且有限的任务。很多指令被按顺序提交给CPU，以引导其完成更复杂的任务。而写出这些指令序列实际上就是汇编语言编程。**



## 3.11 取址和执行

CPU 一执行完一条指令，就转到存储器，按顺序取出下一条指令。在CPU内部，有一个特殊的寄存器，名为指令指针寄存器，它包含下一条即将从内存中取出和执行的指令的地址。每当一条指令执行完毕后，这个指令指针都被更新为指向内存中的下一条指令。

所有这些都像时钟一样规规矩矩地指向。计算机有一个以电驱动的子系统，叫做时钟系统（system clock），它实际上是一个能够以非常精确的时间间隔发出方波脉冲的震荡器，CPU内部的很多极小的晶体管开关根据系统时钟产生的脉冲来协调它们的行为。

CPU的运行过程是这样的：取指和执行；取指和执行。CPU在指令指针寄存器的指引下在内存中行进。

**计算机程序是存储在内存中的二进制机器指令的列表。在内存中，它们与其他数据字节的列表没有任何区别，只是当被取出时，CPU对它们的解释有所不同。**



## 3.12 车间工长的内脏

大部分CPU内部的开关包含不只一个手柄。这些开关，称为门(gate)，它们根据逻辑规则进行工作。为了让某个开关通过门来实现“关闭”，也许需要两三个或更多个“打开”开关投掷同时到达某个特定的门。

这些门被用于在CPU内建造复杂的内部机制。



## 3.13 改变航向

计算机本质的第一个魅力是：内存中的一串二进制编码一步一步地高速计算机做哪些事情。第二个魅力是皇冠上的真正宝石：有一些机器指令能够改变机器指令被取出和执行的顺序。



## 3.14 是什么 vs 怎么做：体系结构和微体系结构

CPU 的灵魂被清楚地分为两个部分：CPU 做什么事情； CPU如何做这些事情。程序员从外面来看它：CPU做什么事情。设计计算机主板和其他包含Intel处理器硬件系统的电子工程师和系统设计人员需要知道其余内容，但是他们是极少数非常吃苦耐劳的一群人，他们知道自己是谁。



### 3.14.1 体系结构的演变

除了向指令集周期性地添加内容外，体系结构本身也在突飞猛进。这些飞跃的典型情况体现在CPU的“宽度”上。1986年，随着80386 CPU 的引入，Intel的16位体系结构扩展到了 32 位，并且添加了大量的指令和操作模式，CPU寄存器的宽度也怎加到原来的两倍。2003年，X86体系结构继续扩展，这次是到64位，而且又添加了很多新的指令，操作模式和扩展寄存器。



### 3.14.2 地下室里的秘密机制

由于涉及向后兼容问题，除非有非常好的理由，否则 CPU 的设计者们不会再添加新的指令或寄存器到体系结构中。有一些其他的更好的方法来改善 CPU 家族。这些方法最重要的是要提高处理器的吞吐量，它不仅仅是单纯地提高 CPU 时钟频率的问题。另一个是要降低电量消耗。

提高处理器的吞吐量意味着提高同一时间段内 CPU 执行的指令数目。很多神秘的技术与提高吞吐量有关，例如：预读取，L1高速缓存，L2高速缓存，分支预测，超管道和微操作熔合等。

总的来说， CPU 为了完成指令让它做的事情而依赖的所有电机制通称为 CPU 的微体系结构。



## 3.15 操作系统：角落办公室

实际上，我们早期的微机操作系统并不是很强大，也做不了太多事情。它们旋转磁盘，处理存储在磁盘驱动器中的数据，当需要时，将数据送回磁盘。它们接收来自键盘按键的敲击，然后把字符发送到显示器。另一种较少的情况是，它们能够把字符发送给打印机。这就是操作系统。

早期的操作系统，加载应用程序时，系统将会放到软驱中，因为内存空间有限。应用程序执行完比后，操作系统重新加载入内存，等待下一条命令。



### 3.15.1 BIOS：是软件，但并不软

IBM已经将处理键盘，显示器和磁盘驱动器的程序代码单独拿出来并烧制到一种特殊类型的，名为只读存储器（ROM）的存储器芯片上。一般的随机存储器在断电时内容就消失了。而ROM不管有没有电都会保持它的内容，这样成千上万条机器指令就不用从磁盘中加载了，因为它们总是位于一个焊在主板上的ROM芯片里。**ROM上软件称为基本输入输出系统（basic input output system），简写为BIOS，因为它能处理计算机的输入设备（例如键盘）和输出设备（例如显示器和打印机）**



### 3.15.2 多任务魔术

windows95 拥有一些以前PC世界中从未见过的内容：**抢先式多任务处理器(preemptive multitasking)**

windows95营造了一种令人相信的错觉：内存中的所有程序在同一时间内运行。这是通过每一个加载到内存中的程序赋予一个CPU时间片来完成的。程序在CPU上开始运行，它的若干条机器指令将会得到执行。运行一个程序时，经过一段时间之后（通常是几分之一秒），windows95 从第一个程序中“抢回” 对 CPU 的控制权，然后将其交给列表中第二个程序。如此循环。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%8811.22.53.png" alt="截屏2021-06-04 下午11.22.53" style="zoom: 33%;" />



操作系统能够为列表中的每一个程序赋予一个优先级，以便有些程序能够比其他程序获取更多的执行时间。



### 3.15.3 内核提升

Linux 没有像 windows 95 一样精美饿图形用户界面，但是它能够处理多任务，而且内部具有更为强大的结构。Linux的核心是一个名为内核（kernel）的代码块，它充分利用了IA-32 保护模式的优点。Linux 内核与图形用户界面是完全分开的，它被保护起来以防被系统某处非正常工作的程序损坏。系统存储器或者被标示为内核空间（kernel space），或者标示为用户空间，运行在用户空间的任何内容都不能被写入（一般情况下也不能从内核空间读取）存放在内核空间的任何内容中。内核空间和用户空间之间的通信通过严格控制的系统调用来进行处理。

只有运行在内核空间的软件才能直接访问物理硬件（包括内存，显存，外设）。希望使用系统外设的程序只能通过内核模式设备驱动来实现访问。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%8811.39.29.png" alt="截屏2021-06-04 下午11.39.29" style="zoom:67%;" />



### 3.15.4 内核爆炸

2000年初，拥有两个 CPU 插口的台式 PC 开始销售。通过使用“对称多处理(SMP)”机制，Window 2000/xp/7 和Linux都支持在一个单系统中使用多个 CPU。当所有处理器都一样时，处理器是“对称的”。当可以使用两个CPU时，操作系统在大多数情况下在一个 CPU 上运行自己的代码，而在另一个 CPU上运行用户模式应用程序。

随着技术的进步，出现了多核心 CPU，四核以上 CPU是可能的，但是，如何使用这样一笔令人为难的财富仍然需要更多的讨论。



### 3.15.5 计划

计算机是一个能够执行计划的盒子。

这个计划（即内存中的机器指令列表）就是汇编语言程序。本书的核心内容就是学会如何将这些机器指令正确地排列到内存中供CPU使用。

是时候开始近距离观察机器指令引导 CPU执行的操作的本质。如同计算中所有内容一样，操作大部分是在存储器中完成的，这些存储器包括主板上的常规内存，又包括那些记忆之王——CPU 寄存器。



# 第 4 章 位置 位置 位置 寄存器、内存寻址以及了解数据存储位置

## 4.1 内存模式的乐趣

在 32 位 Linux 下编程基本上只限于一种内存模式，一旦对内存寻址深入理解之后，你将会非常喜欢它。

* 最古老的内存模式叫**实模式平面模型**（real mode flat model），它完全僵化，但是相对简单。

* 年纪较大的（现在已经退休了的）内存模式叫**实模式段模型**（real mode segmented model）,这可能是编程语言里学到的最令人讨厌的东西。DOS 编程的最高境界会用到这种实模式段模型，其结果是使程序员们备受折磨。

* 最新的内存模式叫**保护模式平面模型**（protected mode flat model）,它是很多现代操作系统（如windows200/XP/Vista 和 Linux）背后的内存模型。

保护模式平面模型只能用于IA-32 体系结构的 386 及更新的 CPU 中。8086、8088 和 80286不支持。

*实模式平面模型非常像保护模式平面模型的缩影*。 



### 4.1.1 16位将带来 64 k 存储空间

8080 拥有一个 8 位的 CPU（即寄存器的位数），这意味着它一次能够处理八位的信息，然而它却拥有 16 根地址线。CPU 的位数——它的通用寄存器应该包含多少个位，它非常重要。在我看来，衡量  CPU 效率的最重要的标准是它一次操作能够调集多少根地址线

16 根地址线可以寻址 64k 字节，从二进制角度看，可以从0计数到65535。（口语中的“64K” 就是 65536的简称）

。意味着65536个单独的内存位置中任意一个都拥有唯一一个从 0 到 65535 之间的地址。

8080的内存寻址方案非常简单：把一个 16 位地址放到地址线上，然后取出存放在那个位置处的 8 位值。注意：**内存系统中的地址线的根数和存放在每个位置上的数据的位数之间没有必要的关系。**8080在每个位置存放8位二进制数，但是它也能够在每个位置存放 16 位或者 32 位数据，并前仍然使用 16 根内存地址线。



8080 主要使用的操作系统是 CP/M-80。CP/M-80出现在安装内存的顶部，有时为了便于包含在 ROM 中，但更主要的是为了让路，从而允许临时程序拥有一致的内存起点，临时程序被加载到内存中，只有需要的时候才运行。当CP/M-80 从磁盘读如一个程序并运行时，它将程序加载到距离内存底部256个字节的地址为0100H的地方。内存的前 256 **个字节叫程序段前缀**（Program Segment Prefix，简称为PSP），里面包含着各种零碎消息和一个用于程序磁盘输入输出的通用内存缓冲区。

当英特尔创建它的第一个 16 位 CPU——8086时，它想让人们更加容易地将较老的CM/M-80 软件从8080 翻译到 8086——这个过程叫移植。要想做这件事，一种方法是确保 16 位寻址系统（例如8080中的寻址系统）仍能够工作。尽管 8086能够寻址的范围是8080的16倍（16*64KB=1MB）,英特尔将 8086创建为可让程序只占用那 1M 内存里的 64K 字段，并前完全在它里面运行，就好像是小型的 8080 内存系统一样。下图是8080内存模式。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%8812.36.35.png" alt="截屏2021-06-05 下午12.36.35" style="zoom: 67%;" />



这是通过使用段寄存器（segment register）来完成的，从根本上来讲，它们是位于 CPU 寄存器内部的内存指针，指向内存中事情开始的位置，这里所说的“事情”，可能是数据存储，也可能是代码执行或其他内容。

在8086内存的1M字节内，一个从8080世界移植过来的程序即将开始运行，如图4-2.

考虑名为CS的寄存器——它代表代码段（Code segment），它是指向8086的1M字节内存中的某一位置的指针。这个指针作为 64k 内存区域的起始点，在这个区域中，一个快速转换的 CP/M-80 程序能流畅地运行。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%883.16.35.png" alt="截屏2021-06-05 下午3.16.35" style="zoom:50%;" />




短期内来看，这是一个非常明智的考虑，同时，从长期来看，这也是一种非常糟糕的设想。两年之内，许多 CP/M-80程序被转换成了 8086 程序。但是，当程序员们企图从头开始创建全新的，与 8080 从未谋面且不需要段模型的程序时，问题变得严重。段模型控制着 8086 的体系结构。一些一次需要大于 64KB内存的程序不得不使用64KB的内存块，通过切换进入和离开段寄存器的值来实现在这些内存块之间的切换。

这是一场噩梦，没有好的理由要学习它。



### 4.1.2 兆字节的本质

当运行在分段实模式下时，x86 CPU 最多能使用1MB 的可直接寻址内存。这个内存也叫实模式内存（real mode memory）。

1MB内存包含 1048576 字节，地址从00000H到0FFFFFH。

这就是 1M 字节内存：由包含 20 根电线的地址总线所连接的，计算机内部的一些内存芯片组合。通过向那 20 根地址线提供 20 位地址来标示 1MB 中的一个字节。



### 4.1.3 向后兼容和虚拟 86 模式

现代的x86 CPU（例如：奔腾）能够在比这更大的内存范围内进行寻址。对于 8086 和 8088 CPU而言，计算机真正拥有 20 根地址线和1兆内存。386 及其之后的英特尔 CPU 能够寻址4兆内存，而不必把它分成更小的段。当 32 位 CPU工作在保护模式实模型下时，一个段是4GB——所以大多数情况下，一个内存段足够。

然而，很多使用分段技术编写的DOS软件仍然随处可见，我们必须对其加以处理。所以，为了与 8086 和 8088 之前的CPU相互兼容，较新的 CPU 被赋予一种权利，使其能够将自己限制在老式CPU 能够寻址和执行的范围。当一个奔腾级别的 CPU 需要运行为实模式段模型编写的软件时，它将采用一项简洁的技术，暂时把自己变成一个8086，这叫虚拟86模式（virtual-86 mode），他对DOS软件提供了非常好的向后兼容性。



### 4.1.4 16位眼罩

在实模式段模型里，X86 CPU 可以“看到”整整 1MB 的内存。也就是说，CPU 芯片能够将自己设置为只能使用32个地址引脚中的20个，进而向存储器系统传递 20 位的地址。对于实模式段模型，虽然这些 CPU 可以看到整整 1M 字节内存，但是它们被限制为只能使用 16 位眼罩来看那 1 M字节。

CPU 看到的实模式段模型下的内存很特殊。它被限制为以块的方式查看内存，这些块中的长度都不超过 65536 字节，也就是我们所说的“64KB”。利用这些块——也就是说，知道目前正在使用哪一块以及如何从一个块移动到另一个块——是实模式段模型编程所面临的真正挑战。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%884.57.43.png" alt="截屏2021-06-05 下午4.57.43" style="zoom:50%;" />



## 4.2 段本质

段是一个内存区域，它从一个段落边界开始，并且扩展一定数量的字节。在实模式分段模型中，这个数量小于或者等于 64K（65536）。

现在来上一段古老的86家族琐事的课。段落(paragraph)是一个内存度量，等于 16 个字节大小，它是用于描述不同内存容量的众多技术术语之一。我们之前已经见过了其中一些，它们都是1个字节的偶数倍。请记住：字节是原子数据；松散的内存位更像是亚原子粒子，如果包含它们的一个字节（或更多字节）“缺席”，这些内存位就根本不存在。有些术语使用频率较其他的高，例如下表：

| 名称 | 十进制值 | 16 进制值 |
| ---- | -------- | --------- |
| 字节 | 1        | 01H       |
| 字   | 2        | 02H       |
| 双字 | 4        | 04H       |
| 四字 | 8        | 08H       |
| 十字 | 10       | 0AH       |
| 段落 | 16       | 10H       |
| 页   | 256      | 100H      |
| 段   | 65536    | 10000H    |

任何能被 16 整除的内存地址称为一个段落边界（paragraph boundary）。第一个段落边界是地址0；第二个是地址 10H；第三个是地址20H。任何一个段落边界都可以被认为是另一个段落边界的开始。

在实模式段模型中，一个程序可能只使用四五个段，但是这些段中的每一个可能开始于65536个段落边界之中的任何一个，当然，这些段落边界位于这1MB在实模式段模型中可用的内存里。

每一个段都有一个编号，这些编号从0开始，一直到64k-1，用十进制表示是 65535，用十六进制表示是 0FFFFH。因为一个段落可能开始于任一段落边界，所以把段开始的那个段落边界的编号叫做段的段地址。如图4-4，每个阴影都是一个段地址，没16个字节开始的一个段。最高段的段地址为0FFFFH，它距离实模式1MB内存的最顶部16个字节。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%885.47.48.png" alt="截屏2021-06-05 下午5.47.48" style="zoom:50%;" />



总之，段可以开始于任意段地址。共有 65536个段地址均匀地分布在实模式下的满满 1MB 内存中，每两个段之间相隔 16 个字节。以其说段地址是一个强制，不如说它是一个许可；对于所有64K个可能的段地址而言，只有五六个在某一时段被真正用作段的开始。

关于段的理解，最重要的一点是，它最大可达 64K 字节，但不一定非要那么大，一个段可能只有一个字节长，或者 256个字节长， 或者21378个字节长，或者任意小于64K的字节长。



### 4.2.1 一个界限，而非一个位置

一种对段的错误的认识就是：段是某种类型的内存位置，一旦预留出来用于某些特定应用的，两侧都有墙壁保护内存区域。

这个观点完全不正确。在实模式下，段内的任何内容都不受保护，而且段并没有被预留出来供某些特定的寄存器或访问方式使用。段也可以重叠。

我的观念是这样的：段是内存中安装 CPU 的64KB 眼罩的位置。通过这个眼罩查看内存，能够看到从段地址开始，一直到眼罩组织你的沿途所有字节，一共64KB。



### 4.2.2 用两个 16 位寄存器构成 20 位地址

寄存能够做很多工作，但最重要的一项也许就是存放内存中某些重要位置的地址。8086 和 8088 有 20 个地址引脚，它们的 1M 字节内存（它是我们正在谈论的实模式分段内存）需要 20 位大小的地址。

无法把一个 20 位的地址放到一个 16 位的寄存器中。但可以把一个 20 位的地址放入两个 16位 的寄存器中。内存中的每个字节都假设位于某个段中。那么，一个字节的完整地址包含它所在段的地址，还有该字节距离那个段的起始位置的的字节数是它的偏移地址。两个地址都指定才能完整描述实模式下整整一兆内存中的任意个字节的地址。在书写时，段地址写在前面，偏移地址写在后面，两者用“:”隔开。x86编程公约规定，当用这种形式表示一个地址时，不用在这两个十六进制数的结尾加上字母H。

发生的意外情况是：所有位于实模式下的 1MB 内存中的存储位置不是只有一个地址。如下图所示，一个我们称之为“MyByte”的字节数据存放在内存中用黑色标示出来的位置

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%886.28.41.png" alt="截屏2021-06-05 下午6.28.41" style="zoom:50%;" />



严格来说，它实际位于哪一个段只是一个习惯问题。

这很尴尬，但它是多年以来我们能够做到的最佳方式。



## 4.3 16位和32位寄存器

段地址可被看作实模式下的 64KB 眼罩的起始位置。通常情况下，你会移动眼罩以找到希望工作的位置，然后把眼罩留在一个地方，在它周围的 64K 限制以内的空间范围移动。

这正是寄存器在实模式段模型下汇编语言中的用法。在8088，8086和80286中，有 4 个专门设计用于存放段地址的段寄存器。386 及后来的处理器又多了两个，它们也可以在实模式下使用。

段寄存器拥有反应其一般功能的名字：CS，DS，SS，ES，FS和GS。FS和GS只出现在386及更高版本的 Intel x86 CPU中，但大小仍然是32位。

* CS（code segment）代表代码段。机器指令存放在代码段的某些偏移位置处。CS中包含当前执行指令的代码段的段地址。
* DS（date segment）代表数据段。变量和其他数据存放在数据段的某些偏移位置处。也会有很多个数据段，，但 CPU 一次只能使用一个，这是通过将该段的段地址放入寄存器DS来实现的。
* SS（stack segment）代表堆栈段。堆栈是 CPU 用来暂时存放数据和地址的一个非常重要的部件。堆栈也是一个段地址，这个地址存放在SS中。
* ES（extra segment）代表附加段寄存器。附加段寄存器是一个可用于指定内存中某一位置的备用段。
* FS和GS是ES的克隆。它们都是额外的段，没有特殊的工作或专长，它们只存在于386 及后来的x86 CPU 中。



### 4.3.1 通用寄存器 

x86 有很多通用寄存器，它们用来做汇编语言计算的其余工作，在很多其他事情（除了计算之外的），这些通用寄存器用来存放偏移地址，它必须与段地址成对出现。它们还经常用于存放算术运算值。

从386开始的较新的 32 位 x86 处理器之间最大，最明显的区别之一：通用寄存器的大小。像段寄存器一样，通用寄存器也是 CPU 芯片本省内部的存储位置；也像段寄存器一样，它们都拥有自己的名字。

通用寄存器真的是通才，但是有些寄存器只能完成某些特殊的功能。有些特殊功能只是在老式的 16 位 CPU 中才会受到限制。

在32位世界中，通用寄存器分为三个一般类：16位通用寄存器，32位扩展通用寄存器和8位的半寄存器。这三类并不代表三个完全不同的寄存器。16位和8位寄存器实际上是32位寄存器内部的一块区域的名字。

有 8 个 16 位通用寄存器：AX，BX，CX，DX，BP，SI，DI和SP。（SP 不如其他通用寄存器通用性强，但有时会用到）。

当 Intel 于1986年将其 x86 体系结构扩展为32位时，它把所有 8 个寄存器的大小增加了一倍，并且通过在原有的名字前面加上前缀 E 来对他们进行重新命名，形成了EAX，EBX，ECX，EDX，EBP，ESI，EDI和ESP。

虽然扩展了新寄存器，但老寄存器一点没丢。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%889.14.24.png" alt="截屏2021-06-05 下午9.14.24" style="zoom:50%;" />





上图展示的 4 个寄存器都完全是 32 位大小。然而，在每个寄存器里，低 16 位都拥有自己的名字。例如，ESI的较低的 16 位可以用 SI 来进行引用。

32位通用寄存器的高 16 位没有自己的名字。



### 4.3.2 半寄存器

有 4 个通用寄存器（EAX，EBX，ECX和EDX），它们的低 16 位本身被分成了两个 8 位寄存器，所以我们不是拥有两个寄存器，而是拥有三个级别的寄存器。16 位寄存器AX，BX，CX和DX作为EAX，EBX，ECX和EDX的低16位而存在，而AX，BX，CX和DX又被分为 8 位的半寄存器，编译程序能够识别这两个“半寄存器”的特殊名字。

字母A，B，C和D仍然保留，但是，半寄存器不再使用X，而是用一个H（高半寄存器）和L（低半寄存器）来表示它。每个半寄存器的大小都是一个字节（8位）。因此，字节大小的半寄存器 AH 和 AL 构成了 16 位寄存器 AX。依次类推。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%889.29.10.png" alt="截屏2021-06-05 下午9.29.10" style="zoom:50%;" />



### 4.3.3 指针指令寄存器

代码段（code segment）是一块存储机器指令的内存区域。程序执行的测试和步骤就包含在代码中。根据使用的编程模型，一个程序可能有多个代码段或者只有一个。当前代码段（current code segment）是指段地址当前正存放在代码段寄存器CS中的那段代码。在任意给定的时间里，当前正在执行的指令都出现在当前代码段中。在实模式段模型里，CS 中的值经常变化。在两个平面模型里，CS中的值（几乎）从来没有变化，当然，在保护模式下的所有段寄存器都“隶属于” 操作系统，一般应用程序不能修改它。

当执行程序时，CPU 使用 IP 来跟踪位于当前代码段中的位置。每执行一条指令后，IP 就递增一定数量的字节，这个字节刚好是执行的那条指令的大小，最终的结果是，IP 跳到了更远的地方，指向了下一条即将执行的指令的开始位置。指令有不同的大小，典型的大小是1到6个字节，（其中有些更神秘的指令的更神秘的形式可能更大些）。CPU 谨慎地将 IP 怎加正确数量的字节数，因此，它实际最终指向下一条指令的起始位置。

CS 和 IP 一起，保存下一条即将执行的指令的完整地址。

地址的本质取决于使用的 CPU，以及正在使用的针对该 CPU 的编程模型。在 8088，8086和80286中，IP的大小是 16 位的。在 386 及更高的 CPU 中IP（像除段寄存器之外的其他所有寄存器一样）增加到 32 位的规模，变成EIP。

在实模式段模型中，CS 和 IP 一起工作，带来了一个 20 位的地址，指向实模式内存中的 1048576 个字节之一。

在两种平面模型中，CS 由操作系统设置并且保持不变，IP完成你（程序员）必须处理的所有指令指向。在 16 位平面模型中（实模式平面模型），这意味着IP可以跟踪所有 64K 内存段内的指令执行。 32 位平面模型做的远远超过其一倍，32位可以代表 4294967296 个不同的内存地址。因此在 32 位平面模型（即，保护模式平面模型）中，IP可以追踪 4GB 内存范围内的指令执行。

 IP是唯一不能直接读出，也不能直接写入的寄存器。有一些技巧可以用来获取当前 IP 寄存器的值。



### 4.3.3 标志寄存器

在8086，8088和80286中，它的大小是16位，并且它的正式名称是FLAGS。在 386 及更高的 CPU 中，它的大小是32位，正式名称是EFLAGS。标志寄存器的大多数位都可以作为名为标志位的一位寄存器来使用，这些单个标志位都有一个名字，例如CF，DF，OF等，并且每一个在CPU 内部都有一个特殊的含义。



## 4.4 三种主要的汇编模型

### 4.4.1 实模式平面模型

在实模式平面模型下，程序和它处理的所有数据都必须位于一个 64 KB 大小的内存块中。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-07%20%E4%B8%8B%E5%8D%888.55.30.png" alt="截屏2021-06-07 下午8.55.30" style="zoom: 50%;" />



由于 16 位寄存器可以容纳从 0 到 65535 之间的任意值，所以它能够精确定位程序使用的 64 KB 空间中的任一字节。因此内存寻址寻址不必显式使用段寄存器。当然从 CPU 的角度来看，段寄存器仍然在发挥作用，它并没有消失，只是当你加载程序的时候，操作系统会根据自己的选择来设置它的值。



### 4.4.2 实模式段模型

在实模式段模型下，程序可以看到在实模式下 CPU 可用的整个 1MB 内存。它通过把 16 位的段地址和 16位的偏移地址结合在一起来做到这一点，但它们不是简单地组合在一起，可以把一个段地址乘以 16 来将其翻译成一个真正的 20 位内存地址。因此，段地址 0002H相当于内存地址 0020H，这是内存中第 32 个字节。



这种乘法不需要程序员来做，CPU 会在内部将段地址和偏移地址组合成一个完整的 20 位地址。你的工作是告诉 CPU 那个 20 位地址的两个不同组成部分。惯用的表示方法是在段寄存器和偏移寄存器之间用一个冒号隔开：

SS:SP

SS:BP

ES:DI

DS:SI

CS:BX

图4-9 通过一幅简图来勾勒实模式段模型。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-07%20%E4%B8%8B%E5%8D%889.18.10.png" alt="截屏2021-06-07 下午9.18.10" style="zoom:50%;" />



该图显示了两个代码段和两个数据段。在实践中，可以有任意合理数量的代码段和数据段。你可以在同一时间访问两个数据段，因为有两个段寄存器可以做这项工作：DS和ES（在386及更高版本的处理中，还有两个附加段寄存器：FS 和 GS）每个都可以指定一个数据段，并且可以通过使用机器指令将数据段从一个段移动到另一个段。但是你只有一个代码段寄存器：CS。CS总是指向当前的代码段，IP寄存器指向下一条即将执行的指令的地址。不能直接加载一个值到 CS 中来实现一个代码段到另一个代码段的改变。如果必要的话，名为跳转的机器指令可以实现到另一个代码段的改变。



任意一个单独的程序都只有一个堆栈段，它有堆栈段寄存器 SS 来指定。堆栈指针寄存器 SP 指向下一条堆栈操作即将发生的(相对于SS而言，方向刚好是颠倒的)内存地址。



必须记住，在实模式下，也许有几个操作系统(如果你使用的是 8086 或 8088，那将是整个操作系统)与你的程序一起存在于内存中，同时还有一些重要的系统数据表。你可能由于粗心使用段寄存器而破坏部分操作系统，这将导致操作系统崩溃，并导致你的程序与之一起崩溃。正是这一危险促使促使英特尔在它的80386 及 更新的 CPU 上建立新的属性来支持 “保护模式”。在保护模式下，应用程序(也就是你写的程序，与操作系统或设备驱动程序相对)不能破坏操作系统或其他通过多任务技术碰巧在内存中运行的应用程序。



### 4.4.3 保护模式平面模型

由于Windows的历史遗留问题，目前可以为 Linux 和 NT 之后的windows 编写保护模式汇编语言程序。

编写保护模式程序的最简单方法是创建控制台(console)应用程序，它是文本模式程序，运行在一个名为控制台的文本模式窗口下。例如windows的CMD，Linux 下的终端。

图 4-10 表示保护模式平面模型。你的程序看到的是一块地址从0一直到4G-1的内存。每个地址都是一个 32 位的量。所有通用寄存器的大小都是 32 位，因此一个通用寄存器可以指向整个 4GB 地址空间中的任何位置。指令指针寄存器的大小也是 32 位，所以 EIP 可以指向 4GB 内存空间内的任何地方的任何机器指令。



段寄存器仍然存在，但是它们以一种完全不同的方式工作。不是你不一定受它们愚弄，而是你已经不能受它们愚弄。现在，段寄存被认为是操作系统的一部分，在几乎所有情况下，你既不能直接读取它们，也不能直接修改它们。它们的新工作是定义你的 4 GB 内存空间出现在物理内存或者虚拟内存的什么地方。物理内存可能远大于 4GB，而且目前 4GB 的内存并不是特别贵。然而一个 32 位的寄存器只能表示 4294967296 个不同的位置，你的程序仅限操纵该区域的内存。在较大的内存系统中定义 4GB 区域的范围，这就是段寄存器的工作，而且操作系统让它们寸步不离其“防护衣”。

虚拟内存，它是一个系统，可以根据它将一个更大的内存空间“映射”到磁盘储存器中，因此即使你的计算机中只有 4GB 的物理内存，CPU也能够处理一个数以百万计字节，更大空间的“虚拟内存”。这也是由操作系统来处理的，而其处理方式对你编写的软件几乎完全透明。

当程序运行时，它将得到一个 4GB 的地址空间来施展手脚，任何一个 32 位寄存器完全依靠自己就可以访问这四十亿字节内存中的任一位置。这是一个过于简化的描述，对于普通的基于 Intel 处理器的台式电脑而言，并非所有的 4GB 内存都是你的程序可以支配，这些内存空间你不但不能使用，



比较一下实模式平面模型和保护模式平面模型。

* 区别：在实模式平面模型下，你的程序拥有操作系统交给它的整整 64KB 内存空间。在保护模式平面模型下，你将得到分配给自己的 4GB 内存中的一部分，而其他部分仍属于操作系统。
* 相似：通过(GP)寄存器本身可以指定整个内存地址空间中的任一内存位置，段寄存器是操作系统的工具，而不是(程序员)的工具

> 同样，在保护模式平面模型下，一个通用寄存器可一存放其 4GB 空间内的任意位置的地址，但是当真正读取或写入某些位置时，会被操作系统禁止并且触发运行时错误。

内存寻址和寄存器都是业务的关键。如果了解了它们，指令将是小事一桩。保护模式平面模型下编程的困难在于了解操作系统及其要求和限制。





## 4.5 保护模式下不再允许我们做的事情



### 4.5.1 内存映射系统

显卡包含一定数量的内存，这块内存“映射”到个人电脑的物理内存空间。换句话说，在访问显卡过程中并没有什么“魔术参与”。简单的将数据写到由段地址：偏移地址指定的，位于显卡包含的内存范围内的某一地址，就可以将一些内容显示在显示器上。

这种技术允许程序显示满满一屏文本，这些文本将一下子弹入我们的视野，没有任何文字从上到下有逐渐出现的感觉。即使是在早期那些拥有慢得令人难以置信的 CPU 芯片的机器上。内存缓冲区的组织非常简单：从地址0B00:0(或彩色显示器0B00:0)开始，是一个两字字节的数组。每个字的第一个字节是一个字符的ASCII 编码。例如，数字 41H是大写字母"A"的编码。第二个字节是一个文本属性：字形的颜色，字符单元格的背景颜色，或者下划线之类的特殊表示方法。



多了在多任务处理时不导致输出混乱，操作系统不得不通过精心制作的视频显示代码库来“管理”视频，依次地，这些代码库通过与内核一同位于内核空间的驱动程序访问显示硬件。驱动程序使得操作系统能够限制单个程序到屏幕的视频输出，以便任意数量的正在运行的程序可以同时显示其输出，而不必和所有其他程序的输出发生碰撞。



综上所述，有一种方法能够在用户内存中建立一个缓冲区，然后告诉Linux 把它当作显存来使用。这涉及到一些与 Linux 帧缓冲设备 dev/fb0，及函数mmap 和 ioctl 相关的忙乱工作，但是它不够简单和迅速。



在本书的后面，将会介绍一个控制台窗口和VT100终端控制序列演示一种颇受青睐的处理文本屏幕输出的Linux方法。



### 4.5.2 直接访问端口硬件

在 DOS 时代，个人电脑拥有由主板上单独的控制器芯片所控制的串行端口和并行端口。与计算机的所有其它组件一样，这些控制器芯片可被运行在DOS下的任意软件直接访问。

加上一些聪明才智，你可以让标准的计算机硬件做它并不真的打算做的事情。



同视频一样，多任务需求也要求操作系统管理对端口的访问，这可以通过驱动程序和代码库来访问，但是与视频不同，使用驱动程序作为端口处理的接口实际上比完全靠自己控制端口简单得多。



### 4.5.3 直接调用 BIOS

在 DOS 时代，有可能直接用软件直接调用BIOS例程，而没有任何限制。

保护模式预留出 BIOS 调用给操作系统，但是说实话，那个实话，即便是保护模式下的操作系统，也很少直接调用BIOS，几乎所有的低级硬件访问都是通过可安装的驱动程序来完成的。操作系统大多利用 BIOS 调用来确定诸如电源管理之类的事情的硬件配置信息。



作为一个安慰奖，Linux 提供了一个低级函数列表，可通过一个与 BIOS 调用非常相似的机制来进行调用，即使用软件中断 80H。

在本书的稍后部分，将讲解软件中断。



## 4.6 展望未来：64位 “长模式”

x86-64 体系结构定义了三个一般模式：实模式、保护模式和长模式。

IA-32：英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。

* 实模式

  是一种兼容模式，它使 CPU 能够运行旧的的实模式操作系统和软件，如 DOS 和 Windows 3.1。在实模式下，CPU 像 8086 或其他 x86 CPU 在实模式下一样工作，并且支持实模式平面模型和实模式段模型。

* 保护模式

  也是一种兼容模式，使得 CPU 在软件看来就像是一个 IA-32 CPU ，以便x86-64 处理器能够运行windows 2000/XP/Vista/7 和其它的 32 位操作系统(如Linux)，以及它们的 32 位驱动程序和应用程序。

* 长模式

  是实 64 位模式；在 CPU 长模式下，所有的寄存器都是 64 位宽，所有工作于 64 位的机器指令都是可用的。



左右在 IA-32 下可用的寄存器依然存在，并已经被扩大到 64 位宽。64位寄存器被以 R 开头进行重新命名。

例如 EAX 变成 RAX，EBX变成RBX。8个全新的 64 位通用寄存器R8到R15，还增加了 8 个 128位的SSE 寄存器(快速数学运算特性)， 



### 64 位内存：前景 VS 现在

64位 可以寻址 16 艾字节，艾字节是 2<sup>60</sup>个字节，等于十亿GB。

今天可以买到的x86-64 CPU能实现 48 位虚拟内存地址，但是只能实现 40 位物理内存地址。2<sup>40</sup>是1T字节。

64位长模式仍然是平面模型，它与 32 位平面模型的相似之处，远远超过了 32 位平面模型与愚昧的实模式段模型的相似之处。



# 第 5 章 汇编的权利 汇编语言程序的创建过程

汇编语言的组织方式与C，Java或者 Pascal 的组织方式不同。最明显的区别是，不能通过试验和错误来编写汇编语言程序。



## 5.1 文件及其包含的内容

所有编程过程都是处理文件的过程。有些编程方法隐藏了其中一些文件，所有方法在一定程度上都是为了让人类更加容易地了解这些文件里面的内容，但底线是你要创建文件，处理文件，阅读文件和执行文件。



对于汇编语言，文件在我们面前什么都没隐藏，要想学好它，你必须愿意进入你所处理的任何文件的内部，通常在字节，更多的是在位的层面去理解它。者需要更长的时间，但是它会给你带来巨大的知识回报：**你将知道一切是怎么工作的**。



### 5.1.1 二进制文件 VS 文本文件

文本文件(text file)是指可以在文本编辑器(如记事本)中打开并能进行有意义地检查的文件。

二进制文件(binary file)是指包含不能显示为有意义的文本的值的文件。



从某一高度来看，汇编语言(或许多其他语言)编程的过程包括采用人类可读的文本文件，以某种方式将它们转化为含有 CPU 能够理解的二进制指令序列。

作为程序员，还需了解哪些文件代表哪些机器指令，以及每个机器指令是如何被处理的。你还需能够“打开”一个可执行的二进制文件并检查它所包含的二进制值。



### 5.1.2 用 Bless 编辑器查看文件内容

左边一栏是偏移列：它包含显示在中间一栏里的那一行的第一个字节与文件开头的第一个字节的偏移量。

最右一栏：用可视化的文本字符以文本形式显示同一行数据。



\r\n 的历史：

在电传打印机时代，有两个单独的电命令被内置到电传机中，当答应文档时，用它们来处理文本行的结束。一个命令用于索引文件的下一行，另一个命令用于返回到左边距处的打印开始处。它们被称为回车(0DH)和换行(0AH)。大多数计算机系统和软件现在忽略回车码，但是也有少数(如记事本)仍然需要它来正确显示文本文件。



0AH 是一个非常好的 EOL(行结束)标记。



### 5.1.3 解释原始数据

在文本文件中，二进制:01010011表示大写字母"S"，在一个二进制可执行文件中，位模式 01010011 可能意味着完全不同的内容，这取决于它刚好位于文件中的位置，以及在该文件中，它的附近存在着哪些其他位模式。



### 5.1.4 字节序

假设内存中存在这样一段位数据(16进制表示): 5361，因为该数据占用两个字节，用不同的字节序有不同的解释。

53为最高有效字节，61为最低有效字节。

我们规定：

多字节值的最高有效字节的的偏移量最小，最低有效字节的偏移量最大，称为**大端序**

多字节值的最高有效字节的偏移量最大，最低有效字节的偏移量最小，称为**小端序**

如下图所示：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%883.40.09.png" alt="截屏2021-06-08 下午3.40.09" style="zoom: 67%;" />





字节序不同，对多字节数据的解释就不同，因此必须明确自己系统中所用的字节序。图5-6 显示了采用不同字节序计算一个 32 位值的区别。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%883.45.20.png" alt="截屏2021-06-08 下午3.45.20" style="zoom:67%;" />



## 5.2 文本进去，代码出来

从某一高度来看，所有程序都归结为文件处理。其目标是采用一个或多个人类可读的文本文件，然后对其进行处理，创建一个可执行程序文件。

程序翻译器(program translator)是生成 CPU 可以理解的机器指令的翻译过程。程序翻译器一行一行地读入源代码文件，并写出一个完成源代码文件所描述的计算机操作的二进制机器指令文件。这种二进制文件称为目标代码文件(object code file)。

编译器(compiler)是一种程序翻译器，它读入采用高级语言(如 C 或 Pascal)编写的源代码文件，并写出目标代码文件。

汇编编译器(assembler)是一种专用编译器。它也是一种程序翻译器，用于读取源代码文件并将其输出为供 CPU 执行的目标代码文件。但是，汇编编译器专门设计用来把汇编语言翻译成目标代码。语言编译器(如 Pascal 或 C++编译器)将源代码文件编译为目标代码文件，采用类似的描述，我们说，汇编语言编译器将汇编语言源代码文件编译为目标代码文件。

汇编语言具有非常重要的特征，也正是这一点，使它在众多编译器中与众不同，即：完全控制目标代码。



### 5.2.1 汇编语言

有些人把汇编语言定义为一种语言，在这种语言中，一行源代码生成一条机器指令。但绝不能按照字面意义去理解，因为汇编语言源代码文件中的某些行是翻译器程序(而不是 CPU)的指令，根本不产生机器指令。



#### 汇编语言定义：

汇编语言(assembly language)是一种翻译器语言，它运行完全控制有翻译器程序生成的每一条机器指令。这种翻译器程序称为汇编编译器。

高级语言，例如Pascal对每一条语句，例如`I := 42;`可能翻译为四五条机器指令，这些指令获取字面数字值 42，将其存储在名称 I 编码的内存位置。通常情况下，Pascal 程序员根本不知道那四五条指令实际是什么，也完全没有办法改变它们，即便知道一个比编译器使用的机器指令序列更快速和更高效的指令序列，除了接受 Pascal 编译器生成的机器指令，别无选择。



#### 在高级语言中使用汇编：

现代的高级语言编译器通常采用所谓的行内汇编(in-line assembly)，它允许程序员从编译器“收回”控制器，“插入”一系列他或她自己设计的机器指令。在使用行内汇编之前，你必须了解编译器如何生成自己的代码(并且在没有进行大量的学习研究和实践之前，不要想很多人那样，想当然认为自己能够比编译器做得更好)



CPU 有很多机器指令，其中每一条都有一个对应的汇编语言助记符。助记符的目的就是为了帮助程序员记住二进制机器指令。例如能够实现将标志寄存器压入堆栈的二进制机器指令是 9CH， 它的助记符是 PUSHF，这比记忆9CH 容易多了。



编写汇编语言源代码文件实际上是在组织一系列助记符，通常情况下，在源代码文本文件中每行放一个助记符，一个源代码文件中的部分内容可能是这样的：

```asm
mov eax,4                      ; 04H 指定系统写内核调用
mov ebx,1                      ; 01H 指定标准输出
mov ecx,Message                ; 把要显示的字符串的起始地址加载到 ECX 中
mov edx,MessageLength          ; 把要显示的字符串的字符个数加载到 EDX 中
int 80H;                       ; 进行内核调用
```

上述代码中，左边距处的 MOV 是助记符。紧挨着每一个助记符的数组和文本叫做操作数。 各种个样的机器指令拥有各种各样的操作数，也有一些指令(如前面所述的 PUSHF)根本不使用操作数。

助记符和它的操作数合在一起称为指令(instruction)。(分号右侧的语句是注释，它们不是指令的组成部分)。如果特别谈论二进制代码，通常称为机器指令。

汇编编译器最重要的工作是从源代码中读出一行行语句并将机器指令写出到目标代码文件。如下图：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%884.43.10.png" alt="截屏2021-06-08 下午4.43.10"  />



### 5.2.2 注释

每条指令的右侧是以分号开始的文本。该文本叫注释，其目的显而易见：解释相关汇编语言指令的作用。

在结构上，注释始于一行的第一个分号，一直持续到标示该行行尾的EOL。注释块也很简单，它的每一行都以左边距处的分号为开始。

#### 汇编编程建议

注释对于汇编语言程序的成功而言至关重要，其重要性远远超过任何一种其他编程语言。我的个人建议是：源代码中的每一条指令都应该有关于其功能及作用的相应注释。此外，在每组以某种方式共同工作的指令前面，都应该有一个注释块，从某一高度解释这组指令，以及它们如何协同工作。

注释对于理解文本文件非常重要。

简而言之：注释开始于分号，结束于EOL。



### 5.2.3 当心 “只写” 源代码

汇编语言中有一种非常严重的问题。汇编指令本身非常简洁，以至于任何有用的事情都需要许多条指令才能完成。除此之外，尽管每条指令声明了它所做的事情，但是并没有任何内容表明该条指令操作的上下文环境。在 Pascal 或者 Basic 代码中，可以通过一些技巧和规则(以及一些见名知意的标识符)构建上下文环境，但是在汇编语言中，只能通过注释来添加上下文环境。



编写汇编语言程序需要投入大量的时间和精力——远远超过在那些“一半天堂”的语言(如 C 和 C++)，并且匪夷所思地超过那些“什么都替你做了”的IDE集成环境(如 Delphi，Lazarus 和 Gambas)。汇编语言程序的编写方式比任何一种其他语言程序的编写方式都困难；如果不添加注释，你很可能最终只能丢弃令人费解的数百行代码，从头开始，再编写一遍。



**聪明地工作。不停地写注释，直到退出**



### 5.2.4 目标代码和连接器

汇编器读入源代码文件，并生成包含 CPU 能够理解的机器指令以及所有在源代码定义的数据的目标代码文件。这样的一步到位汇编并没有什么真正的价值，除非你刚刚开始学习汇编语言。

因此，现代汇编编译器产生的目标代码文件是一种源代码文件和可执行文件之间的中间步骤。这个中间步骤是一种类型的二进制文件，叫做目标模块(object module)，或只是一个简单的目标代码文件。

目标代码文件本身并不能作为程序运行。想要把目标代码变成可执行程序文件，还需要一个额外的必要步骤，那就是连接(link)。

目标代码文件作为中间步骤的原因是：大的源代码文件可以划分为许多更小的源代码文件，以保持文件大小和复杂性的可管理性。汇编编译器单独汇编各种各样的片段，然后将生成的目标代码文件交织在一起，组成一个可执行程序文件。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/assembler1234.png" alt="assembler" style="zoom:67%;" />

连接器不只是把目标代码组合成一个单个的块。它确保模块以外的函数调用能够到达目标对象模块，并且确保所有此类内存引用实际上指向它们期望引用的地方。汇编编译器的工作是显而易见的；连接器的工作是微妙的。两者对于产生一个已完成的，能够工作的可执行文件来说，都是必不可少的。



开始将程序中经常使用的部分提取到自己的个人代码库，这样做有两个原因。

1. 可以把已通过测试和验证的程序放到单独的库文件中，将其连接到任何可能需要它们的程序中。这样就可以重用代码，而不是每一次都重蹈覆辙，重新开始一个新的汇编语言编程项目。
2. 一旦一个程序的部分内容已经通过测试，并且发现是正确的，就没有必要浪费时间让它们随较新的，未经测试的程序部分一起，一遍又一遍地重新编译。一旦一个主要程序增长到成千上万行代码(这一时刻可能会比你预想的更快到达！)，通过只编译当前正在工作的那部分程序，然后将已完成部分连接到最终程序，不必每次重新编译整个程序的每一个组成部分，可以节省大量的时间。



连接器的工作复杂，而且不容易描述。每个目标模块可能包含以下内容：

* 程序代码，包括已命名过程。
* 对外部模块中存放的已命名过程的引用。
* 已命名数据对象: 具有预定义值的数字和字符串。
* 为程序以后使用的预留的，只是空白空间的已命名数据对象。
* 对存放在模块外部的数据对象的引用。
* 调试信息。
* 一些用来帮助连接器创建可执行文件的其他不太常见的杂项。



要想将若干个目标模块处理成一个单个的可执行模块，连接器必须首先建立一个索引，这个索引叫做符号表(symbol table)，里面存放的是它连接的每一个目标模块中的每一个已命名项，其中存放着一些关于哪个名字(叫做符号)指向模块内部哪个位置的信息。一旦符号表完成后，连接器将生成一个映像，里面存放着当操作系统加载它时，如何将可执行文件安排在内存中的相关信息。然后，该印象被作为可执行文件写入磁盘。

关于映像，最重要的事情是：连接器生成相关的地址。一个目标模块允许引用其他目标模块中的符号。在汇编过程中，这些外部引用(external reference)被作为“小洞”预留下来，以后再填补——顺理成章，因为这些外部符号存在的模块可能还没有编译，甚至还没有编写。当连接器生成一个最终可执行程序文件的映像时，它知道所有这些符号位于该映像的什么地方，从而可以把所有的实际地址放入那些外部引用“小洞”。

调试信息可以让程序员在调试时更容易看到数据项的名字。

一旦程序制作完成，并完全通过调试，再一次在不带调试信息的情况下重新运行汇编编译器和连接器。因为调试信息可以让可执行文件大很多，而且运行速度会变慢一些。



### 5.2.5 重定位能力

最早期的计算机系(如运行 CP/M-80的 8080 系统)的内存地址体系结构非常简单。程序也被设计为加载并运行在一个特定的物理内存地址。对上述系统，对程序员而言任何程序都将从100H开始，然后从那里往后延伸。

随着 8086 及其特头的操作系统的到来(如 CP/M-86 和 pc DOS)，一切都发生了变化。与 8086 一同引入的 Intel 体系结构内部有了很大的改进，从而使程序无需被编译为在特定的物理地址运行。可执行文件内部的所有引用都是通过相对于该程序起始位置的偏移量来指定。偏移量总是相同的，并且因为所有的引用都是相对于可执行程序文件的起始位置，所以，在运行时，程序存放在物理内存中的什么地方都没有关系。

这种特性叫可重定位能力，它是所有现代化计算机系统的必要组成部分，特别是当多个程序可以同时运行时。处理重定位也许是连接器的最主要工作。

幸运的是，它自己能够完成此项工作，并不需要任何来自外界的输入。一旦任务完成且善后工作处理完毕，文件翻译工作就彻底完成，你将得到一个可执行程序。



## 5.3 汇编语言的开发过程

在编写，编译，测试汇编语言程序的过程中，包含很多种不同类型的文件和相当多的程序。可以用下图描述这个过程。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%8810.19.26.png" alt="截屏2021-06-08 下午10.19.26" style="zoom:67%;" />



概括讲，这个过程可归结为如下内容：

(1) 在文本编辑器中创建汇编语言源代码文件。

(2) 用汇编编译器从源代码文件创建目标模块。

(3) 使用连接器把目标模块(和任何以前编译的，也是该项目的一部分的目标模块)转换为单个的可执行文件。

(4) 通过运行程序文件来对其进行测试，如果有必要，可以使用调试器。

(5) 回到步骤(1)中的文本编辑器，修复以前可能犯下的任何错误，并在必要时编写新的代码。

(6) 重复步骤(1)到(5)，直到完成。



### 5.3.1 工作目录规范

程序员通常从 0 开始计数，如果对汇编语言开发过程的步骤进行计数的话，步骤0包含的内容为：在Linux 电脑上建立一个系统目录，以管理在该过程中创建和处理的文件。

一个项目只能存储于一个目录之下。也就是说，当你想编写一个名为 TextCaser 的Linux 程序时，创建一个名为 TextCaser 的目录，并保持在该目录中只保存与 TextCaser 项目直接相关的文件。如果你有另一个名为 TabExploder 的项目，应该为其单独创建一个自己的目录。首先，这是一种非常好的管理实践，其次，它能有效防止将生成文件(makefile)搞乱。

我建议为汇编开发项目建立一个目录架构，我的经验建议这样做：在 Linux Home 目录下创建一个名为 “asmwork” 的目录，并创建一个以个人项目命名的目录作为整个汇编语言目录的子目录。

顺便说下，一个目录的名称可以与该项目的主.ASM 文件相同：也就是说，textcaser.asm 非常乐意在名为 textcaser 的目录下。



### 5.3.2 编辑源代码文件

汇编语言源代码文件以 .asm 为文件扩展名保存在磁盘上。



### 5.3.3 编译源代码文件

文本编辑器生成一个 .ASM 为扩展名的源文件，然后这个文件被传给汇编编译器本身，以将其解释为一个目标模块文件。在本书的环境——Linux 和 在 NASM汇编编译器下，文件的扩展名为 .O



当读取源代码文件中的代码行时，汇编编译器会对它们加以检查，建立一个符号表来总结源代码文件中的每一个已命名项，构建源代码行所代表的二进制机器指令，然后把这些机器指令和符号信息写入目标模块文件。当汇编编译器完成并关闭目标模块文件时，它的工作完成，他将终止运行。在现代 PC 上，对于一个不到 500 行代码的程序而言，这些事情的发生只需 1 秒或更少的时间。



### 5.3.4 汇编错误

如果汇编编译器从源代码中读取一行代码时，汇编编译器遇到一些不能理解的事情，这个不被理解的文本叫错误(error)，汇编编译器会显示一个错误信息(error message)。

例如：

当遇到 `mov eax,evx`时，NASM将显示如下错误信息:"testerr.asm:20 symbol 'evx' undefined"

当遇到 `mov ax,ebx`时，NASM将显示"testerr.asm:22: invalid combination of opcode and operands"。对于该错误，汇编器没有给出更详细的信息，你必须知道什么是合法的，什么是非法的，才能真正理解做错了什么。

汇编错误信息并不能把你从理解 CPU 或汇编编译器规则的责任免除。

从第一次坐下来编写自己的汇编代码开始，这些会变得越来越清晰，对于更加深奥的错误，汇编器提供的错误信息几乎毫无帮助价值。

如果已经显示了大量的出错信息，汇编程序将终止。从第一个错误开始，一定要了解它(做笔记)，然后继续下去。如果第一个错误之后的错误不符合逻辑，那么修复第一个或前两个错误，然后再重新编译。



### 5.3.5 回到编辑器

修复错误的方法是把有问题的源代码文件加载回文本编辑器，然后开始仔细寻找错误。

汇编错误信息几乎总是包含一个行号。将光标移动到那个行，开始寻找错误和那些不切实际的幻想。如果立即发现了错误，马上修复它，然后继续寻找下一个。



### 5.3.6 汇编警告

汇编时警告是汇编编译器作为有经验的顾问，向你暗示在源代码中有些东西有点冒险。这些东西并不严重得足以引起汇编编译器停止汇编文件，但是它的严重程度足以让你注意并展开调查。例如，如果你定义了一个命名标签，但是没有在后面放置任何指令，NASM 会显示一个警告，但这可能不是错误，而是你的疏漏，你应该密切关注该行并努力回想你在编写它时究竟在想什么。



如果你是普通的初学者，百分百做出本书列举的每一件事情，你应该“嚼烂”汇编参考手册，弄明白为什么汇编编译器会对你发出指责的滋滋声。无视警告可能会在后来的程序测试中导致奇怪的错误。或者。忽略警告消息可能根本没有任何不良后果。但是我认为，知道发生了什么事情总是更好些。请遵循这条规则：

**只有当确切知道汇编警告意味着什么时才可以忽略警告消息**

否则，必须将它像一个错误信息一样对待。只有完全理解它的根源及其含义之后，你才可以尝试做出决定：是忽略还是不忽略它。

总之，汇编语言开发过程的第一部分(如图 5-9)是一个循环。

如果没有进一步发现错误，汇编编译器将一个.O 文件写到磁盘中，可以准备进行下一个步骤了。



### 5.3.7 连接目标代码文件

连接步骤显示在图5-9的右半边。右上角是一排.O 文件，这些 .O文件是以前编译的正确的 .ASM 文件，它们包含机器指令和数据对象的目标模块文件。当连接器(linker)连接由正在处理中的 .ASM 文件所产生的 .O 文件时，它将这些以前编译的.O 文件加入其中。连接器写入磁盘的单个可执行文件包含来自所有当它被调用时传递给它的.O 文件的机器指令和数据项。

一个非常重要的好处，一些.O 模块中的过程可以被用于将来的，甚至还没有开始的汇编语言程序中。创建这样的“工具”程序库是通过重用代码节省时间的一个非常有效的方法，甚至不需要再把它传给汇编编译器。

Linux 拥有自己的连接器，叫ld。

本书比较简单的程序将使用 ld，但是到了第 12 章，我们将接纳 Linux 的特点，使用一个C编译器作为连接器。



### 5.3.8 连接错误

连接错误比汇编错误更微妙一些，它们通常很难找到。幸运的是，它们比较少见，而且不容易发生。正如汇编错误一样，连接错误是致命的，它们使可执行文件无法生成；当连接器遇到错误时，它将立即终止。当你遇到连接错误时，必须返回到编辑器，找出问题所在。一旦识别出问题(或者认为已经识别出)，对源代码文件进行一些修改以修复它，你必须重新编译该程序，然后重新连接以查看连接错误是否已经消失。直到连接错误不复存在。

如果可能，尽可能通过试验和错误来避免这种情况的发生。阅读汇编编译器和连接器文档。了解你正在做什么。对在汇编器和连接器中发生的事情越了解，就越容易确定哪些东西适合连接器。



### 5.3.9 测试 .EXE 文件

如果没有收到连接错误，连接器将创建一个单独的可执行文件，该文件包含出现在连接器命令中的所有文件中的机器指令和数据项。这个可执行文件就是你的程序。

在 Linux 下，一个调用程序的命令行可能是这样的：

./myprogram

这是快乐真正开始的时候。



### 5.3.10 错误 VS 漏洞

漏洞是指任何不按照你的意图去工作。这使得漏洞比错误(error)更加主观。

“漏洞对决特性”冲突应由你来负责。你对程序应该做什么以及怎么做应该有一个相当清楚的构想，并且应该将其备份为一套书面规范或者其他某种类型的文档，那就是判断 bug 的标准。

以下是一个常见的提示: "Segmentation Fault"，它被称为运行时错误(runtime error)。通常情况下，你的程序不会激怒操作系统。它只是不会做你期望它做的事情，而且很可能在失败的过程中没有说出太多内容。

幸运的是，Linux 是一个坚固的操作系统，它考虑到了充满漏洞的程序，“程序打败机器”这种情况及不可能像在DOS 时代那样常见。

为了阻止这种 Babel 效应，我认为最重要的事情是要认真地划清错误和 bug 之间的区别。错误是源代码文件中的某些错误的东西，被汇编编译器或者连接器认为不可接受而踢出来。错误阻止编译过程或者连接过程继续进行，进而阻止生成最后的 .EXE 文件。

bug 则是在程序执行中发现的问题。它既没有被汇编编译器察觉，也没有被连接器发现。bug 也可以是良性的，例如在屏幕信息中拼错的单词，或在显示器定错位的行; bug 也可以迫使程序提早终止。如果程序试图执行某些禁止的事情，Linux将终止它，并显示出错信息。这些错误被称为运行时错误，但它们实际上是漏洞造成的。

错误和 bug 都要求你返回文本编辑器编辑并修改源代码文件中的一些内容。所不同的是，大多数错误被报告出来，用一个行号指出你应该查看源代码的什么地方来修复该问题。相反地， bug 则被遗留下来供新手们联系。你必须寻找它们，无论是汇编编译器，还是连接器，都不会为你提供多少线索。



### 5.3.11 我们还在那里吗

图 5-9 表明，如果程序工作完美的话，汇编语言开发过程就可以宣告结束了。一个非常严肃的问题：你如何知道它何时工作完美？在学习语言过程中编译的一些简单程序可能很容易在一两分钟之内测试完毕；但是任何一个能够完成某些有用事情的程序都将花费至少数小时的测试时间。一个重要的大型应用可能花费数周或者数月才能进行彻底的测试。对于采用各种各样的输入值且产生各种各样的输出值的程序，要使用输出值的尽可能多的不同组合来进行测试，每次应该检查每一个可能的输出。

即便如此，在较大的程序中找到一个漏洞仍然被有些人认为是遥不可及的理想。也许——但是你应该以一种你可以做到的尽可能高效的方式，争取尽可能地接近这一理想。



### 5.3.12 调试器和调试

汇编语言开发过程中的最后一个，也绝对是最痛苦的组成部分是调试。调试(debugging)是简单的系统过程，我们通过这一过程来定位和纠正 bug。调试器(debugger)是一种实用工具，专门设计用于帮助你定位和识别 bug。

在所有种类的软件中，调试器是最神秘，最难以理解的。调试器与程序一起，加载到内存中，并与程序一起，一直在内存中。然后调试器转到程序中，完成一些真正独特的事情。

调试器能够让你一次执行程序中的一条机器指令，这样你就可以在每两条指令之间无期限等待，以检查上一条指令的指令执行效果。调试还允许你在两条指令之间的暂停期间，查看程序运行访问的内存块中的任何位置的内容以及存放在任何 CPU 寄存器中的值。

调试器能够做这些神秘的事情，因为它们是必不可少的，CPU 拥有一些内置到其硅芯片中的特殊属性，这些属性使调试器成为可能。它非常令人着迷，我建议你在熟悉了 x86 CPU 的内部结构之后，进行进一步的研究。

一些调试器能够同时显示机器指令和源代码，这样就可以看到哪些源代码文件对应哪些二进制代码。还有一些其他调试器能够根据名字而不是通过内存地址来定位一个变量。

DOS 和早期版本的 windows 所配备的调试器是 DEBUG

Linux 有一个非常强大的调试器，教 gdb



## 5.4 沿着汇编小路旅行

我们确实还在那里，同时，你必须理解汇编语言的开发过程，否则，即便知道指令如何工作也不会对你有丝毫的帮助。



#### 5.4.1 安装软件

Linux 下的非预装软件通过使用软件包管理器(package manager)得到。软件包管理器是个人电脑上的一个目录程序，用于维护 Linux 下所有可用的免费软件包列表。你可以选择你想要的一款软件，软件包管理器会上网，从它们的在线主页(名为知识库)中下载它们， 然后再为你安装它们。

在Ubuntu Linux 操作系统下安装了两款软件包管理器。

*  Application 菜单中看到的 Gnome Application Installer，它作为添加/删除菜单项而出现。这款软件包管理器由于其简单性而出现在那里，但是，它没有列出每一个你可能想要的免费软件包。
* 藏身于 System -> Administraton 菜单的是 Synaptic Package Manager，它可以(至少在理论上)访问任何一个已经被提交到公共知识库的免费软件产品。

在 Linux 下，不必担心软件被安装到何处。几乎所有的软件都安装在/usr 目录层次结构下。

我们需要很多开发工具：一个编辑器，一个汇编编译器，一个连接器和一个调试器

Linux 下安装Synaptic Package Manager包管理器

```shell
sudo apt update
sudo apt install synaptic
```



### 5.4.2 第 1 步: 在编辑器中编辑程序

```asm
; 可执行程序明 : EATSYSCALL
; 版本 : 1.0
; 创建日期 : 2021-1-9
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   演示了  Linux INT 80H  系统调用显示文本的用法
;
; 使用这些命令生成：
; nasm -f elf -g -F stabs eatsyscall.asm
; ld -o eatsyscall eatsyscall.o
;

SECTION .data                   ; 包含已初始化的数据的段


EatMsg: db "Eat at Joe's!",10
EatLen: equ $-EatMsg

SECTION .bss                    ; 包含未初始化的数据的段
SECTION .text		        ; 包含代码的段

global _start                   ; 连接器需要据此找到入口点！

_start:
	nop			    ; 这个无操作指令让 gdb 非常高兴
	mov eax,4		; 指定 sys_write 系统调用
	mov ebx,1 		; 指定文件描述符1：标准输出
	mov ecx, EatMsg	        ; 传递显示信息的偏移地址
	mov edx,EatLen 		; 传递显示信息的长度
	int 80H			; 进行系统调用来输出文本到标准输出
	mov eax,1 		; 指定 Exit 系统调用
	mov ebx,0		; 返回一个零代码
	int 80H			; 进行系统调用来终止代码
```



### 5.4.3 第2步 使用NASM 编译程序

编译命令：

```shell
$ nasm -f elf -g -F stabs eatsyscall.asm
```

`-f elf`有许多种有用的目标文件格式，而且每一种都以不同的方式生成。NASM 汇编器能够产生其中的大多数，包括其他格式，如 bin, aout, coff和ELF64，你可能不需要它们，至少暂时不需要。-f 命令告诉NASM ，它将对目标代码文件采用哪种格式。在 32 位 IA-32 Linux 工作环境下，命令格式为 ELF32，它可以在命令行中通过简单的elf来指定。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-09%20%E4%B8%8B%E5%8D%883.06.06.png" alt="截屏2021-06-09 下午3.06.06" style="zoom:50%;" />



-g 将调试信息嵌入目标代码文件，以便使用调试器来定位出现问题的地方。

-F stabs 与输出文件一样，NASM 也可以采用不同的格式生成调试信息，如果你工作于 IA-32 Linux 下，很可能为调试信息使用 stabs 格式，至少在你刚刚开始学习汇编时。还有一种更为强大的调试格式，叫 DWARF，也可以与elf 一起使用。

可以使用 -o 选项指定生成的目标文件文件名，例如：下述命令将生成syscall.o

```shell
$ nasm -f elf -g -F DWARF eatsyscall.asm -o syscall.o
```



### 5.4.4 第 3 步：使用 LD 连接器

```shell
$ ld -m elf_i386 -o eatsyscall eatsyscall.o
```

ld : 调用连接器

-m elf_i386 指定生成的软件架构，必须与eatsyscall.o的架构对应。

-o eatsyscall 指定即将产生的可执行文件的名称

eatsyscall.o  指定即将链接的目标代码文件的名称

当使用了其他代码库时，必须在输入命令行中输入正在使用的每一个库的名字。



### 5.4.5 第 4 步：测试可执行文件

一旦链接器无错通过，已经完成的可执行将在工作目录下等着你。如果汇编编译器和连接器消化了它，且没有显示任何错误信息，表明它没有错误。然而，没有错误并不代表没有缺席。为了确保其工作，只需在终端上命令行指出其文件名运行。

```shell
$ ./eatsyscall 
Eat at Joe's!
```



### 5.4.6 第 5 步：在调试器中观察程序运行

大多数时候，编写完程序需要立即开始查找漏洞。为此，最简单的方法是将可执行文件加载到调试器中，以便单步处理，在每条机器指令执行完毕之后，暂停一下，看看每条指令对寄存器和内存中定义的每一个变量有什么影响。gdb 和 KDbg两个程序一起，提供了一个愉快的(可以忍受的)调试经历。gdb 实用程序完成调试器所做的纵深层次的 CPU  魔术，而 KDbg 则在显示器上将其排列整齐，并允许你控制它。

要想启动一个调试会话，从终端窗口命令行中调用 KDbg，后面跟上可执行文件的名称：

kdbg eatsyscall



kdbg 官网：

https://www.kdbg.org/manual/howdoi.html



`INT 80H`指令是一个特殊的指令。它生成一个名为 sys_wait的 Linux 系统调用(我们亲切地称之为syscall)，它将数据发送到当前活动的终端窗口。

将 EatMsg 发送到输出窗口，这就是 eatsyscall 程序的设计初衷。它的任务完成后，程序中的最后三条指令主要做一些整理工作，然后结束。务必使 EAX 与 EBX 在最后的 INT 80H 前接收到新值，这些新值向 Linux 发出信号，告诉它该程序已经完成。

Step Into By Instruction 按钮指明 一步一步地通过一个过程。

Step Over By Instruction 按钮指明 不进入方法调用，停在方法调用之后的指令处。



在基于 IA-32 的保护模式下，像 EatMsg 这样的数据项既有段地址，也有偏移地址。然而，段地址是操作系统的财产，当做这种简单的用户空间编程时，我们可以放心地忽略它。回到 DOS 时代，我们则必须完成实用实模式分段内存模型，而且必须跟踪段寄存器；采用保护模式的方式完成它意味着少了一个令人头疼的问题(别担心，还有很多方法)



### 5.4.7 准备好要来真格的了吗

你已经具备了必要的基础。现在是时候拿出一些正式的工具，调查程序员对 Linux 操作系统的看法，并开始编写一些程序了。



# 第 6 章 有地儿，有工具 与工作息息相关的 Linux 操作系统和工具

DOS 被创建为更像某个强大的操作系统(即 Unix)的简化版本。Unix系统是 AT&T 研究实验室在 20 世纪 60 年代 和 70 年代开发的。当时，IBM 个人电脑已经出现，Unix 只允许在硕大的而安贵的大型机上。个人电脑没有原始的计算能力来运行 Unix。

DOS 下的Turbo Pascal 是第一个真正成功的，能够为程序员提供交互式开发环境(Interactive Development Environment，IDE)的商业产品。



## 6.2 Linux 和 终端

### 6.2.1 Linux 控制台

默认情况下，终端仿真程序使用 PC 键盘和显示器进行输入输出。它连接到一个与定义设备，可提供与 Linux 系统本省的通信。



终端程序只是一个程序，可以在 Linux 机器上安装各种不同类型的终端程序，每个终端程序可以在同一时间允许多个实例。但是，只有一个 Linux 控制台，我指的是名为 dev/console 的设备，它传送命令到 Linux 系统，并返回系统的响应。默认情况下，当启动的时候，终端仿真程序连接到 dev/console。如果愿意，可以使用 Linux 的终端仿真程序通过网络连接到其他设备



### 6.2.3 三个标准的 Unix 文件

人们将计算机描述为移动数据的机器，这是一种不错的看法。

理解 Unix 的一个根本设计原则：一切都是文件。

文件是数据所采用的路径的**端点**。当将数据写入一个端点时，你在沿着一条路径发送数据到一个端点。当从文件中读取数据时，你在从一个端点接收数据。数据在文件之间采用的路径可能完全位于一台计算机内部，或者位于某种类型的网络计算机之间。数据可以沿着路径处理或修改，或者它只是从一个端点移动到另一个端点，未做任何修改，无论怎样均可。

”一切都是文件“不只适用于磁盘上的数据集合。键盘是一个文件：它是一个生成数据并将其发送到某个地方的端点。显示器是一个文件：它是一个从某处接收数据并将其放在一个你可以看到的地方的端点。

下表为 Unix 定义的三个标准文件。当程序正在运行期间，这些文件对程序一直是打开的。

| 文件            | c 标识符 | 文件描述符 | 默认值 |
| --------------- | -------- | ---------- | ------ |
| Standard Input  | stdin    | 0          | 键盘   |
| Standard Output | stdout   | 1          | 显示器 |
| Standard Error  | stderr   | 2          | 显示器 |



在底层，操作系统通过文件描述符来知道一个文件。在某一程序内打开一个现有文件或者创建一个新文件时，Linux 会返回一个针对该文件的文件描述符。为了操作该文件，需要调用操作系统，向它传递你想处理的文件的描述符。

`mov ebx, 1			; 指定文件描述符1:标准输出`

 

### 6.2.4 I/O 重定向

`>` 和`<`是重定向操作符

`2>` 重定向标准输出到某些文件

`<` 它能够使原本来自键盘的标准输入重定向为来自另一个文件



如果将 `>` 换为 `>>`，就是将某些形式的输入追加到文件末尾



### 6.2.5 简易文本过滤器

NASM 汇编编译器本身就是一个过滤器：它读如满是汇编语言代码的源文件，对其进行处理，然后写出一个全是目标代码和符号信息的二进制文件。

程序可以通过将某些消息写到标准错误文件来发布文本状态和错误信息到终端显示仿真程序，所有这些都发生在它正在工作，标准输出文件正忙着将程序输出到磁盘期间。



### 6.2.6 使用转义序列进行终端控制

VT 终端观察其正在显示的数据流，并挑出具有单独释义的转义字符序列。例如：某个转义序列被解释为一个命令，用来实现清屏操作；另一个转义序列被解释为一个命令，用来在距离屏幕顶部 5 行，距离屏幕左边距 30 个字符的位置显示下一个字符。有几十个这种可识别的转义序列，它们让当时相对原始的文本终端能够向用户显示出格式整齐的文本，一次显示满满一屏。



Konsole 关键警惕一个通常情况下并不显示的特殊字符:ESC, 与之对应的 ASCII 码为 27，或 01Bh。当 Konsole 在其显示的文本流中看到一个 ESC ，它会非常仔细地查看后面几个字符。如果 ESC 字符后面的前三个字符是[2j，那么 Konsole 确认它为一个转义序列，该序列命令执行清屏操作，如果后面的字符是[11H，那么该序列命令将光标移动到显示器左上角的 home 位置。



毫不夸张地讲，有几十个不同的转义序列，它们都代表一些操作命令。如四处移动光标，改变字符的前景色和背景色，切换字体或字符编码，擦除线条或者部分线条或者整个屏幕的一部分，等等。通过向标准输出发出精心设计的转义字符序列，终端窗口中运行的程序能够完全控制整个显示器中的显示。

整个实现过程并不像听起来那么简单。在图形用户界面(GUI)应用时代到来之前，Unix 正是通过发送转义序列到终端(或终端仿真程序)来实现编程显示的。



### 6.2.7 为什么不用汇编语言编写 GUI 应用程序呢

使用汇编语言开发 GUI 应用程序是非常困难的，而且收效甚微。在能够使用汇编语言编写第一个 GUI 项目之前，你必须了解它的“所有”工作原理，并且为了迎接这一挑战，有很多的“所有”。

如果真心希望为某种 Linux 桌面管理器编写基于汇编语言的 GUI 应用程序，可以通过如下步骤接近这一目标：

1. 采用一种强大的本地编码高级语言(如Pascal，C或者C++)研究 Linux 编程。在这里，中级语言系统(如Python或者 Perl)基本不会对你有太多帮助。
2. 精通那种语言。研究它产生的代码，具体的做法是：将其加载到调试器，或者编译成汇编语言源代码并研究产生的汇编源代码文件。
3. 学习如何编写和连接汇编语言函数到你所选择的高级语言所编写的程序中。
4. 研究底层的窗口机制。对于 Linux 而言，这将是 X Window 技术，关于它已经有很多非常好的书籍。我最喜欢的一本书是The joy of X，作者是Niall Mansfield
5. 仔细研究一个特定的桌面环境和部件细节，如GNOME,KDE, xfce或者其他环境。(有很多中环境，而且其中一些被设计为轻量级，相对来说比较简单，如Xfce和windowLab)做到这一点的最佳办法就是用你所选择的高级语言为它编写应用程序，然后再研究汇编语言编译器产生的代码
6. 最后，通过模仿编译器生成的内容，尝试构建你自己的汇编代码。

## 6.3 使用 Linux Make

makefile的工作是：指定需要用程序的哪些部分来构建程序的其他部分。



### 6.3.1 依赖条件

生成文件(makefile)的内容制定了构建哪些文件需要哪些其他文件，以及需要采取哪些步骤来实现。Make 使用程序查看生成文件中的规则(依赖条件)并调用任何编译器，汇编编译器和它认为构建最终可执行文件或者库文件所需的其他实用程序。

```makefile
eatsyscall: eatsyscall.o
	ld -m elf_i386 -o eatsyscall eatsyscall.o


eatsyscall.o: eatsyscall.asm
	nasm -f elf -g -F DWARF eatsyscall.asm -o eatsyscall.o
```



### 6.3.2 文件何时最新

Make 可以判断目标文件是否为最新，如果为最新则没必要重新生成，节省了不必要的时间。

例如如下makefile

```makefile
eatsyscall: eatsyscall.o
```



Make 实用程序知道，可执行文件eatsyscall 依赖于目标代码文件eatsyscall.o，如果没有eatsyscall.o将无法生成eatsyscall，它还知道两个文件的最后更改时间，因此，如果可执行文件eatsyscall比eatsyscall.o，它便推断出对于eatsyscall.o所做的任何更改都已反映在eatsyscall中。（可以完全肯定，因为产生eatsyscall的唯一方式是通过处理eatsyscall.o）



### 6.3.3 依赖链

当一个单独的生成文件包含依赖链之后，Make 机制的真正价值才开始显现。即使在最简单的生成生成文件中，也会有某些依赖条件又依赖其他条件的情况。例如：

为了得到eatsyscall，首先需要的到eatsyscall.o，而为了得到，还需得到eatsyscall.asm

用一个makefile文件，可以自动编译得到所有需要的依赖条件，最终得到eatsyscall

```makefile
eatsyscall: eatsyscall.o
	ld -m elf_i386 -o eatsyscall eatsyscall.o

eatsyscall.o: eatsyscall.asm
	nasm -f elf -g -F DWARF eatsyscall.asm -o eatsyscall.o
```



## 6.4 Insight 调试器

Insight 与 KDbg，DDD 以及其他 Gdb 前端产品不同。Insight 实际上是 Gdb 的一部分，并且提供 Gdb 操作的另外一种(用于图形化桌面如 GNOME, KDE, xfce 以及所有的其余的桌面系统上使用的)窗口视图。



# 第 7 章 跟踪指令 与机器指令亲密接触

它不是 PC 汇编语言的完整课程。一旦“跑到”了本书的最后，你就可以抬脚奔向各个出版社的众多其他汇编语言书籍了。



## 7.1 为自己建立一个沙盒

认识 x86 机器指令的最佳方法是建立一个自己的沙盒，并且玩得开心。沙盒中的汇编语言程序并不需要在 Linux 中正确地运行。它甚至不需要像一般程序员那样完整。所有它必须具有的特点就是能够被 NASM 和连接器理解。

按照我个人的技术术语来讲，沙盒就是一个打算在调试器中运行的程序。

我的沙盒思想是这样的：为一个名为 sandbox.asm创建一个用于编译和连接的生成文件(Makefile)。你可以创建一个代码量很小的 NASM 程序，并将其以文件名 newsandbox.asm 保存到磁盘上。什么时候想“摆弄”机器指令，你都可以打开 newsandbox.asm ，将其再次保存为sandbox.asm，覆盖所有可能存在的sandbox.asm 早期版本。你可以添加指令用于观察，并使用 Linux 的 Make 使用工具生成一个可执行文件。然后，调试该程序。



你的实验程序有可能产生一些具有保存价值的有用的机器指令组合。在这种情况下，你将沙盒文件另存为 experiment1.asm(或者任何你想赋予它的描述性名称)。一旦时机成熟，随时都可以从那个序列生成一个“真正的”程序。



### 7.1.1 一个最小的NASM 程序

```asm
section .data
section .text

    global _start


_start
    nop

    nop

section .bss
```


我们真正需要的是一个标记为全局(global)的起始点，这里为 _start 标号。我们还需要定义一个.data段和一个 .text 段。.data段用于保存已命名数据项，当程序运行时，它们将被赋予初始值。清单 5-1 中的"Eat at Joe's"信息就是数据段中的一个已命名数据项。.text 段用用于存放程序代码。要想创建一个可执行文件，这两个段都是必不可少的。



第二个标记 .bss 的段并不是必须的 ，但是，如果打算进行实验，拥有它会带来一些好处。.bss 段保存未初始化的数据，也就是说，该空间用于存放当程序运行时并没有接收任何初始值的数据项。从根本上讲，这些都是空的缓冲区，用于存放程序运行期间即将产生的数据，或者从某处读取数据。按照惯例，.bss 段位于 .text 段的后面

```makefile
andbox: sandbox.o
	ld -m elf_i386 -o sandbox sandbox.o

sandbox.o : sandbox.asm
	nasm -f elf -g -F DWARF sandbox.asm -l sandbox.1st
```

-l 的意思是：生成一个sandbox.1st 和一个 sandbox.o，这样这个版本就被保存下来了



使用gdb 调试，可以看到程序将不正常退出。

Linux 将提交一个分段错误，其中的原因可能有若干种。但是，本例中发生这种情况的原因是程序视图执行一个已经超过 .text 段结尾位置的代码。当程序被加载时，Linux 知道该程序有多长，它不允许执行任何在程序中不存在的指令。

当然，这并没有什么持久性的伤害，Linux 非常善于处理错误的行为和畸形的程序，没有什么意外事件会对 Linux 有所影响。



### 7.1.2 指令及其操作数

在汇编语言工作中，最常见的活动就是将数据从这里移到那里。有一种专门做这件事的方法，但真正通用的只有一个: MOV 指令。MOV 运行的操作：

* 可以从一个寄存器到另一个寄存器
* 从一个寄存器到一个内存地址或从一个内存地址到一个寄存器移动一个字节(8位)，一个字(16位)或者一个双字(32位)的数据。

不能做的事情是直接从一个内存地址移动另一个内存地址中。



### 7.1.3 源操作数和目标操作数

大多数机器指令(包括 MOV)有一个或多个操作数(有些指令没有操作数，或隐式地操作寄存器或存储器)。

如下机器指令：mov eax,1

上述机器指令有两个操作数:第一个是 EAX，第二个是数字1。

在汇编语言中，一条机器指令的第一个(最左边)操作数是目标操作数。从左边数第二个操作数是源操作数。

只要某些机器指令产生一个新值，这个新值就被放在目标操作数中。

有三种不同类型的数据可以作为操作数：

* 内存中的数据
* 寄存器中的数据
* 立即数



### 7.1.4 立即数

例如以下指令：`MOV EAX,42H`，42H是一个立即数，它通过名为立即数寻址的寻址模式来访问立即数。**立即数寻址的名字来源于这样的事实：被寻址的项刚好是内置在机器指令中的数据。**它不是存放在寄存器中，也不是存放在位于指令之外的某个内存中。立即数总是位于正被取出和执行的指令的内部。

从内存中获取任何数据的时间均超过从寄存器中获取任何数据的时间，毕竟，指令都存储在内存中。因此，对立即数的寻址的速度总是比对存储在内存中的普通数据寻址的速度快，但是，从这两个地方取出数据的速度，都不如从 CPU 寄存器中简单地取出一个数值的速度快。

**只有源操作数可以是立即数**



NASM 还允许一些有趣的立即数，例如: mov eax, ‘WXYZ’

在调试器中可以看到，EAX 的值是: 0x5a595857

根据 ASCII 恰好为: ZYXW

因为IA-32 架构的CPU是小端序，因此刚好和‘WXYZ’的对应值相反。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-11%20%E4%B8%8B%E5%8D%883.11.15.png" alt="截屏2021-06-11 下午3.11.15" style="zoom:67%;" />





### 7.1.5 寄存器数据

我们将存储在 CPU 内部的数据称为寄存器数据，将直接访问寄存器数据的内存寻址模式称为寄存器寻址。

```asm
mov ebp,esi       ; 32 位
mov bl,ch         ; 8位
add di,ax         ; 16位  将di和ax中的内容相加，并将结存存入 目的寄存器di中
add ecx,edx       ; 32位
```



**无论是什么指令，只要直接作用于寄存器中的数据，就会发生寄存器寻址。**

有一种特殊情况就是，在同一条指令中出现一个 16 位的半寄存器和一个完整的 32 位寄存器。这种操作是不合法的。将 2 个字节源操作数移动到一个 4 字节的目标操作数种似乎是可能的，甚至是合理的，但是 CPU 并不支持这种操作。



`xchg cl,ch` 用于交换两个寄存器的值

有时候，在机器执行时间方面，某种“特殊情况”要比一般情况更快一些。例如被 2 的幂数相处，我们可以使用 DIV 指令实现，但也可以通过 SHR(右移位)指令实现。DIV 是更为一般的办法（你可以用它来实现任何无符号整数除法，不仅仅是 2 的幂数）,但是它的速度非常缓慢，在某些种类的 x86 处理器上，甚至比 SHR 指令的速度慢高达 10 倍!



### 7.1.6 内存数据

内存数据是存储在分配给某个程序的系统内存中的某个 32 位内存地址处的数据。除了一两个例外(如字符串指令，本章后文会涉及，但并不进行详细讲解)之外，一条指令的两个操作数只有一个可以指定内存位置。

如果想要指定的数据是位于寄存器中的内存地址中的值，而不是寄存器本身中的数据，需要在寄存器名字的两边加上方括号。

例如，如果想将存放在寄存器 EBX 中的内存地址处的双字移到寄存器 EAX 中，应该使用以下指令：

`mov eax,[ebx]`



还可以在寄存器的括号内添加字面常量，NASM 会进行数学计算：

`mov eax,[ebx+16]`

也可以添加两个通用寄存器，就像这样：

`mov eax,[ebx+ecx]`

而且，如果还不够，可以添加两个寄存器，外加一个字面常量：

`mov eax,[ebx,ecx+11]`

当然，这还没包含全部的合法形式。括号中的所有内容称为内存数据项的有效地址(effective address)，并且有一些规则来规定哪些是合法的有效地址，哪些不是。在目前的 x86 硬件演变中，可以将两个寄存器加在一起，形成有效地址，但没有三个寄存器或更多的情况。换句话说，下面的指令是非法的：

`mov eax ,[ebx,ecx,edx]`  



### 7.1.7 混淆数据和它的地址

例如下面的指令

```asm
EatMsg db "Eat at Joy's"
mov ecx, EatMsg
```

该指令并不是把 EatMsg的值存入 ECX 中，而是将 EatMsg的地址存入 ECX 中。在汇编语言中，变量名代表的是地址，不是数据。

那么，实际上该如何到达一个由(想 EatMsg 一样的)变量表示的数据呢? 同样，这也可以通过使用方括号来实现：

`mov ecx,[EatMsg]`

这条指令所做的事情就是从 EatMsg 代表的内存地址中取出前 32 位数据，并从最低有效字节开始，将其加载到EDX 中。根据我们为 EatMsg 定义的内容，那将是 'E' 'A' 't' '  '四个字符。用 ASCII码表示。



### 7.1.8 内存数据的尺寸

如果只想要其中一个单独字符，而不是前 4 个字符，该怎么办？从根本上来讲，如果想使用一个字节的数据，需要将其加载到一个字节大小的容器中。例如：

```asm
 msg db "hello world"
 mov al,[msg]
 mov bl,[msg+1]
```

al保存 h的 ASCII ，bl保存 e的 ASCII。

将寄存器中的数据写到内容时，尺寸问题将变得棘手。NASM 并不像高级语言那样“记得”变量的大小。它只知道 msg 从内存中什么地方开始，就这么简单。你必须告诉 NASM 需要移动多少个字节的数据。这是通过大小说明符(size specifier)来实现的。例如:

mov [msg],byte 'G '

这里通过大小说明符byte告诉 NASM，你只想移出一个字节到内存中。其他的大小说明符包括WORD(16位)，DWORD(32位)。



### 7.1.9 糟糕的过去

很高兴你是在现在学习 x86 汇编，因为在前些年学习它要复杂得多。在 DOS 实模式下，对于一个有效地址的组成部分有几个限制，而这些限制在当今的 32 位保护模式下已经不复存在了。在实模式下，只有某些 x86 通用寄存器能够存放内存地址：BX, BP,SI 和 DI。而其他的寄存器AX，CX和DX则不能。



更糟糕的是，正如第四章描述的那样，必须确保通过使用类似[DS:BX]结构指定段地址。而且必须处理名为ASSUME 的恶魔般的事情，对此还是少说为妙。



在许多方面，我们的生活都变得越来越美好了。



## 7.2 CPU 的标志位

一个标志是一个单独的二进制信息位，它的含义独立于任何其他位。根据 CPU 的需要，一个二进制位可以被 CPU 设置为 1 或者清除为 0.这样做是为了告诉你(程序员)CPU 内部的某些条件的状态，以便程序员可以对其进行测试并根据那些条件的状态采取相应的行动。更少见的情况是，你(程序员)也可以设置一个标记，并将其作为一种向 CPU 发送某些信号的方式。

作为整体来看，EFlags 只是一个掩藏在 CPU 内部的 32 位寄存器。它是出现在 8086/8088 CPU 中的16位标志寄存器的 32 位扩展后代。其 32 位中的每一位都是一个标志。尽管这些标志很常见。此外，还有许多标记没有被因特尔定义，而且尚未使用或暂未使用。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-11%20%E4%B8%8B%E5%8D%885.32.55.png" alt="截屏2021-06-11 下午5.32.55"  /> 



EFlags 寄存器中的每一个标志都有一个由两个或三个字母组成的符号，大多数程序员通过这些符号来了解它们。

* OF：溢出标志，当对一个有符号整数量的算术运算操作结果过于庞大，以至于不能适合原来的操作数时，溢出标志 OF 被设置。当"进位标志"被标记时，溢出标志通常也被设置。
* DF：方向标志，它告诉 CPU 某些你想让它知道的东西，而不是反过来(CPU 想让你知道)的其他方式。它决定了字符串指令执行过程中的行为移动方向(上内存或者下内存)。当 DF 被设置时，字符串指令从高内存向低内存进行。当 DF 被清除时，字符串指令从低内存向高内存进行。
* IF；中断使能标志是一个双向标志。CPU 在某些条件下设置它，你也可以使用STI 和 CLI 指令来自己设置它。当 IF 被设置时，中断被启用，并且当需要时可以发生。当 IF 被清除时，中断将被 CPU 忽略。早在 DOS 时代，普通程序就可以在实模式下自由地设置和清除这个标志。但在 Linux 下，IF 是供操作系统使用的，有时是为它的驱动程序所用。如果你尝试在自己的程序中使用 STI 和 CLI 指令之一，Linux 将会提交一个一般保护错误，并终止程序。一定要考虑 IF 的"军事禁区"。
* TF：当被设置时，单步标志允许调试器通过强制 CPU 在调用一个中断程序前只执行一条指令来实现单步管理。对于一般编程而言，这不是一个特别有用的标志，我也不会对其做更多的讲解。
* SF：当一个操作的结果强迫操作数变为负数时，符号标记被设置，“负”只是意味着在一次有符号运算中，操作数中排序最高的位(符号位)变成了1。任何结果为正的算术运算操作都会将 SF 清零。
* ZF：当一个操作的结果为零时，零标志被设置。反之，如果目标操作数变成某些非零值，则 ZF 被清零。该标志经常用于条件转移指令中。
* AF：辅助进位标志只用于 BCD 码算术运算。BCD 码算术将每个操作数的一个字节看作一对4位“半字节”，并通过使用 BCD 算术指令，允许一些近似十进制(基数为 10)的算术运算直接在 CPU 的硬件上完成。这些指令已经不再使用。
* PF：对于任何了解串行数据通信的人而言，奇偶标志看起来应该很熟悉，但是对于那些不熟悉的人们而言，则完全是件完全奇怪的事情。PF 表明某个结果数字的排序最低的字节中被设置为 1 的二进制位的个数是奇数还是偶数。例如，如果结果为 0F2H，那么 PF 将被清除，因为0F2H(11110010)中包含奇数个设置为 1 的二进制位。同样，如果结果是3AH(00111100)，那么PF 将被设置为1。该标志位是计算机串口通信遗留下来的。
* CF：进位标志用于无符号算术运算。如果一个算术或移位操作的结果从操作数“进”1位，CF被设置。否则，如果没有进位，CF 将被清除。



### 7.2.1 标志防范

请查看每一条指令的指令参考部分，看看它是否影响了标志。



### 7.2.2 使用 INC 指令和 DEC 指令加 1 和 减 1

有些 x86 机器指令是成对出现的。这些指令之中最简单的就是 INC 和 DEC，它们将一个操作数分别加1和减1。

如下述指令：

```asm
mov eax,0FFFFFFFFH
mov ebx,02DH
dec ebx
inc eax
```

调试上述指令，EBX 变为0CH，EAX 变为 0，因为EAX 的值加一产生了溢出，但此时**进位标志不受INC指令影响**



### 7.2.3 在调试程序中观察标志

dec 指令影响的标志位为: OF，SF，ZF，AF 和 PF 标志。DEC EBX 指令将所有这些标志清零，原因如下：

* 溢出标志(OF)被清除，因为被解释为有符号整数的操作数并没有变得太大，以至于无法存放在 EBX 中。
* 符号标志(SF)被清除，因为操作的结果没有使得 EBX 的最高位变成1。假如 EBX 的最高位变成1，那么，被解释为有符号整数的 EBX 
* 的值将成为负数，当一个变为负数时，SF 被设置。所以，像 OF 一样，SF也没有多大用处，除非正在做有符号算术运算。
* 零标志(ZF)被清零，因为目标操作数不等于零。如果为零，ZF 将被设置为 1。
* 辅助进位标志(AF)被清零，因为没有从 EBX的低四位向高四位的 BCD 码进位。
* 奇偶标志(PF)被清零，当目标操作数的二进制位 1 的数量是奇数时，PF 被清零。
* DEC指令不影响 IF 标志，它仍然被设置为 1.



现在执行 INC EAX 指令，并重新在调试器中查看。

* 奇偶标志(PF)被设置，因为 EAX 的值为 1 的二进制位的个数是零，当操作数的值为 1 的二进制位的个数是偶数时，PF 被设置为 1。0被认为是偶数。

* 辅助进位标志 AF 被设置低4位从 FFFF 变成了 0000。这意味着从低 4 位到高 4 位 有进位，当操作数的低 4 位有进位时，AF 被设置。
* 零标志(ZF) 被设置，因为 EAX 变成了零。
* 像前面一样，IF 标志没有变化，仍然一直处于设置状态。



### 7.2.4 标志如何改变程序的运行

```
section .data
    myname db "WANG"
section .text
    global _start

_start
    nop
    
        mov ebx,myname
        mov eax,4
    DoMore: add byte [ebx],32
        inc ebx
        dec eax
        jnz DoMore
    
    nop
section .bss
```



该程序将数据段中的变量myname中的每个字符，由大写变为小写。采用的方法是，将其 ASCII 码加上 32。

该程序将循环 4 次，每次改变一个字符。



## 7.3 有符号值和无符号值

在汇编语言中，既可以使用有符号数，也可以使用无符号的数。当然，有符号数可以为负数的值，而无符号的值则始终为正。 在 X86 指令集中，有一些用于四种基本算术运算的指令，这些指令既可以操作有符号值，也可以操作无符号值。（对于乘法和除法，有单独的指令分别用于有符号和无符号计算）。

理解有符号数和无符号数之间的关键是知道 CPU 将符号放在什么地方。它不是一个破折号符号，而是实际上代表这个数字的二进制模式下的一个位。一个有符号数的最高有效字节的最高位是符号位。如果符号位的值为 1，则这个数为负数。如果符号位的值为0，则这个数为正数。

记住，一个给定的二进制模式到底代表一个有符号数还是无符号数，取决于你如何使用它。



### 7.3.1 补码 和 NEG

CPU 在逻辑层面上，并不真正需要减法。它只是产生减数的补码，并将其与被减数相加。

使用机器指令 NEG 可以求一个数的补码，并取负。**当对一个数执行NEG时会假定该数作为负数处理，因为会将该数的符号为置为1**

一个有符号数，最高位为符号为，1代表负数，0代表正数

有符号数的范围为

![截屏2021-06-14 下午4.43.52](https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/number.png)



将 8 位最大正数值(7FH)加1，将得到一个最大的负值(80H)

在 GDB 中可以以 十六进制，十进制和无符号数之间进行选择。这三种格式采用如下方式工作：

* 十六进制以十六进制显示该值。
* 十进制形式将该值表示为一个有符号数，最高位当成符号位来处理。
* 无符号形式将该值表示为一个无符号值，把最高位只是看成整个数中的一个二进制位。



### 7.3.2 符号扩展和 MOVSX

GDB 不能显示低于 32 位的有符号值，低于 32 位，符号为会被看成是数值位。

默认情况下，如果我们执行`mov ax,-42`，ax会被显示为 65494，使用普通的 mov 指令执行 `mov ebx,eax`

那么ebx也只是显示65494，它并不会显示为一个负数。

为了克服这个缺陷，我们应该使用 MOVSX 指令，MOVSX 的意思是“带符号扩展一起移动”

```asm
mov ax,-42
movsx ebx,ax 
```

执行完上述指令，ebx，将会以 10 进制显示 -42



MOVSX 指令

| 机器指令 | 目标操作数 | 源操作数 | 操作说明                     |
| -------- | ---------- | -------- | ---------------------------- |
| MOVSX    | r16        | r/m8     | 8 位有符号数到 16 位有符号数 |
| MOVSX    | r32        | r/m8     | 8 位有符号数到 32 位有符号数 |
| MOVSX    | r32        | r/m16    | 16位有符号数到 32 位有符号数 |

**目标操作数只能有一个寄存器**，r/m 的意思是任意的寄存器或者内存位置，后面跟它们的位数

例如：r/m16 指任意的 16 位寄存器或内存位置。



## 7.4 隐式操作数

有些指令实际上也有操作数，但是这些操作数代表的是由指令做出的假设。这种操作数被称为隐式操作数，它们永远不变，也不能被更改。使情况变得更复杂的是，大部分包含隐式操作数的指令同时也包含显示操作数。

在 x86 指令集中，最好的隐式操作的例子是乘法和除法指令。排除专门的数学处理器(x86，MMX 和 SSE)中的指令，x86 指令集有两套乘法和除法指令。**一组是 MUL 和 DIV，用于处理无符号计算。** **另一组是IMUL和IDIV，用于处理有符号计算。**

MUL 指令完成我们期望它做的事情：它将两个值相乘，然后返回一个结果。然而，在基本的数学运算中，乘法有一个特殊的问题：它产生的输出值经常比输入值大很多。这使得我们无法按照 x86 指令模式操作，即把指令产生的结果存入目标操作数中。

考虑一个 32 位乘法操作。32 位寄存器中能够存放的最大无符号值是 294967295。它们即使是与 2 相乘也会得到一个 33 位的结果，而该结果不再适合任何 32 位寄存器。当 x86 是 16 位体系结构使，就存在着将两个 16 位值的，非常容易溢出 16 位寄存器的计算结果存放到何处的问题。

为了解决这个问题，Intel 的设计师们采用它们唯一能够做到的方法：使用两个寄存器来保存结果。

两个二进制数的最大乘机的位数不超过较大因子的位数的两倍。简单地说，任意两个 16 位值的乘积都适合存储在 32 位容器中，而任意两个 32 位值的乘积都适合存储在 64 位容器中。



观察下述指令`mul ebx`

该指令将计算机 EBX * EAX，并将结果保存在 EDX 和 EAX 中，EBX 作为显式操作数，EAX 作为隐式操作数，EDX 和 EAX作为隐式操作数(结果)。这带来 3 种变体。

| 机器指令 | 显式操作数(因子1) | 隐式操作数(因子2) | 隐式操作数(结果) |
| -------- | ----------------- | ----------------- | ---------------- |
| mul      | r/m8              | AL                | AX               |
| mul      | r/m16             | AX                | DX and AX        |
| mul      | r/m32             | EAX               | EDX and EAX      |

第一个因子以一个明确的操作数给出，它可以是一个寄存器中的值，也可以是某个内存位置中的值。第二个因子是隐式的，并且总是在适合于第一个因子位数的 "A" 系列通用寄存器中。如果第一个因子是一个 8 位值，第二个因子总是在 8 位寄存器 AL 中。如果第一个因子是一个 16 位值，第二个因子总是在 16 位寄存器 AX 中，依次类推。

一旦结果需要不止 16 位，“D”系列寄存器就被“征用”，以存放计算结果的高序位部分。这里的“高序位”指的是不适合在 “A” 系列寄存器中存放的那部分计算结果。**例如将两个 16 位值相乘，得到的结果是02A456FH，那么，寄存器 AX 中会包含 0456FH，而 DX 寄存器中则存放 02AH。**

即使计算结果足够小，以至于存放结果的两个寄存器之一就能够存放它，高位寄存器(不论是AH，DX，或EDX)仍然被清零。

MUL 指令的操作数不能为立即数；也就是说，你不能做以下事情，将第一个因子声明为立即数：

`mul 42`



### 7.4.1 MUL 和进位标志

MUL 产生的结果如果很大，将由两个寄存器来保存结果，用 EDX 保存高位部分，用 EAX 保存低位部分。可以通过进位标志 CF，看是否有高位部分。



### 7.4.2 使用 DIV 实现无符号除法

被除数是隐式操作数，存放在 EDX(高位部分) 和 EAX(低位部分) 中，除数存放在 DIV 的唯一显式操作数中，它可能在寄存器中 或者内存中(同乘法指令一样，不能使用立即数作为操作数)。返回的商数存放在 EAX 中，余数存放在 EDX 中。

如同乘法指令一样，DIV 的隐式操作数取决于显示操作数的尺寸。

| 机器指令 | 显式操作数(除数) | 隐式操作数(商的整数部分) | 隐式操作数(商的余数部分) |
| -------- | ---------------- | ------------------------ | ------------------------ |
| DIV      | r/m8             | AL                       | AH                       |
| DIV      | r/m16            | AX                       | DX                       |
| DIV      | r/m32            | EAX                      | EDX                      |

无论是除数还是被除数，都不能为零。



### 7.4.3 x86 中的“慢动作” 指令

DIV 和 MUL 指令接近整个 x86 指令集中最慢的的指令。两条指令的 32 位版本均慢于 16 位版，8位版本是所有版本中最快的。

在最新的奔腾级 CPU 指令中，其他因素开始发挥作用，这使得泛泛地谈论指令速度几乎成为不可能的事情，当然更不可能对其进行精确地说明了。

在那些不断执行大量计算的循环中，比如图形绘制和视频处理(如果正在做此类事情，你也许应该使用 x86 体系结构的数学处理器部分，而不是 MUL 指令和 DIV 指令)，指令速度至关重要。我的个人启发是使用输入值运行的最小版本的 MUL 和 DIV 指令，而且大多数时候被更大的启发所冲淡，指令速度并不重要。当汇编语言经验足够丰富，以至于能够进行指令级性能决策时，你将知道这一点。在此之前，你应该集中精力在程序错误上，而将速度问题仍给 CPU。



## 7.5 阅读和使用汇编语言参考资料

在手头预留一些其他类型的参考文档，以唤醒他们对于机器指令细节的记忆。



### 7.5.1 对于复杂记忆的唤醒文件

Intel 的处理器文档：https://software.intel.com/content/www/cn/zh/develop/articles/intel-sdm.html

Borland 的 Turbo Assembler 快速参考指南，关于汇编指令的材料并不适用于 NASM，但是它的指令参考包括能够在 486 上通过的所有 32 位形式的指令，而这是一个汇编初学者可能使用的几乎所有内容。



### 7.5.2 初学者汇编语言参考指南

现代 x86 中的很多复杂指令和内存寻址机制只为操作系统和驱动程序使用。对于短小的运行在用户模式下的应用，它们根本不适用。

初学者经常参考的，最常见的 x86 指令在附录 A 中。对于在本书中的每一条指令，附录 A 中都至少包含一页的内容，加上一些其他的，每个人都应该知道的指令。它并不包括每一条指令的描述，而是只对那些最常见和最有用的进行描述。一旦你已经足够熟练，可以使用那些更为神秘的指令时，你应该能够阅读英特尔的 x86 文档，并且将其运用在汇编工作中。



### 7.5.3 标志

在附录 A 中，所有受指令影响的标志的符号下方都将有一个星号(*)出现。标志是如何受到影响的，取决于指令所做的事情。



### 7.6 NEG：求补(求补码；即，与-1相乘)

一个值的补码与该值相加，产生的结果为零。

如果操作数为 0 ，则 CF 被清零，ZF 被设置，否则，CF 被设置，ZF 被清零。

如果操作数包含最大值(8 位最大值 -128; 16 位最大负值为 -32768)，则操作数不变，但是OF，CF 被设置。如果结果为 负，则 SF 被设置，否则 SF 被清除。如果结果的低 8 位包含偶数个 1 的位，PF 被设置，否则 PF 被清零。



### 7.6.1 合法形式

实际上不同的形式代表不同的二进制操作码。例如，在最底层，POP AX 指令的二进制数 058H，而 POP SI 指令是二进制数 05EH。多数操作码不是单个的 8 位值，大多数至少有两个字节长，而且往往是4个或更多个字节。

当你想使用具有一组特定操作数的指令时，务必检查该指令饿参考指南中的“合法形式”小节，以确保该组是合法的。与以前的糟糕的 DOS 时代比，现在有更多的合法形式，很多保留下来的限制都涉及段寄存器，当编写一般的 32 位保护模式用户应用程序时，你将无法使用它。例如，MOV 指令不能将数据从某个内存位置移动到另一个内存位置，并且在实模式下存在一些如何在段寄存器中存放数据的限制。



### 7.6.2 操作数符号

r8：一个 8 位的半寄存器，AH，AL，BH，BL，CH，CL，DH或者DL

r16：一个 16 位通用寄存器，AX，BX，CX，DX，BP，SP，SI或者DI

r32：一个 32 位通用寄存器，EAX，EBX，ECX，EDX，EBP，ESP，ESI或者EDI

sr：一个段寄存器，CS，DS，SS，ES，FS或者GS

m8：一个 8 位的字节内存数据

m16：一个 16 位的内存数据

m32：一个 32 位的内存数据

i8：一个 8 位的字节内存立即数

i16：一个 16 位的字立即数

i32：一个 32 位的双字立即数

d8：一个 8 位的有符号位移

d16：一个 16 位的有符号位移，用于 jump指令和call指令

d32：一个 32位的有符号位移



### 7.6.3 示例

我试图为每一条指令提供一个良好的范例取样，尽量体现该条指令不同可能性的范畴。



### 7.6.4 注解

附录 A 中，“注释”小节简单描述了指令的活动，并提供了一些信息，包括它如何影响标志，如何可能被限制使用，以及所有需要记住的其他细节，特别是那些初学者容易忽视或误解的内容。



### 7.6.5 这里没有包含的内容

附录A 中不同于大多数详尽的汇编语言参考资料，它不包括操作码的二进制编码信息，也没有表明该指令的每种形式使用多少机器周期的相关内容。

一条指令的二进制编码是 CPU 消化和识别的机器指令的实际二进制字节序列。我们称之为 POP AX 的指令被机器视为二进制数 58H。我们称之为 ADD SI,07733H的机器指令视为 4 个字节的序列: 81H 0C6H 33H 77H。机器指令可以被编码到任意地方，根据它们是什么指令以及操作数是什么，从一个到四个(有时更多)二进制字节不等。

像 Michael Abrash 在他的巨著 《Michael Abrash 的图形编程黑皮书》中这样说，要想知道一个给定系列的指令将花费多长时间来执行，仅仅知道单个指令的执行周期还远远不够，即使是专家级别的汇编语言编程员。 CPU 缓存，预取指，分支预测，超线程和任意数量的其他因素结合在一起，相互作用，使得进行这样的计算几乎是不可能的，除非从广义上来讲。



# 第 8 章 我们的崇高目标 创建能够工作的程序

## 8.1 汇编语言程序的基本框架

```asm
; 可执行程序明 : EATSYSCALL
; 版本 : 1.0
; 创建日期 : 2021-1-9
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   演示了  Linux INT 80H  系统调用显示文本的用法
;
; 使用这些命令生成：
; nasm -f elf -g -F DWARF eatsyscall.asm -o syscall.o
; ld -m elf_i386 -o eatsyscall eatsyscall.o
;

SECTION .data                   ; 包含已初始化的数据的段


EatMsg: db "Eat at Joe's!",10
EatLen: equ $-EatMsg

SECTION .bss                    ; 包含未初始化的数据的段
SECTION .text		        ; 包含代码的段

global _start                   ; 连接器需要据此找到入口点！

_start:
	nop			    ; 这个无操作指令让 gdb 非常高兴
	mov eax,4		; 指定 sys_write 系统调用
	mov ebx,1 		; 指定文件描述符1：标准输出
	mov ecx, EatMsg	        ; 传递显示信息的偏移地址
	mov edx,EatLen 		; 传递显示信息的长度
	int 80H			; 进行系统调用来输出文本到标准输出
	
	mov eax,1 		; 指定 Exit 系统调用
	mov ebx,0		; 返回一个零代码
	int 80H			; 进行系统调用来终止代码
```



### 8.1.1 最开始的注释块

汇编语言编码的目的之一，是使用仅可能少的指令来完成某项工作。这并不意味着创建尽可能短的源代码文件。源文件的大小与编译后得到的可执行文件的大小毫无关系！放入文件的注释越多，当下次再捡起它的时候，你就越能更快地想起它的内部工作原理。我想你会发现，一个复杂的汇编语言程序的逻辑在你的脑海里的冷却速度快的惊人。



注释既不浪费时间，也不浪费空间。IBM 曾建议"每行代码一个注释"。这很好，并应被视为汇编语言工作最其码的组成内容。一个更好的(我在后面较为复杂的例子中所遵循的)习惯是在每一行代码的右侧使用一行短行注释，同时在共同完成某一单独任务的每个指令序列的开始位置添加注释块。

每一个程序的顶部应该是一个标准的注释块，其中包含一些重要的信息：

* 源代码文件的名称
* 可执行文件的名称
* 创建该文件的日期
* 最后一次修改该文件的日期
* 程序编写者的名字
* 用于创建它的汇编编译器的名称和版本
* 程序或者库文件所做事情的概要说明。需要多少空间你就用多少。它并不会影响可执行程序的大小和速度。
* 如果使用生成文件(你应该那么做)的话，还应该有一个来自于生成文件的，用于生产该文件的命令的副本

对于程序开头的注释块而言，挑战在于更新它，以使其反映项目的当前状态。



### 8.1.2 .data段

用 NASM 编写的运行在 Linux 下的普通用户空间程序分为三个段，这些段在程序中的排列顺序并不重要，但是根据习惯，.data 段在最上面，其次是 .bss段，最后是 .text段。

.data 段包含了已初始化的数据项的数据定义，已初始化数据在程序开始运行前就拥有了自己的值，这些值是可执行文件的一部分，当可执行文件被加载到内存中用于执行时，它们被加载到内存中。你不必非要将它们与其值一起加载，除了将程序作为一个整体而加载到内存中所需的机器周期之外，并不需要额外的时间来创建它们。

关于 .data 段，最重要的是，定义的初始化数据项越多，可执行文件就会越大，运行它的时候，也就需要更长的时间才能将它从磁盘里加载到内存中。



### 8.1.3 .bss 段

并不是所有数据项在程序开始运行之前都拥有值。例如，从磁盘文件读取数据时，当数据从磁盘中出来之后，需要有一个存放的地方。那样的缓冲区是在 .bss 段中定义的。你为缓冲区预留一定数量的字节，然后给缓冲区取一个名字，但是并不指明缓冲区中将要出现什么值。

.data 段中定义的数据项和 .bss 段中定义的数据项之间有一个重要的差别：.data 段中定义的数据项将会添加到可执行文件的大小上，而 .bss 段中定义的数据项则不会。我们可以在 .bss 段中定义一个 16000(或更多)字节的缓冲区，而可执行文件的大小几乎不变(除了大约 50 个字节用于描述以外)

Linux 加载程序把程序带入内存的方式使这成为可能。当生成可执行文件时，Linux 连接器向描述所有已定义符号的文件添加一些信息，包括用来命名数据项的符号。加载程序知道哪些数据项没有初始值，当把可执行文件从磁盘加载到内存时，它为这些数据项分配空间，而具有初始值的数据项则与其初始值一起读如。



### 8.1.4 .text 段

真正组成程序的机器指令存放在.text段中。一般情况下，在.text段中不进行数据项的定义。.text 段中包含名为标号(label)的符号，这些符号用于标识跳转和调用的程序代码位置，但是位于指令助记符之外。

所有全局标号必须在 .text 段中声明，否则该标号就不能被 Linux 连接程序和 Linux 加载程序在你的程序之外看到。



### 8.1.5 标号

标号是一种类型的书签，用于描述程序代码中的某个位置，由于它拥有一个名字，因而比毫无装饰的内存位置更加容易记忆。标号用于标识转移指令应该跳转到的位置，也可为可调用的汇编过程起个名字。

下面是我们需要了解的关于标号的最重要的内容：

* 标号必须以字母开头；否则用下划线，句号或者问好开头。后三种对于汇编编译器来说，有着特殊含义，所以在了解 NASM 如何解释它们之前，不要使用它们。
* 当定义标号时，后面必须跟着一个冒号。这主要是告诉 NASM，被定义的标识符是一个标号。如果没有冒号的话，NASM 会像凌空踢球一样一脚把它踢出来，不会标记任何错误，但是如果有冒号定在那里的话，就可以防止一个敲入有误的指令助记符被误当做标号。所以请使用冒号！
* 标号是大小写敏感的。所以yikes:，Yikes:，和 YIKES:是三个完全不同的标号。

标号的作用：被用作转移指令和 call指令的目标操作数。

在 eatsyscall.asm 中只有一个标号，而且这个标号有些特殊。 _start 标号标识程序从何处开始。每一个 Linux 汇编语言程序都必须以这种方式进行标识，并且必须精确采用 _start 标号，此外这个标号必须在 .text 段的顶部标记为全局的，如前所示。

这是 Linux 操作系统的要求。Linux 下的每一个可执行程序必须在某处有一个 _start 标号，不管编写它的语言是 c ,Pacal 还是汇编。如果 Linux 加载程序找不到这个标号，它就不能正确地加载。Global 限定符告诉连接器让 _start 标号在程序的边界之外可见。



### 8.1.6 已初始化变量

像以下方式定义变量

```asm
MyByte: db 07H 				; 8 位大小
MyWord: dw 0FFFFH      ; 16 位大小
myDouble: dd 0B8000000 ; 32 位大小
```

可以将 DB 指令理解为“定义字节”。DB 预留一个字节的内存空间用于数据存储。可以将 DW 指令理解为 “定义字”。DW 预留一个字(16位或 2 个字节)的内存空间用于数据存储。可以将 DD 指令理解为“定义双字”。DD 在内存中预留一个双字的空间用于数据存储，通常用于完整的 32 位内存地址。



### 8.1.7 字符串变量

汇编中用以下方式定义字符串：

Mystr db "Hello world", 10

每一个字符都占用一个字节的大小，编译器会根据后面字符的个数预留相应的字节数。最后的数字 10 表示行结束符(EOL)

也可以使用 DW 来定义字符串，如下所示：

```asm
WordString: dw 'CQ'
mov ax,dw 
```

执行完第二条指令，ah保存字符'Q'，al保存字符'C'



### 8.1.8 通过 EQU 和 $ 推到字符串的长度

我们可以通过如下方式求出字符串的长度：

```asm
EatLen: equ $-EatMsg
```

包含 EQU 指令的语句叫做等值语句。等值语句是一种将一个值与标号相关联的方法。每当汇编编译器在编译过程中遇到一个等值语句，它都将该等值语句的值与其名字进行交换。例如

```
FieldWidth equalized 10
```

上面的汇编语句告诉汇编编译器 标号 FieldWidth 代表数值 10。一旦该值已经被定义，下面的两个机器指令就完全相同:

```
mov eax,10
mov eax,FieldWidth
```

这样做有两个优点:

* 等值通过一个值使用描述性的名字而使指令更容易理解。我们知道 10 这个值在此处的含义：它是字段的宽度
* 等值使程序更容易更改。如果在某种情况下，字段宽度从 10 变化为 12，我们只需要修改源文件中的一行代码，而不是每一处访问该字段宽度的地方。

要想在 Linux 下显示一个字符，我们不仅需要向操作系统传递字符串的地址，而且需要传递它的长度。可以通过如下方式创建一个字符串长度的等值:

EatMsg db "Hello world",10

EatLen equ 12

如果改变了字符串的长度，意味着将要改变EatLen的值。对于编译时计算而言，你只需修改字符串变量的定义，而它的长度则有 NASM 在编译时自动计算。

EatLen: equals $-EatMsg

$值代表 EatMsg的最后一个字符后面的位置，EatMsg代表字符串的开始位置。

整个原理是：结束处-开始处=长度

每次编译文件时都执行这种运算，因此任何时候 EatMsg 的内存发生改变，EatLen 的值都将被重新计算。

编译时计算还有一些其他的用途，但是这是最常见的一种，而且是一个当你作为初学者时很可能使用的用途。



## 8.2 通过堆栈实现后进先出

堆栈是一个直接构建在 x86 硬件之上的存储机制。英特尔没有发明它；自从 20 世纪 50 年代以来，堆栈一直是计算机硬件的组成部分。

x86 堆栈(和其他计算机硬件体系结构中的大部分其他堆栈)都被叫做后进先出或者 LIFO 栈。我们在堆栈顶部压入很多数据块，并且这些数据块将一直呆在堆栈中，直到我们按照相反的顺序将它们弹出。

堆栈并不存在某些单独的 CPU “壁橱”中。它就存在于普通的内存中，事实上我们称之为“堆栈”的东西实际上是一种内存数据的管理方式。堆栈是一个地方，我们可以暂时放入其中一个或两个(或需多个)32位双字，并在稍晚的时候再取出它们。它的主要好处是不需要我们给出存储数据的名称。我们将数据放入堆栈，后面不是通过内存地址而是通过位置来找回它们。

当把数据放入堆栈时，我们说，我们把数据压入堆栈；当从堆栈中取出数据时，我们说，我们把数据弹出堆栈。堆栈随着数据被压入或者被弹出而减小或增长。最新压入堆栈的项被认为是在“堆栈的顶部”。当从堆栈弹出一个项时，我们得到的是位于堆栈顶部的那一项。

在 x86 体系结构中，堆栈的顶部由名为堆栈指针寄存器的寄存器来进行标识，该寄存器的正式名称是 ESP。它是一个 32 位寄存器，里面存放着最后一个压入栈中的项的地址。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-15%20%E4%B8%8B%E5%8D%8811.47.03.png" alt="截屏2021-06-15 下午11.47.03" style="zoom:50%;" />

### 8.2.2 堆栈的内容上下跌倒

图 8-2 从广义上显示了当程序运行时，Linux 如何阻止分配给程序的内存。在内存底部的是程序中定义的三个段：.text 段位于最低的地址处，其次是 .data 段，再次是 .bss 段。堆栈一直位于程序的内存块的另一端。位于 .bss 段的末尾和堆栈的顶部之间的内存基本上是空的。

C 程序经常使用这种剩余内存空间来为那些位于堆内存中的，“已在运行中”的变量分配空间。汇编程序也可以这么做，尽管并不像听起来那么容易。需要记住的最重要的事情是：堆栈和程序(代码和已命名数据)在沙盒的相对角落里循规蹈矩地“玩耍”。堆栈朝着程序的剩余部分增长，但是除非你正在做一些真正惊人的事情，或者是愚蠢的事情，堆栈很少或者根本没有机会增大到能够撞到程序的已命名数据项或者机器指令的程度。如果出现这种情况，Linux 将会冷静地发出分段错误并且终止程序。

对于图 8-2 我的唯一警告是：程序段与堆栈的相对大小不应该照字面理解。程序代码可能有上千个字节，一个中等汇编程序中的数据可达成千上万个字节，但是所用的堆栈仍然相当小：最多几百个字节，一般低于这个值。

注意，当程序开始运行时，堆栈并不完全是空的。一些有用的东西在那里等着你。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-16%20%E4%B8%8A%E5%8D%8812.03.59.png" alt="截屏2021-06-16 上午12.03.59" style="zoom:50%;" />

### 8.2.3 Push-y 指令

我们可以采用几种方法将数据放入堆栈中，但最直接的方法涉及一组相关的机器指令，一共有 5 个：PUSH，PUSHF，PUSHFD，PUSHA 和 PUSHAD。所有指令都以相似的方式工作，它们之间的主要不同是压入堆栈的数据。

* PUSH 将一个在源代码中指定的 16 位或者 32 位寄存器值或者内存值压入堆栈。
* PUSHF: 将 16 位标志寄存器的值压入堆栈。
* PUSHFD: 将 Eflags 寄存器的全部 32 位值压入堆栈。
* PUSHA: 将所有的 8 个 16 位通用寄存器压入堆栈。
* PUSHAD: 将所有的 8 个 32 位通用寄存器压入堆栈。

下面是 PUSH 系列指令的一些使用举例：

```
pushf           ; 将标志寄存器压入堆栈。
pusha           ; 将 AX, CX, DX, BX, SP, BP, SI 和 DI 按此顺序一次性压入堆栈。
pushad          ; 将 EAX, ECX, EDX, EBX, ESP, EBP, ESI 和 EDI 按此顺序一次性压入堆栈。
push ax         ; 将 AX 寄存器压入堆栈
push eax        ; 将 EAX 寄存器压入堆栈
push [bx]       ; 将存放在 BX 里的内存中的字压入堆栈
push [edx]      ; 将存放在 EDX 里的内存中的双字压入堆栈
push edi        ; 将 EDI 寄存器压入堆栈
```

PUSH 采用以下方式处理 32 位操作数：首先，ESP 递减 32 位(4个字节)，指向堆栈段的一个四四节长的空白区域。然后将压栈的数据写入 ESP 指定的内存中。

PUSHA 从 286 处理器开始才添加到指令集，在 8086/8088 处理器中并不存在。

PUSHFD 和PUSHAD 从 386 处理器才开始添加到 x86 指令集。

因为 Linux 至少需要运行在 386 上，所以可以假设，任何 Linux 安装都支持 PUSHA，PUSHFD和 PUSHAD。

SP 初始位置与当前位置(栈顶)之间的所有内容包含真正的数据，这些数据被显式地压入堆栈，并且以后可以从堆栈中弹出。其中有些是在运行操作系统之前被操作系统压入堆栈的。

哪些数据可以压入堆栈，哪些数据不可以压入堆栈，这比较复杂，取决于你所使用的 CPU 。任何 16 位 和 32 位通用寄存器都可以被单独压入堆栈。但是 x86 CPU.不能将 8 位寄存器压入堆栈。立即数可以被压入堆栈，但是只有在 286 或者更高的处理上才行。(在 Linux 操作系统下这将永远为真。)用户模式 Linux 程序任何情况下都不能将段寄存器压入堆栈。

跟踪所有这一切曾经是 DOS 时代的一个难题。

PUSHAD 和 PUSHA的完整操作 

```
if(OperandSize = 32) { //PUSHAD instruction
	Temporary = ESP;
	Push(EAX);
	Push(ECX);
	Push(EDX);
	Push(EBX);
	Push(Temporary);
	Push(EBP);
	Push(ESI);
	Push(EDI);
}
else { //OperandSize = 16, PUSHA instruction
	Temporary = SP;
	Push(AX);
	Push(CX);
	Push(DX);
	Push(BX);
	Push(Temporary);
	Push(BP);
	Push(SI);
	Push(DI);
}
```



### 8.2.4 POP 指令 

一般来说，压入堆栈的内容必须要弹出来，否则你可能以若干种不同的麻烦之一结束程序。将堆栈中的数据项弹出来可通过另外一组指令五重奏来完成：POP，POPF，POPFD，POPA，POPAD。正如预想的那样，POP 是一个通用的，一次处理一个数据项的弹出指令，而 POPF 和 POPFD 专门用于从堆栈中弹出标志寄存器。POPA 从堆栈中弹出 16 个字节的数据到 8 个 16 位的通用寄存器中。POPAD 是 PUSHAD 的反向操作，它将栈顶的 32 个字节弹出到 8 个 32 位通用寄存器中。以下是一些例子：

```
popf     ; 从栈顶弹出两个字节到标志寄存器中。
popa     ; 从栈顶弹出 16 个字节到AX，CX，DX，BX，BP，SI和DI，方向和压栈时刚好相反，
popad.   ; 从栈顶弹出 32 个字节到EAX，ECX，EDX，EBX，EBP，ESI和EDI，方向和压栈时刚好相反，

popcx    ; 从栈顶弹出两个 2 个字节到 CX
pop esi  ; 从栈顶弹出 4 个字节到 esi 中
pop [ebx] ; 从栈顶弹出 4 个字节到 EBX 中的值所指定的内存中。
```

向 PUSH 一样，POP 只能操作 16 位或者 32 位操作数。

当 POP 指令被执行时，工作顺序是这样的：首先，当前存放在 ESP 中的值所代表的地址处的数据(无论是 16 位值，还是 32 位值，取决于操作数)被从堆栈中复制下来，然后放入 POP 的操作数中，无论你指定该操作数是什么；此后，ESP 递增步长为操作数的长度，这样，实际上 ESP 在堆栈中朝着远离低内存的方向上移动两个或四个字节。

对与 x86 而言，除非栈完全为空，否则 SP 指向的永远是真实的数据，而不是空白的空间。

需要记住一点：**POPA 和 POPAD 将把当前堆栈指针寄存器的值压入堆栈，并不改变 SP/ESP 中的值，而是在EDI，ESI，EBP加载后递增**

POPAD 和 POPA 的完整操作：

```
if(OperandSize == 32) {
	//Instruction == POPAD
	EDI = Pop();
	ESI = Pop();
	EBP = Pop();
	ESP = ESP + 4; //skip next 4 bytes of stack
	EBX = Pop();
	EDX = Pop();
	ECX = Pop();
	EAX = Pop();
}
else {
	//OperandSize == 16, instruction == POPA
	DI = Pop();
	SI = Pop();
	BP = Pop();
	ESP = ESP + 2; //skip next 2 bytes of stack
	BX = Pop();
	DX = Pop();
	CX = Pop();
	AX = Pop();
}
```

当执行指令`push ax`,此时 AX 的值为1234，那么堆栈从上到下依次保存 12，34，它的最低有效字节存放到 ESP 中，最高有效字节存放到 ESP+1中。（记住两个字节可被作为一个单位一次压入到堆栈中）

**MOV 指令不会操作 Flags 或者 EFlags寄存器，如果想加载一个 Flags 或者 EFlags 的副本到某一寄存器中，必须使用PUSHF 或者PUSHFD 指令 将 Flags 或者 EFlags 的值压入堆栈，然后再使用 POP 指令将Flags 或者 EFlags 的值从堆栈中弹出到选定的寄存器中。 **

比如，要想将 Flags 寄存器中的值放入 BX 寄存器中，可通过如下指令完成：

```
PUSHF     ; 将 Flags 寄存器压入堆栈
POP BX    ; 立即将
```

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-16%20%E4%B8%8B%E5%8D%888.55.32.png" alt="截屏2021-06-16 下午8.55.32" style="zoom:67%;" />

并非 EFlags 中的所有位都能被 POPFD 改变。当从堆栈中弹出一个值到 EFlags 中时，VM位 和 RF 位不会受到影响。



### 8.2.5 临时存储

堆栈被视为一个短期存放数据的地方。存放在堆栈中的数据项没有名字，并且一般情况下必须按照与进入堆栈相反的顺序弹出。

堆栈的一个非常好的应用是它允许数量确实太少的寄存器“身兼多职”。如果需要一个寄存器来暂时存放某些即将被 CPU 操作的值，而所有寄存器刚好都在使用中，可以将其中一个繁忙的寄存器的值压入堆栈中。当你使用完寄存器，再将原来的值从堆栈中弹出——这样，在并非真的拥有一个额外寄存器的情况下，你已经获得了一个额外的寄存器的好处。(当然，代价是花费在移动那个寄存器的值到堆栈中和将其从堆栈中弹出所需要的时间。我们当然不希望在需要频繁重复的循环中做这件事)

在程序的执行过程中，短期存储是堆栈最简单，最明显的用法，但是，它最重要的用途可能是程序调用和 Linux 内核服务。现在，我们已经了解了堆栈的相关知识，可以揭开 INT 指令的神秘面纱了。



## 8.3 通过 INT 80 使用 Linux 内核服务

eatsyscall.asm

```asm
; 可执行程序明 : EATSYSCALL
; 版本 : 1.0
; 创建日期 : 2021-1-9
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   演示了  Linux INT 80H  系统调用显示文本的用法
;
; 使用这些命令生成：
; nasm -f elf -g -F DWARF eatsyscall.asm -o syscall.o
; ld -m elf_i386 -o eatsyscall eatsyscall.o
;

SECTION .data                   ; 包含已初始化的数据的段


EatMsg: db "Eat at Joe's!",10
EatLen: equ $-EatMsg

SECTION .bss                    ; 包含未初始化的数据的段
SECTION .text		        ; 包含代码的段

global _start                   ; 连接器需要据此找到入口点！

_start:
	nop			    ; 这个无操作指令让 gdb 非常高兴
	mov eax,4		; 指定 sys_write 系统调用
	mov ebx,1 		; 指定文件描述符1：标准输出
	mov ecx, EatMsg	        ; 传递显示信息的偏移地址
	mov edx,EatLen 		; 传递显示信息的长度
	int 80H			; 进行系统调用来输出文本到标准输出
	
	mov eax,1 		; 指定 Exit 系统调用
	mov ebx,0		; 返回一个零代码
	int 80H			; 进行系统调用来终止代码
```

上述源码做的唯一真正工作：将一行文本显示到 Linux 控制台。这个程序的核心宗旨是：通过使用带 80H 参数的 INT 指令，实现对于 Linux 操作系统内核服务的调用。

Linux 以神圣的方式控制着机器的所有最重要的部分：磁盘驱动器，打印机，键盘，各种接口(以太网，USB，蓝牙等)和显示器。同时，Linux 也像一个生活在一座连接计算机的所有这些部件的桥梁下面的恶魔：你告诉巨魔你想做的事情，然后巨魔会为你代劳。

Linux 提供的服务之一是简单地访问个人电脑显示器。那么，如何使用 Linux 服务？我们必须通过 Linux 内核请求这些服务。有一种使用起来非常容易但是理解起来比较棘手的方法：通过软件中断。



### 8.3.1 不中断任何事情的中断

在 eatsyscall.asm 程序中列举过的两次真实的示例能够很好地解释软件中断和 Linux 服务的本质。正如我先前暗示的那样，Linux 让库例程(着眼于某一单一任务的机器指令序列)在它的内部隐藏起来。每个库例程指令序列都做一些有用的事情——从文件中读取数据，发送数据到文件中，获取当前时间，访问网络端口，等等。Linux 使用这些库例程来完成自己的工作，同时也允许程序员从自己的程序中访问它们。

所有的机器指令序列都拥有地址，那么为什么不公布一份所有这些有用例程的地址列表呢？这里存在两个问题：

1. 允许用户空间程序对操作系统内部进行访问是危险的。恶意软件编写者可以通过修改操作系统的关键组成部分来监视用户的活动，捕获击键并转发给其他地方，等等。
2. 任意给定指令序列的地址从一个安装到到另一个安装会有所变化，不仅如此，甚至(随着软件不断被从个人电脑上安装，配置以及移除)从一天到另一天也会有所变化。Linux 在不断进化，完善和在现有基础上进行修复。修复和完善代码涉及增加，修改和删除机器指令，而这些会改变那些隐藏的代码序列的大小——且作为结果，它们的位置也会发生变化。

解决方案非常巧妙。有一种调用 Linux 内部服务例程的方法，它不需要依赖任何地址。大多数称之为内核服务调用门，它是一个戒备森严的门户，位于程序运行的用户空间和 Linux 神/巨魔完成其工作的内核空间之间。调用门方案通过一个 x86 软件中断实现。

在 x86 最开始的一段内存中，段地址和偏移地址均为 0 的地方，有一个特殊的具有 256 个数据项的查找表。每一项都是占用 4 个字节，包括段地址和偏移地址的完整内存地址。任何 x86 机器上的第一个 1024 字节的内存被预留出来存放此表，不能在那里存放其他的代码或数据。

表中的每一个地址都被叫做中断向量。这张表作为一个整体被叫做中断向量表。每个向量都有一个 0 到 255 之间的编号。占用表中 0 到 3 字节的向量是向量0，占用表中 4 到 7 字节的向量是向量 1。依次类推。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-16%20%E4%B8%8B%E5%8D%8811.53.20.png" alt="截屏2021-06-16 下午11.53.20" style="zoom:50%;" />



这些地址没有一个像个人电脑 BIOS 例程那样烧制到永久性内存中。当机器启动时，Linux 和 BIOS 向很多位于中断向量表中的插槽填写关于该插槽本身的中断程序的地址。每一个版本的 Linux 都知道其内部部件的位置，并且当升级到新的 Linux 版本时，这个新的版本会向很多位于中断向量表中的插槽填写升级之后的准确地址。

从一个 Linux 版本到另一个 Linux 版本中没有什么变化的是存放特定地址中断编号。换句话说，从最早的 Linux 发行版本开始，中断 80H 就指向进入最漆黑的通往(将近 200 个)的，单独的 Linux 内核服务例程的支线。在大多数 Linux 发行或版本，程序都能通过中断向量表中的 80H 项来访问该调度程序。

程序不必非得通过查找中断向量表才能获得它们的地址(实际上也无权访问，因为它属于操作系统)。但是，你不一定非要直接访问表中的地址。x86 处理器包括一条机器指令，它拥有特殊的使用中断向量表的权利。eatsyscall.asm 使用 INT(中断)指令来请求在屏幕上显示一条字符串的 Linux 服务。eatsyscall.asm 在两个地方都有一个 INT 80H 指令。当执行一条 INT 80H 指令时，CPU 查找中断向量表，并从 80H 表项中取出地址，然后再将执行流程跳转到给地址。从用户空间到内核空间的过程非常干净，而且非常可控。而另一边，位于存储在表中 80H 项中的地址处的调度程序开始执行，开始完成你的程序请求的服务。

这一过程如图 8-5 所示。当 Linux 在计算机引导期间被加载时，它为计算机准备使用所做的诸多事情之一就是把正确的地址放入中断向量表中的几个向量中。其中一个地址就是内核服务调度的地址，它将进入插槽 80H

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/INT.png" alt="截屏2021-06-17 上午12.13.10" style="zoom:67%;" />



以后，当在 Linux 控制台的命令行中键入程序名称 eatsyscall 时，Linux 加载 eatstscall 的可执行文件到用户空间内存，并运行它执行。为了访问内核服务，eatsyscall 根据需要执行了 INT 80H。除了需要知道在中断向量表中的编号之外，eatsyscall 继续处于无知状态，它只是简单地让 INT 80H 指令和中断向量 80H 将它带到需要的地方。

而在幕后， INT 80H 指令做了一些其他事情，在沿着向量 80H 所示的地址进入 Linux 内核之前，它把下一条指令(即紧跟在 INT 80H 指令后面的那条指令)的地址压入堆栈。以帮助 CPU 在 “远足” 到 Linux 内部之后依然能够找到返回 eatsyscall 的路线。

现在，Linux 内核服务调度程序控制着对于这 200 个单独的服务例程的访问。它是如何知道执行哪一个例程的呢？我们要告诉调度程序需要哪个服务，这可以将服务的编号放入寄存器 EAX 中来实现。在开始工作之前，调度程序可能还需要将其他信息，并且期待你在正确的位置提供该信息(它们几乎总是在各种各样的寄存器中)

例如下面的代码：

```asm
mov eax,4		; 指定 sys_write 系统调用
mov ebx,1 		; 指定文件描述符1：标准输出
mov ecx, EatMsg	        ; 传递显示信息的偏移地址
mov edx,EatLen 		; 传递显示信息的长度
INT 80 H
```

这个指令序列要求 Linux 显示一个文本字符串到控制台。第一行建立一个关键信息：需要请求的服务的编号。在本例中，它是 sys_write，服务编号为 4 它能够将数据写入一个 Linux 文件中。请记住，几乎所有东西都文件，其中也包括控制台。第二行告诉 Linux 写入哪个文件：标准输出。每个文件都必须有一个数字的文件描述符，前3(0,1,2)个是标准的，并且永远不会改变。标准输出的文件描述符是1。

第三行把将要显示的字符串的地址放到 ECX 寄存器中。Linux 通过它来知道我们想要显示的内容。调度程序希望我们将地址存入 ECX 寄存器中，但是那个地址只是字符串的开始位置。Linux 还需要知道字符串的长度，我们将那个值放在 EDX 寄存器中。

当内核服务编号，字符串的地址和字符串的长度被放入适当的寄存器之后，我们通过执行 INT 80H 到调度程序旅行了一圈。INT 指令是它需要的所有内容。执行跨过“桥梁”进入内核空间，Linux 巨魔在那里读取 ECX 处的字符串，并且通过它那或多或少有些保密的机制，将其发送到控制台。大多数情况下，这是一件好事：描述程序机制可能需要很多的信息，它就像描述你的个人生活一样一言难尽。



### 8.3.2 再次返回

上面讲解了进入 Linux 内部。那么程序如何再次返回呢？向量 80H 中的地址将执行带入内核服务调度程序。

要想继续执行在 INT 80H 指令之前所遗留的内容，Linux 必须在一个完全可靠的地方找回返回地址，而那个完全可靠的地方不是别处，正是栈顶。

INT 80H 指令在进入一个未知地址之前，先将一个地址压入堆栈。这个地址就是下一条即将轮到执行的指令的地址：紧跟在 INT 80H 指令后面的那条指令的地址。这个位置是完全可靠的，因为，正如一台机器上只有一个中断向量表一样，在任何一个时间段中，只有一个堆栈在工作，这意味着只存在一个堆栈的栈顶——也就是 ESP 寄存器所指向的地址——通过将地址从栈顶弹出，然后跳转到那个地址，Linux 总是能够将执行送回到调用它的程序中。

这一过程如下图所示，它是图 8-5 的延续。正如 INT 指令将一个返回地址压入堆栈中，然后跳转到存放在某一特定向量中的地址一样，有一条“配对”指令能够将返回地址从堆栈中弹出，然后跳转到这个地址，**这条指令就是 IRET(用于中断返回)**，它完成这一复杂却可靠的系统(在你不知道地址的情况下，跳转到这个地址)。再次地，其中的技巧是知道在哪里可以可靠地找到地址，在本例中，那个地方就是堆栈。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-17%20%E4%B8%8B%E5%8D%8812.16.53.png" alt="截屏2021-06-17 下午12.16.53" style="zoom:50%;" />



实际上，软件中断机制压入和弹出堆栈的内容不止这些，但是它的发生非常透明，等有了基础，应该去尝试编写自己的软件中断例程。那是在内核区编程，我鼓励你完成这一目标。



### 8.3.3 通过使用 INT 80H 退出一个程序

在 eatstscall.asm中，有第二个 INT 80H指令，它完成一项谦卑却又关键的工作: 关闭程序，将控制权返回给 Linux。这比它的实际情况听起来要简单，一旦你了解了更多 Linux 内部知识以后，你将开始重视那项必不可少，既要启动一个进程又要关闭一个进程的工作。

从自己的程序的角度来看，它非常简单：将 sys_exit 服务的中断号放入 EAX 寄存器中，把返回值放入 EBX 寄存器中，然后执行 INT 80H :

```asm
mov eax,1       ; 指定退出系统调用
mov ebx,0       ; 将零作为返回值
int 80H         ; 进行系统调用以终止程序
```

返回值是一个数字，它的内容没有任何限制(除了必须适合存放在 32 位寄存器中之外)，但是按照惯例，返回值为 0 意味着"一切工作都完成了；正常关闭"。返回值为 0 以外的数字则通常表明发生了某种类型的错误。请记住，在更大一些的程序中，必须留意那些没有按照预期工作的事情：找不到磁盘文件，磁盘驱动器已满，等等。如果程序不能完成其工作，必须提前终止，它应该以某种方式告诉你(或在某些情况下，另一个程序)哪里出了问题。返回值就是一个能够做到这一点的好办法。

我们编写的每一个程序都必须以这种(通过内核服务调度程序来进行 sys_exit 调用的)方式退出。



### 8.3.4 软件中断 VS 硬件中断

软件中断是一种 CPU 注意自身之外世界的机制，硬件中断是一种 CPU 注意自身之外世界的机制。

一个内置在电脑中的相当复杂的电气系统能够让电路板发送信号给 CPU。CPU 芯片上的一个金属针被电路板设备(如磁盘驱动器，控制器或一个串口板)从某一伏特电压等级变为另一等级。通过这个引脚，外部设备能够“轻拍 CPU 的肩膀”。CPU 将这种“轻拍”识别为硬件中断，在中断向量表中都预留一个 “插槽”(表项)。在这个插槽中，存放的是一个中断服务例程(ISR)的地址，该中断服务例程执行一些与轻拍 CPU 肩膀的设备相关的事情。例如，如果中断信号来自一个串口电路板，CPU 将会允许该串口板从它自己传输一个字符字节到 CPU 中。

硬件中断和软件中断之间的唯一不同之处是触发到中断向量表之旅的事件。在软件中断中，触发事件是软件的一部分，也就是说，一条 INT 指令。在硬件中断中，触发事件是一个应用于 CPU 芯片本身的，没有任何 INT 指令插手这一过程的电信号。当意识到有电脉冲触发中断时，CPU 自己把返回地址压入堆栈，但是，当 ISR 执行完毕，必须通过一条 IRET 指令将执行 “送回家”，就像在软件中断中所做的一样。

这里所说的用于在一个软件中断调用后的“返回”机制，实际上比听起来更加普遍。在本书的后面，我们将开始把程序分割成过程，这些过程通过一对指令来进行访问：CALL 和 RET。CALL 将下一条指令的地址压入堆栈，然后跳转到一个过程；在该过程的结尾处，一条 RET 指令将该地址从堆栈的栈顶弹出，然后允许执行继续捡起 CALL 指令后面的内容。



### 8.3.5 INT 80H 和可移植性崇拜

Unix 世界一直秉承这样的理念，即一个程序应该能够在不需要更改的情况下被重新编译，并且能够正确地运行在完全不同的 CPU 体系结构上的 Unix 上。这仅仅是勉强可以的，只对那些用简单语言(C)编写的相对简单的程序适用，该简单语言使用计算机系统所能提供的"最小公分母" 子集。进入精心制作的图形用户界面(GUI)应用程序和现代的外设之后，你将面对很多拥有大量复杂的应用程序编程接口(API)的，不兼容的软件库，以及那些本不应该存在却非常不礼貌地存在着的设备驱动程序怪癖。

再加上近年来所有这些 API 和新的，更高级的语言(比如 Python)的不断演变，你在去年编写的程序甚至可能今年就不在同一平台上编译了，你将面对我在很多年前得出的结论：嵌入式便携性就是一个神话。我们现在的平台如此复杂，以至于每一个应用程序都基于特定的平台。跨平台编码可以做，但必须修改源代码，通常折中于必须使用条件编译来实现——**本质上来讲，条件编译就是程序里面的 IF 语句集，该语句通过一系列传递给编译器的参数来改变源代码；**如果在 x86 上的 Linux 进行编译，编译这些语句；如果在为 x86 上的 BSD Unix 进行编译，编译其他语句，等等。条件编译，仅仅是佩戴在残酷的底层现实上的面具：计算机是不同的。计算机系统是不断进化的。

在本节讲的 Linux 内核服务调用实际上是针对特定的 Unix 的 Linux 实现的。其他的 Unix 实现以不同的方式处理。在 Unix 操作系统的 BSD 家族中，内核服务调度程序也是通过INT 80H 实现的，但是，参数被传递到内核的堆栈上，而不是寄存器中。无论是好是坏，它们是不同的，Linux 汇编程序将无法运行在 BSD Unix 下。(要想了解“可移植性”的编码，你应该学习 Python，这是一种极具魅力的非常高级的语言，并且几乎出现在所有的 Unix 实现上。)

但是，在 Linux 的发行和甚至跨年的升级中，内核服务列表本省只是改变了一点点，改变更多的主要是最近几年添加到内核的更加神秘的服务。如果在 Linux 的 x86 发布下编写的汇编代码不会等同地运行在另一个 x86 发布中，它并不是由于调用内核服务的方式造成的。

汇编语言不是也不能是可移植的。它不是为实现移植而设计的。另一方面，也不要让任何人试图说服你去做这件事。



## 8.4 设计一个有价值的程序

要想编写一个有价值的汇编程序，如果没有条件转移语句，会很困难。



### 8.4.1 问题定义

我们将工作在 Linux 下。

数据存在于磁盘文件中。

我们事先不知道任何一个文件的大小。

文件没有最大值或最小值。

我们将使用 I/O 重定向技术将文件名称传递给程序。

所有输入文件都采用相同的编码方案。这个程序可以假设在一个文件中的字符“a”与另一个文件中的字符“a”所采用的编码方式相同。

我们必须以原来的形式保留原始文件，而不是从原始文件读出数据，然后将其再写回到原始文件中。(这是因为如果进程崩溃，我们会在没有完全生成输出文件的情况下破坏原有文件)



### 8.4.2 从伪代码开始

这是一种可能采用的陈述形式：

* 从输入文件读如一个字符。
* 将该字符转换成大写字符(如果需要的话)。
* 将字符写入到输出文件中。
* 重复该过程直至任务完成。



### 8.4.3 连续改进

下一轮改进：

* 从标准输入(stdin)中读如一个字符。
* 测试该字符以判断其是否为小写字符。
* 如果该字符为小写字符，则将其通过与 20H 相减来将其转换为大写字符。
* 将字符写入标准输出(stdout)。
* 重复该过程直到任务完成。
* 通过调用 sys_exit 来退程序。



我们如何知道输入文件已经没有字符？这可能需要一些研究，但是在大多数操作系统(包括 Linux)中，你调用的用于从文件中读取数据的例程都会有一个返回值。这个值可以表明一次成功的读取，一次错误的读取或者某者特例结果。例如；文件是否结束(EOF)。一个扩展的解决方案版本的伪代码可能像这样：

* 从标准输入(stdin)中读如一个字符。
* 测试一下是否已经到达了文件的结尾(EOF)。
* 如果已经到达了文件的结尾，我们已经完成任务，所以跳转到 exit。
* 测试该字符以判断其是否为小写字符。
* 如果该字符为小写字符，则通过将其与 20H 相减来转换为大写字符。
* 将字符写入标准输出(stdout)。
* 回去读取另一个字符。
* 通过调用 sys_exit 来退出程序。

随着语句的添加，对那些代表跳转目标的语句添加标号会给我们带来帮助，这样可避免混淆跳转目标，即便是在伪代码中。通过将相关语句组合在一起，它也有助于我们将伪代码分解成子块。我们迟早会得到以下内容类似的结果:

Read : 设置用于 sys_read 内核调用的寄存器。

​			 调用 sys_read 从标准输入中读如一个字符

​			 测试 EOF

​             if 我们到了 EOF，跳转到 Exit

​             测试该字符以判断其是否为小写字符

​			 if 它不是小写，跳转到 Write

​            通过将字符与 20H 相减来将其转换为大写字符。 

 Write：为写内核调用设置相关寄存器

​				调用sys_write 向标准输出写数据

​				跳回到标号 Read 处，读取另一个字符。

Exit:    设置通过 sys_exit 来停止程序所需的寄存器，调用 sys_exit



```
; 可执行程序明 : uppercaser1
; 版本 : 1.0
; 创建日期 : 2021-6-17
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   将一个文本文件中小写字母转换为大写，其他字符不变，写入到另一个文件
;
; 使用这些命令生成：
; nasm -f elf -g -F DWARF uppercaser1.asm -o uppercaser1.o
; ld -m elf_i386 -o uppercaser1 uppercaser1.o
; 运行方式，假设当前目录下有一文本文件 t1.txt，执行命令: ./uppercaser1 > t2.txt < t1.txt 
; 程序将t1.txt中的小写字母转换为大写，其他字符不变，转换后的文件保存在t2.txt，若t2.txt不存在，则首先创建该文件，再将结果写入
;         
section .bss
    Buff resb 1

section .data

section .text
    
    global _start

_start:
    nop

Read:
    mov eax,3            ;   指定 sys_read 调用
    mov ebx,0            ;   指定文件描述符0：从标准输入
    mov ecx,Buff         ;   传递即将从中读取数据的缓冲区地址
    mov edx,1            ;   告诉 sys_read 从标准输入读入一个字符
    int 80H              ;   调用 sys_read
    cmp eax,0            ;   观察 sys_read在EAX寄存器中的返回值。
    je Exit              ;   如果为零(意思是EOF)则跳转到Exit
                         ;   如果不为零，则测试它是否为一个小写字母

    cmp byte [Buff],61H  ;   将输入字符与小写字母 'a' 比较
    jb Write             ;   如果在 ASCII 表中比 a 小，则不是小写字符

    cmp byte [Buff], 7AH ;   将输入字符与小写字符 'z' 比较
    ja Write             ;   如果在 ASCII 表中比 'z' 大，则不是小写字符
                         ;   此时，我们已经拥有了一个小写

    sub byte [Buff],20H  ;   从小写字符中减去 20H，得出相应的大写字符
                         ;   然后将该字符写出到标准输出



Write:
    mov eax,4            ;  指定 sys_write 调用 
    mov ebx,1            ;  指定文件描述符1：标准输出
    mov ecx,Buff         ;  传递要写出的字符的地址
    mov edx,1            ;  传递要写出的字符的数量
    int 80H              ;  调用 sys_write
    jmp Read             ;  然后跳转到开始处，获取另一个字符

Exit:
    mov eax,1            ;  退出系统调用的代码
    mov ebx,0            ;  将零作为返回值而返回 Linux 
    int 80H              ;  进行内核调用以退出程序

```



Buff 是一个尚未初始化的变量，因此位于程序的 .bss 段中。Buff 没有初始值，并且不包含任何内存，直到我们从 stdin 中读如一个字符并将其存储在那里。

由于内存地址(如 Buff)只是指出内存中的一个没有指定固定大小的位置，所以必须在 CMP 和它的内存操作数之间放一个限定符 BYTE，告诉 NASM，他要比较两个 8 位的值，在本例中，这两个 8 位值是一个 ASCII 字符(如 '"w")和一个十六进制值(如 7Ah)



### 8.4.4 不可避免的 “哎呀！”时刻

你可能会认识到，有一些用汇编语言实现的，更短的完成某事的方法，它能比直接从字面翻译伪代码带来更好的效果。学无止境，无论认为自己学的多么棒，你都永远处于学习状态。

一个很好的例子，程序没有检测到错误，它假设用户为 I/O 重定向输入的输入文件已经存在并且没有损坏，文件里面已经存有数据，在当前用于输出文件的驱动器也会有空间，等等。这种操作方式很危险，即使它能够侥幸完成。与文件相关的 Linux 系统调用都能返回错误值，任何使用它们的程序员都应该检查这些错误，并据此采取响应的行动。

总之，在整个过程中，总要上演几次你必须认真推敲伪代码，甚至将其完全推翻，然后再重新开始的场景。当你处于将伪代码转换为机器指令的最后阶段时，这种(令人讨厌的)情况经常发生。请做好思想准备。

如果你了解一些关于低级文件输入/输出的相关知识：Linux 的 sys_read 内核调用不仅限于一次返回一个单个字符，你将一个缓冲区地址传递到 sys_read中，sys_read 将尝试从输入文件中向该缓冲区填充字符，可以指定填充的字符数，前提是输入文件中有那么多字符。对sys_read 的一次简单调用就能够一下子带给你 很多个字符，这样就可以减少 Linux 在切换文件系统和你的程序上所花费的时间。

在改进问题解决方案的伪代码过程中，你应该已经知道了前期步骤。有很多你的大脑和指尖都需要的诸如此类的细节，你不可能一个下午就将它们变为永不磨灭的记忆。这种启示经常迫使你“备份”一个或两个迭代，并且重新改写某些伪代码。



### 8.4.5 扫描缓冲区

Unix 的读写内核调用是面向缓冲区而非面向字符的，因此我们必须重新修改伪代码以填充字符到缓冲区中，然后再处理这些缓冲区。这里添加了从磁盘读取缓冲区，扫描和转换缓冲区中的字符，以及后来将其写回到磁盘缓冲区所需的一切内容。(当然，缓冲区必须从一个字符扩大到某些有用的大小，如 1024 个字符)。缓冲区的技巧要点是建立一个指向缓冲区的指针，然后检查(如有必要)和转换指针所代表处的地址处的字符。然后将指针移动到缓冲区的下一个字符，做同样的事情，重复该过程，知道已经处理完缓冲区中的所有字符。

扫描缓冲区是一个很好的关于汇编语言循环的例子。

Read: 为 sys_read 内核调用设置寄存器

​			调用 sys_read 从标准输入读入满满一缓冲区的字符

​			将读入字符的数量存放到 esi 寄存器中

​			测试 EOF (eax = 0)

​			if 我们到了文件的结尾，跳转到 Exit



​             将缓冲区地址放入 ebp 中

​			将读入缓冲区中的字符的数量放入 ecx 寄存器中



Scan 将[ebp+ecx] 处的字节与'a'比较

​		if 该字节在 ASCII 表中的顺序比 'a' 小，则跳转到 Next 处

​		将[ebp+ecx] 处的字节与'z'比较 

​        if 该字节在 ASCII 表中的顺序比 'z' 大，则跳转到 Next 

​		通过将该字符与 20H 相减来将其转换为相应的大写字符

​		

Next: 将 ecx 寄存器递减1

​			if 不为零，跳转到标号 Scan



Write: 为写内核调用设置寄存器。

​			调用 sys_write 将处理后的缓冲区内容写到标标准输出

​             跳回标号 Read处，然后获取另一个充满字符的缓冲区



Exit: 通过 sys_exit 来终止程序而设置寄存器

​		调用 sys_exit





### 8.4.6 缓冲溢出(“Off By One”)错误

在伪代码中有一个漏洞(bug)，它是所有汇编语言初学者最常见的错误之一：传说中的缓冲溢出(“off by one”)错误。EBP 和 ECX 之和将指向一个超出缓冲区结尾的地址。当 ECX 中的计数值为零时，仍然有一个字符(在缓冲区的最开始的那个)没有受到检验，并且保持不变。解释这个漏洞来源的最简单方法就是将其画出来。如图 8-7 所示：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-18%20%E4%B8%8A%E5%8D%8811.19.02.png" alt="截屏2021-06-18 上午11.19.02" style="zoom:50%;" />

​			              

每当地址偏移和某种计数值合二为一的时候，这种问题都有可能发生，计数从 1 开始，而偏移量从 0 开始。字符 #1 实际上位于相对于缓冲区开始位置偏移地址为 0 的地方，字符 #2 在偏移地址为 1 的地方，等等。我们正在尝试将一个 ECX 中的值既作为计数值来用，又作为偏移地址来用，如果缓冲区里的偏移地址假定从 0 开始，一个缓冲溢出错误将不可避免。

解决方法很简单：在开始扫描前，将缓冲区的地址(它被存储在 EBP 中)递减 1，EBP 现在指向缓冲区的第一个字符前面的内存位置。EBP 以这种方式设置之后，我们就可以将 ECX 中的值既作为一个计数值来用，又作为一个偏移地址来用了。当ECX 中的值递减为 0 时，我们已经处理了 “g” 字符，并且退出循环。

下面是循环的机器指令：

; 设置寄存器，用于转换缓冲区这一步骤

​	mov ecx, esi              ;  把读入的字节数放入 ecx 寄存器中。

​    mov ebp,Buff           ;  把缓冲区的地址放入 ebb 寄存器中。

​	dec ebp



; 搜查该缓冲区，并将小写字符转换为大写字符:

Scan: 

​		cmp byte [ebx+ecx], 61H       ;  测试输入字符，将其与小写字符 'a' 相比较

​		jb Next									  ;  如果 ASCII 码值比 'a' 的 ASCII 值小，则不是 小写字符

​	    cmp byte [ebx+ecx], 7AH      ; 测试输入字符，将其与小写字符'z' 相比较

​        ja Next                                      ;  如果 ASCII 码值比 'z' 的 ASCII 值大，则不是 小写字符



; 此时 ，我们有了一个小写字符

​	   sub byte [ebp+ecx],20H          ;  与 20H 相减，得到大写字符

​	

Next: dec ecx

​		 jnz Scan                                   ;  如果不为零则跳转到 Scan





纯粹主义者认为，在循环开始前递减 EBP 中的地址是一个冒险的黑客行为。它们有一半是正确的，如果程序试图在该位置写入一个值，则可能破坏另一个变量，或者导致一个分段错误的结果，这里，循环的逻辑并不要求在那个特定的地址写入数据，但是很容易误操作。

处理 off-by-one 错误的"合适" 方法就是让 EBP 一直指向缓冲区的真正开始位置，然后在循环开始时而不是在结束时递减 ECX。测试 ECX，判断其是否为零的工作仍然必须要做，但是在循环的最后，通过一条单独的 CMP 指令来完成。这样不仅能够正常工作，而且指针总是指向缓冲区内不的内存位置:

; 设置寄存器，用于转换缓冲区这一步骤

​	mov ecx, esi              ;  把读入的字节数放入 ecx 寄存器中。

​    mov ebp,Buff           ;  把缓冲区的地址放入 ebb 寄存器中。



; 搜查该缓冲区，并将小写字符转换为大写字符:

Scan: 

​		cmp byte [ebx+ecx], 61H       ;  测试输入字符，将其与小写字符 'a' 相比较

​		jb Next									  ;  如果 ASCII 码值比 'a' 的 ASCII 值小，则不是 小写字符

​	    cmp byte [ebx+ecx], 7AH      ; 测试输入字符，将其与小写字符'z' 相比较

​        ja Next                                      ;  如果 ASCII 码值比 'z' 的 ASCII 值大，则不是 小写字符

; 此时 ，我们有了一个小写字符

​	   sub byte [ebp+ecx],20H          ;  与 20H 相减，得到大写字符



Next: cmp ecx,0                              ;  判断字符计数器的值是否为 0

​			jnz Scan                               ;  如果没有，则跳转回去，继续循环



但是，这样做需要付出代价：循环内部的指令比以前多处了一条。循环次数很少时，影响并不大，但是当循环次数达到数千，数万或者数百万的话，即使是非常微小的时间片累加起来，执行速度也能明显变慢。

将所有的伪代码全部转换为汇编代码之后的完整程序如下:

```asm
; 可执行程序名：uppercaser2
; 版本：1.0
; 创建日期：2021年6月18日
; 最后修改日期：2021年6月18日
; 作者: wangjun
; 描述：一个为 Linux 编写的简单的汇编程序，使用 NASM 2.13.02
; 展示了简单的文本文件输入/输出(通过重定向)
; 为了实现从输入文件读入一块缓冲区，强制将小写字符转换为大写
; 将修改过得缓冲区写入到一个文件
; 
; 以这种方式来运行它:
; uppercaser2 > (output file) < (input file)
; 
; nasm -f elf -g -F DWARF uppercaser2.asm
; ld -m elf_i386 uppercaser2.o -o uppercaser2
;

SECTION .bss                ; 包含未初始化数据的段
    BUFFLEN equ 1024        ; 缓冲区的长度
    Buff: resb BUFFLEN      ; 缓冲区文本本身

SECTION .data               ; 包含已经初始化数据的段

SECTION .text               ; 包含代码的段

    global _start           ; 连接器需要这个来找到入口点

_start:
    nop

; 从标准输入读入满满一缓冲区文本
Read:
    mov eax,3               ; 指定 sys_read 调用
    mov ebx,0               ; 指定文件描述符0: 标准输入
    mov ecx,Buff            ; 传递要从中读入数据的缓冲区的地址
    mov edx,BUFFLEN         ; 传递一次循环中要读入的字节数
    int 80H                 ; 调用 sys_read 来填充缓冲区
    mov esi,eax             ; 复制 sys_read 的返回值并妥善保管
    cmp eax,0               ; 如果 eax=0, 则 sys_read 到了标准输入的结尾
    je Done                 ; 如果(与0相比较)相等则跳转

; 设置寄存器，用于处理缓冲区这个步骤

    mov ecx,esi             ; 将读入的字节数放入 ecx 寄存器中
    mov ebp,Buff            ; 将缓冲区的地址放入 ebp 寄存器中
    dec ebp                 ; 调整偏移地址的计数值
    
; 详细检查缓冲区，并将小写字符转换为大写字符
Scan:
    cmp byte [ebp+ecx],61H  ; 测试输入字符，将其与小写字符 'a' 相比较
    jb Next                 ; 如果 ASCII 码值比 'a' 的 ASCII 码值小，则不是小写字符
    
    cmp byte [ebp+ecx],7AH  ; 测试输入字符，将其与小写字符 'z' 相比较
    ja Next                 ; 如果 ASCII 码值比 'z' 的 ASCII 码值大，则不是小写字符

    ; 此时我们拥有了一个小写字符
    sub byte [ebp+ecx],20H  ; 与 20H 相减，得到大写字符

Next:
    dec ecx                 ; 递减字符计数器
    jnz Scan                ; 如果仍然有字符，则继续循环


Write:
    mov eax,4               ; 指定 sys_write 调用
    mov ebx,1               ; 指定文件描述符1: 标准输出
    mov ecx,Buff            ; 传递缓冲区的偏移地址
    mov edx,esi             ; 传递缓冲区数据的#个字节
    int 80H                 ; 进行 sys_write 内核调用
    jmp Read                ; 回去继续循环，加载另一满满的缓冲区数据

; 全部搞定

Done:
    mov eax,1               ; 退出 syscall 的代码
    mov ebx,0               ; 将零作为返回值返回
    int 80H                 ; 进行 sys_exit 内核调用
```



### 8.4.7 进一步学习

无论使用什么语言编程，这个过程都会很好地为你服务。当你在这个项目以及所有未来项目上继续前行时，这里是一些需要牢记的事项：

* 请记住，没有人说过你必须一次性将所有内容从伪代码转换为机器指令。是的，连续改进应该是连续的。一个完全合理的问题陈述可能既包括指令也包括伪代码。随着时间的推移，一个完全合理的问题问题陈述可能既包括指令也包括伪代码。随着时间的推移，你会不断发展适合于自己的技术，随着你逐渐变成一名越来越自信的程序员，你所需要的完善次数将会越来越少，而得到的结果则会越来越好。
* 不要害怕画图。当你试图处理一个复杂的循环或者任何需要处理许多环节的过程时，潦草地画在方格信笺上的铅笔素描指针、缓冲区等等。可以为你带来很大的帮助。
* 保存你的笔记，无论它有多么丑陋。编程过程中的记忆会变得陈旧。如果你编写了一个实用工具，并且使用了它 6 个月，在试图重新改进它之前，你可能需要对它的内部工作机制进行一下复习。将所有相关内容都存放到一个文件夹里，包括写入磁盘文件中的伪代码的打印结果。

过滤器在 Unix 工作中十分常见。

添加了错误检查的版本

```asm
; 可执行程序名：uppercaser2
; 版本：1.0
; 创建日期：2021年6月18日
; 最后修改日期：2021年6月18日
; 作者: wangjun
; 描述：一个为 Linux 编写的简单的汇编程序，使用 NASM 2.13.02
; 展示了简单的文本文件输入/输出(通过重定向)
; 为了实现从输入文件读入一块缓冲区，强制将小写字符转换为大写
; 将修改过得缓冲区写入到一个文件
; 
; 以这种方式来运行它:
; uppercaser2 > (output file) < (input file)
; 
; nasm -f elf -g -F DWARF uppercaser2.asm
; ld -m elf_i386 uppercaser2.o -o uppercaser2
;

SECTION .bss                ; 包含未初始化数据的段
    BUFFLEN equ 1024        ; 缓冲区的长度
    Buff: resb BUFFLEN      ; 缓冲区文本本身

SECTION .data                        ; 包含已经初始化数据的段
ReadError db "read error",10         ; 定义字符串，表示“表示数据读取错误”，10表示
ReadErrorLen equ $-ReadError         ; 表示字符串 ReadError 的长度 
WriteError db "write error",10       ; 定义字符串，表示“数据写入错误”
WriteErrorLen equ $-WriteError       ; 表示字符串 “WriteError” 的长度

SECTION .text               ; 包含代码的段

    global _start           ; 连接器需要这个来找到入口点

_start:
    nop

; 从标准输入读入满满一缓冲区文本
Read:
    mov eax,3               ; 指定 sys_read 调用
    mov ebx,0               ; 指定文件描述符0: 标准输入
    mov ecx,Buff            ; 传递要从中读入数据的缓冲区的地址
    mov edx,BUFFLEN         ; 传递一次循环中要读入的字节数
    int 80H                 ; 调用 sys_read 来填充缓冲区
    mov esi,eax             ; 复制 sys_read 的返回值并妥善保管
    cmp eax,0               ; 如果 eax=0, 则 sys_read 到了标准输入的结尾
    jl ReadErrorMsg         ; 如果小于(与 0 相比较)则跳转
    je Done                 ; 如果(与0相比较)相等则跳转

; 设置寄存器，用于处理缓冲区这个步骤

    mov ecx,esi             ; 将读入的字节数放入 ecx 寄存器中
    mov ebp,Buff            ; 将缓冲区的地址放入 ebp 寄存器中
    dec ebp                 ; 调整偏移地址的计数值
    
; 详细检查缓冲区，并将小写字符转换为大写字符
Scan:
    cmp byte [ebp+ecx],61H  ; 测试输入字符，将其与小写字符 'a' 相比较
    jb Next                 ; 如果 ASCII 码值比 'a' 的 ASCII 码值小，则不是小写字符
    
    cmp byte [ebp+ecx],7AH  ; 测试输入字符，将其与小写字符 'z' 相比较
    ja Next                 ; 如果 ASCII 码值比 'z' 的 ASCII 码值大，则不是小写字符

    ; 此时我们拥有了一个小写字符
    sub byte [ebp+ecx],20H  ; 与 20H 相减，得到大写字符

Next:
    dec ecx                 ; 递减字符计数器
    jnz Scan                ; 如果仍然有字符，则继续循环


Write:
    mov eax,4               ; 指定 sys_write 调用
    mov ebx,1               ; 指定文件描述符1: 标准输出
    mov ecx,Buff            ; 传递缓冲区的偏移地址
    mov edx,esi             ; 传递缓冲区数据的#个字节
    int 80H                 ; 进行 sys_write 内核调用
    cmp eax,0
    jl WriteErrorMsg
    jmp Read                ; 回去继续循环，加载另一满满的缓冲区数据

; 输出读取错误信息 
ReadErrorMsg:
    mov eax,4		        ; 指定 sys_write 系统调用
	mov ebx,1 		        ; 指定文件描述符1：标准输出
    mov ecx,ReadError       ; 传递 ReadError 的地址
    mov edx,ReadErrorLen    ; 传递 ReadError 的长度
    int 80H
    jmp Done

WriteErrorMsg:
    mov eax,4		        ; 指定 sys_write 系统调用
	mov ebx,1 		        ; 指定文件描述符1：标准输出
    mov ecx,WriteError      ; 传递 WriteError 的地址
    mov edx,WriteErrorLen   ; 传递 WriteError 的长度
    int 80H
    jmp Done
    
    
; 全部搞定

Done:
    mov eax,1               ; 退出 syscall 的代码
    mov ebx,0               ; 将零作为返回值返回
    int 80H                 ; 进行 sys_exit 内核调用
```

​			

# 第 9 章 位，标志，分支和表 轻松进入主流汇编编码

在 X86 指令集中，有一族指令能够让我们通过应用按位布尔逻辑运算来操作字节中的位。比如：AND, OR, XOR和 NOT。对单个字节或字进行移位的操作，以下就是经常用到的移位/循环移位指令：ROL，ROR，RCL，RCR，SHL和SHR。



### 9.1.1 位编号

最不重要的位也叫最低有效位，最重要的位也叫最高有效位。图 9-1 以 16 位字为例进行了展示。位编号的工作方式始终一样，不管处理的位有多少个：字节，字，双字或更长字。第 0 位通常在最右端，然后依次往左，位编号递增。

![截屏2021-06-19 上午11.00.41](https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.00.41.png)



当你数这些二进制位的时候，从最右边的那个位开始，并且从零开始编号。



### 9.1.2 逻辑操作

逻辑与操作符的工作原理如下：条件 1 与 条件 2，当且仅当二者同时为真时结果为真；如果二者之一为假，结果为假。

![截屏2021-06-19 上午11.06.38](https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.06.38.png)

在汇编术语中，与指令处理两个二进制位(bit)，根据这两个位的计算结果产生第 3 位，根据习惯，我们认为二进制位 1 的值为真，二进制位 0 的值为假。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.08.59.png" alt="截屏2021-06-19 上午11.08.59" style="zoom:80%;" />



### 9.1.3 与指令

x86 指令集中的 AND指令体现了这个概念。AND 指令对两个位数相同的操作数执行与逻辑运算，并且一般情况下，用计算结果替换目标操作数。(注意，目标操作数通常情况下是指最接近助记符的那个操作数。)例如：

```asm
and al,bl
```

AL 中的第 0 位与 BL 中的第 0 位相与，AL 中的第 1 位 与 BL 中的 第 1 位相与，依次类推。每个与操作产生一个结果位，当所有这 8 个与操作完成后，这些结果位被放到目标操作数里(这里为 AL)。这是机器指令中惯用的一种思路：对两个操作数执行某种操作，用产生的结果替换第一个操作数(目标操作数)，而不是第二个操作数。



### 9.1.4 位屏蔽

与指令的一个主要应用是把一个二进制位或者更多的二进制位从字节数据或者是字数据中分离出来。这里所说的分离，只不过是把所有不需要的二进制位都置为一个可靠的值: 0。

例如，我们想测试某个数值的第 4 位和第 5 位。可以用下图所示方式解决：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.23.36.png" alt="截屏2021-06-19 上午11.23.36" style="zoom:50%;" />

这样，我们就可以获得 AL 的第 4 位和第 5 位分别为 1 和 0。



### 9.1.5 或指令

两个操作数，有一个操作数为真，结果就为真。两个操作数都为 假，结果才为假。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.29.31.png" alt="截屏2021-06-19 上午11.29.31" style="zoom:50%;" />

由于或操作不适合做位屏蔽，因此比与运算用的少得多。



### 9.1.6 异或指令

这个逻辑操作是排他性的或，意思是：只有当这两个操作数的值不同(即 1 和 0 或者 0 和 1)时，结果才为 1.

![截屏2021-06-19 上午11.38.36](https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.38.36.png)

异或的一个不太明显的应用是：任何值与本身相异或，将产生结果 0.换句话说，如果把寄存器作为操作数，对其进行异或操作的话，这个寄存器将会被清零。

```asm
xor eax,eax    ;  清零 eax 寄存器
```

在过去，这种方式比通过使用 MOV 来加载立即数 0 到寄存器要快一些，尽管现在已经不再这样，但是它仍然是一个有必要知道的有趣的技巧。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8A%E5%8D%8811.39.12.png" alt="截屏2021-06-19 上午11.39.12" style="zoom:50%;" />



### 9.1.7 非指令

在所有逻辑指令中，最容易理解的就是非指令。非操作的真值表也比我们前面看到的要简单，因为非操作仅仅对一个操作数进行运算。该运算做的事情也非常简单: 非操作取出它的单操作数的每一位的状态，然后将其变化相反的状态。1 变成 0，0  变成 1。

| 位   | 操作符 | 结果位 |
| ---- | ------ | ------ |
| 0    | NOT    | 1      |
| 1    | NOT    | 0      |



### 9.1.8 段寄存器对逻辑操作没有反应

你不能直接访问 X86 的段寄存器，除非已经达到了可以对操作系统编程的水平。段寄存器属于操作系统，用户空间程序不能以任何方式修改它们。

但是，即使你已经开始在操作系统级别上编程了，段寄存器仍然具有很大的局限性。其中之一就是**不能进行按位逻辑运算**。如果企图这样做的话，汇编编译器会抛给你“非法使用段寄存器”的错误提示。如果需要对段寄存执行逻辑操作的话，你必须首先将该段寄存器的值拷贝到以下寄存器之一：EAX，EBX，ECX，EDX，EBP，ESI或者EDI；对通用寄存器执行逻辑运算然后再将通用寄存器中的计算结果拷回到段寄存器中。

通用寄存器被称为“通用的”是有原因的，段寄存器在任何方面都不是通用的。它们的内存地址是专有的，如果你必须修改段寄存器的值，一般的方法是将其挪到通用寄存器中去完成，然后再将修改后的值拷回所处理的段寄存器中。



## 9.2 移位操作

另一种操纵字节中的位的方式要更直接一些：将这些位往某个方向(左或右)移动。最简单的移位指令相当显而易见: SHL 将它的操作数左移，而 SHR 将它的操作数右移。

所有的移位指令都有相同的一般形式, 如 SHL 指令形式:

```
shl <寄存器/内存>,<count>
```

第一个操作数是移位操作的目标——也就是那个即将进行移位操作的数值。它可以是寄存器数据或内存数据，但是能是立即数。第二个操作数则指出了即将移动的位数。



### 9.2.1 根据什么进行移位操作

表示移动位数的 \<count\> 操作数有着独特的历史，在老式的 8086 和 8088 中，它可能是以下二者之一：立即数1 或者寄存器 CL。

而到了 x86，它的通用寄存器成为真正的“通用”之前，计数的工作成了 CX 寄存器的隐形议程。它通过循环，线性元素以及其他结构对移动的位数进行计数。尽管能够移动的最大位数可达 32 位，但是真正有意义的移动位数最多到 32 。

从 286 以及所有更新的 X86 CPU 开始，\<count\>操作数可以是从 1 到 255 之间的任意立即数。因为 Linux 需要至少运行在 386 上，所以当你在 Linux 下进行编程的时候，对于移位计数值的那些古老的限制已经不复存在了。



### 9.2.2 移位指令的工作原理

要想理解移位指令，需要把即将进行移位操作的数转换为二进制数，而不是十六进制或者十进制数。例如：

AX寄存器的内容为: 0B76FH，它对应的 二进制数为：1011011101101111

如果此时执行 SHL AX,1

AX 将会变成 0110111011011110，这个数的右边被插入了一个 0，整个数据都往左边移动了一位。注意，最左侧的二进制位已经被从这个数中移除到“空白宇宙”之中。



### 9.2.3 将位移入进位标志

从这个二进制数的左侧移出来的最后一位，被存放到名为进位标志的位临时存储段里，它一般缩写为“CF”。进位标志是在那聚集在一起形成EFlag 寄存器的信息位之一。

当使用移位指令时，请记住，许多不同的移位指令都使用进位标志(carry flag) ——不仅仅是移位指令。**如果想把一个二进制位移入进位标志，目的是想测试一下这个位，然后看一下它的值到底是什么，一定要在执行其他能够影响进位标志的指令之前进行，这些指令包括算术指令，所有的按位逻辑操作指令以及其他一些不同种类的指令，当然，还有所有的其他的移位指令。**

如果将移位移入进位标志，然后立即执行其他的移位指令，那么， 第一个移入的位将被从这个数中移除，彻底消失。



### 9.2.4 循环移位指令

如果希望一个二进制位的命运不是即将被丢弃到“空白宇宙”，需要使用循环移位指令：RCL，RCR，ROL，ROR。循环移位指令几乎和移位指令相同，但是有一个重要区别：**从操作数的一端移出的二进制位，将会重新出现在操作数的另一端。当你对一个操作数执行不止一位的循环移位操作时，这些位不断地在某一方向上进行匹配，从某一端被移除，然后立刻出现到另外一端。**当循环指令被执行时，这些位就这样在操作数中循环。

例如，下图展示了 ROL(循环左移)指令：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8B%E5%8D%889.18.07.png" alt="截屏2021-06-19 下午9.18.07" style="zoom: 67%;" />



ROR(循环右移)指令工作原理相同，只不过位的移动方向是从左往右。

操作数即将循环移动的位数可以是立即数，也可以是 CL 寄存器中的值。在 X86 指令集中，还有一对循环指令: RCR(带进位的循环右移指令)和RCL(带进位的循环左移指令)。这些操作跟 ROL 和 ROR 类似，但是有一点不同：从操作数的某一端移出的二进制位，会通过进位标志来重新进入该操作数。任意一个位通过 CF 进行循环的路径，都比通过 ROL 和 ROR 进行循环的路径长一位。如图 9-5：

如果对一个值循环移动超过 31 次，你将得到一个和开始循环的那个数一样的值。如果把一个数循环移动 32 位，就会得到一个和开始循环那个数一样的值。因此在保护模式下(以及在老式的 286 下)编程时，在指令执行之前，移位的数量被删减到 5 位。归根结底，5 位二进制数所能表示的最大值是32。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-19%20%E4%B8%8B%E5%8D%889.31.30.png" alt="截屏2021-06-19 下午9.31.30" style="zoom: 50%;" />



### 9.2.5 将已知值存入进位标志 CF

有两条操作标志寄存器的指令: CLC, STC

CLC：将标志位清零，STC：将标志位设置为1

使用 RCL 或 RCR 指令，可以将 CF 设置为特定值。



## 9.3 位操作

Linux 能够相当方便地在显示器上显示文本，但是想把某个寄存器中的值以十六进制的方式进行显示，Linux 就无能为力了。必须先把这个数转换为字符串的形式，然后再通过 INT 80H 调用 sys_write 内核服务来显示这个字符串。

下面的代码，颇像一个 Bless 十六进制编辑器的只读版本。当你从任意类型的文件中重定向它的输入时，它都会从该文件中一次性读入 16 个字节，并将其显示在一行里，形成由空格隔开的 16 进制值。

```asm
; 可执行文件名：hexdump1
; 版本：1.0
; 创建日期：2021年6月19日
; 作者：王俊
;    描述：Linux 下的一个简单的汇编程序，采用 NASM 2.13.02
;    演示了如何把二进制值转换为 16 进制字符串表示
;    本程序可作为供文件使用的一个非常简单的 16 进制转换工具
;    尽管没有 ASCII 等值列
; 通过以下方式执行本程序:
; hexdump1 < (input file)
;
; 通过以下命令生成本程序
; nasm -f elf -g -F DWARF hexdump1.asm -o hexdump1.o
; ld -m elf_i386 -o hexdump1 hexdump1.o
; 

SECTION .bss                    ; 包含未初始化数据的段
    BUFFLEN equ 16              ; 我们一次从这个文件读取 16 个字节
    Buff: resb BUFFLEN          ; 文本缓冲区本身

SECTION .data                   ; 包含已初始化数据段
    HexStr: db " 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",10  ; 保存 16 进制 字符串
    HEXLEN equ $-HexStr                                               ; 上述字符串长度

    Digits: db "0123456789ABCDEF"                                     ; 保存 16 进制中的 16 个字符


SECTION .text                   ; 包含代码段
 
global _start                   ; 连接器需要这个来找到入口点

_start:
    nop                         ; 这个无操作指令使得 GDB 感到非常高兴

; 从标准输入中读取满满一缓冲区的文本:
Read:
    mov eax,3                   ; 指定 sys_read 调用
    mov ebx,0                   ; 指定文件描述符 0：标准输入
    mov ecx,Buff                ; 传递将要从中读入数据的缓冲区的偏移地址
    mov edx,BUFFLEN             ; 传递一次需要读取的字节数
    int 80H                     ; 调用 sys_read 来填充缓冲区
    mov ebp,eax                 ; 存储从文件中读入的字节数以备后用
    cmp eax,0                   ; 如果 eax=0, 则 sys_read 已经到达标准输入结尾
    je Done                     ; 通过与零比较，相等则跳转


; 设置寄存器用于处理缓冲区步骤：
    mov esi,Buff                ; 将文件缓冲区的地址存入 esi
    mov edi,HexStr              ; 将线性字符串的地址存入 edi
    xor ecx,ecx                 ; 将线性字符串指针清零

; 通读检查缓冲区，将二进制数值转换为 16 进制位元(hex digits)
Scan:
    xor eax,eax                 ; 将寄存器 eax 清零

;  这里我们可以计算选对于 HexStr 的偏移地址，它等于 ecx 中的值乘以3
    mov edx,ecx                 ; 将字符计数器的值复制到 edx 中
    shl edx,1                   ; 通过左移位操作将指针的值乘以 2
    add edx,ecx


; 从缓冲区中获取一个字符，并将其同事存入 eax 和 ebx 中:
    mov al,byte [esi+ecx]           ; 从输入缓冲区中取出一个字节，送入al
    mov ebx,eax                     ; 为了求得第 2 个“半字节”，将该字节复制到bl中

; 查找低半字节字符并将其插入字符串
    and al,0FH                      ; 屏蔽除了低半字节之外的所有内容
    mov al,byte [Digits+eax]        ; 查找与该半字节相等的字符
    mov byte [HexStr+edx+2],al         ; 将最低有效位的字符位元写入线性字符串
    
; 查找高半字节字符并将其插入字符串:
    shr bl,4                        ; 将字符的最高位移入低四位
    mov bl, byte [Digits+ebx]       ; 查找与该半字节相等的字符
    mov byte [HexStr+edx+1],bl      ; 将最高有效位的字符位元写入线性字符串

; 将缓冲区指针指向下一个字符，看一下任务是否完成:

    inc ecx                         ; 增加线性字符串指针的值
    cmp ecx,ebp                         ; 与缓冲区的字符数进行比较
    jnae Scan                        ; 如果 ecx <= 缓冲区的字符数 ，转回去继续循环

; 将这行十六进制写入标准输入:

    mov eax,4                       ; 指定 sys_write 调用
    mov ebx,1                       ; 指定文件描述符1：标准输出
    mov ecx,HexStr                  ; 传递线性字符串的偏移地址
    mov edx,HEXLEN                  ; 传递线性字符串的长度(字节)
    int 80H                         ; 通过内核调用来显示字符串
    jmp Read                        ; 继续循环，再次加载文件缓冲区


; 胜利完成任务！
Done:
    mov eax,1                       ; 该行代码用于退出系统调用(syscall)
    mov ebx,0                       ; 将返回值设为 0 
    int 80H                         ; 进行内核调用
```



### 9.3.1 将一个字分解为 “半个字“

记住，Linux 以二进制的形式将值从文件中读入内容。十六进制是一种显示二进制的方式。显示一个8 位二进制数需要两个十六进制数，字节的低四位用一个十六进制数来表示，高四位用另一个十六进制数来表示。例如，二进制数 11100110 与十六进制数 E6 相等。把一个 8 位二进制数转换成两个 4 位二进制数时，必须每次转换 1 个，者意味着不得不把一个单字节拆分成 2 个 4 位大小的二进制量，我们通常将其称作半字节(nybble)。

我们将一个字节放入两个寄存器 EAX, EBX 中，因为把一个字节的高位和低位分开具有一定的破坏性，因为从本质上讲， 我们把不需要的那个半字节清零了。

要想从字节中分离出低 4 位，我们需要屏蔽掉不想要的那个半字节，可以通过与指令完成：

```asm
and al,0Fh
```



### 9.3.2 将高半字节移入低半字节

屏蔽掉 AL 中的高半字节将会破坏掉它的值，所以需要提前将其拷贝到 EBX 中，我们可以把 BL 中的高半字节变成低半字节，可以通过移位指令实现：

```asm
shr bl,4
```



### 9.3.3 使用查找表

在程序对的 .data 段中，定义了一个非常简单的查找表。Digits 表的定义如下：

Digits: db "0123456789ABCDEF"

每一个十六进制位元(digit)都在这个字符中占用一个位置，而该位元相对于字符串起始位置的偏移地址就是它所代表的值。换句话说，ASCII 字符 "0"，位于这个字符串的开始位置，它相对于这个字符串的起始位置的偏移地址是 0 个字节。我们可以通过一个内存引用来从 Digits 表中 “查找” 一个字符:

```
mov al,byte [Digits + eax]
```

 把 AL 中存放的偏移地址和 Gigits  查找表的地址 (通过 EAX)相加刚好能够把与 AL 中的值相等的 ASCII 值字符带给我们。如下图所示：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-20%20%E4%B8%8A%E5%8D%8811.29.15.png" alt="截屏2021-06-20 上午11.29.15" style="zoom:50%;" />



关于从查找表 Digits 中取出一个位元并将其放入 AL 中的 MOV 指令，可能有两件令人费解的事情：

* 在内存引用中，我们必须使用 EAX 而不是 AL，因为 AL 不能参与有效地址计算。不要忘记，AL 位于 EAX “内部”。
* 我们把 AL 中的半字节用与之相等的字符进行替换。该指令首先从查找表中取出与这个半字节相等的字符，然后再将这个相等的字符存回 AL。而之前 AL 中的那个半字节则不复存在了。



### 9.3.4 通过移位和相加来实现相乘

HexStr: db " 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",10

当 hexdump1 每次从输入文件中读入一个 16 字节的数据块时，它都将其转换成十六进制位元的 ASCII 字符格式，并插入 HexStr 中。从某种意义上讲，这是另外一种类型的表操作，只不过我们讲查找表操作替换为根据索引将一些值写入表中而已。

另外一种方式是将 HexStr 看成一个具有 16 个表项的表，每一个表项长度为 3 个字符，如图 9-7。在每一个表项中，第一个字符是空格，第二个和第三个字符是该 16 进制数本身。在 .data 段中，作为HexStr 的一部分，空格字符已经存在了。初始的"空" HexStr 字符串在所有的 16 进制位元的位置都有一个 0 字符，为了给 HexStr 填充真实的数据，以便显示每一行，我们必须通过汇编循环来扫描 HexStr，将低半字节字符和高半字节字符区分开来。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-20%20%E4%B8%8B%E5%8D%888.19.04.png" alt="截屏2021-06-20 下午8.19.04" style="zoom:67%;" />



每一次循环，都要 HexStr 索引乘于3，前面讲解了 MUL 指令，可以 X86 指令集中任意的无符号乘法。该指令同样具有一些局限性，尤其是它需要特定的寄存器来完成隐式操作的工作方式。

所幸的是，在汇编语言中，有一些其他的，速度更快的方法可实现乘法操作。使用 SHL(左移位)指令，可以实现一个数与 2 的幂次方相乘。例如，左移 1 位，相当于乘以 2，左移 2 为，相当于乘以 4。

如果要实现一个数与 3 相乘，那该怎么办呢？非常容易：先将这个数与2 相乘，然后再把得到的结果与被乘数的一份复制相加即可。例如：

```asm
mov edx,ecx      ; 将字符计数器复制到 edx 
shl edx,1        ; 通过左移位将指针与 2 相乘
add edx,ecx      ; 完成乘以 3 的操作
```



一旦理解了字符串表 HexStr 如何创建，就可以直截了当地把十六进制位元写入它。最低有效十六进制位元在 AL 中，最高有效十六进制位元在 BL 中。通过一个由 3 部分组成的内存地址来实现将这两个十六进制位元写入十六进制字符串(HexString)

```asm
mov byte [HexStr+edx+2],al     ; 将 LSB 字符位元(char digit)位写入字符串行
mov byte [HexStr+edx+1],bl     ; 将 MSB 字符位元(char digit)位写入字符串行
```



## 9.4 标志、测试和分支

没有条件转移指令，很多汇编操作将无法完成。



### 9.4.1 无条件转移

通常情况下，指令是一条一条地从低内存到高内存顺序执行的。条件转移指令改变了即将执行的下一条指令的地址。转移指令可以在内存中移动执行的位置。它可以使执行路径折回去构成一个循环(它还能将程序绑定到诸多逻辑关系中)。

有两种类型的转移指令：条件转移指令和无条件转移指令。

无条件转移指令是指肯定会发生的跳转：

```
jmp <label>
```

当这条指令执行时，执行顺序转到了位于标号\<label\>处的那条指令。



### 9.4.2 条件转移指令

当执行时，调制转移指令需要检验一些东西，通常是一个，有时两个，或者很少情况下，3个 EFlags 寄存器中的标志位。入股被检验的标志位或碰巧处于某一特定的状态，执行将会跳转到代码段中其他位置的某个标号处；否则，它执行失败，继续按顺序执行下一条指令。

意思是，条件跳转指令的执行只有两种结果，要么成功，要么失败。是否执行跳转取决于 CPU 内部的一小撮二进制位序列的当前值。

当从整体上讨论 EFlags 寄存器时，当某条指令的执行结果为 0 时，会有一个标志位的值被某些特定指令设置为 1:零标志(ZF)。DEC(递减)就是很好的例子，DEC 把它的操作数减 1，如果通过递减使得操作数变为 0，ZF 就被设置为 1。其中一个跳转指令，JZ(为零跳转)，会检测 ZF 的值，如果发现 ZF 为 1，则发生跳转操作，执行转到 ZF 助记符后面的标号所指定的位置。它也许是整个 X86 指令集中国最常见的跳转指令。当执行某个循环的时候，我们经常使用该指令来判断存放在寄存器中的计数值是否为零。当计数器寄存器中的值通过 DEC 指令变为零时，这个循环结束，程序从循环之后的语句开始执行。

```
mov word [RunningSum],0      ; 清零 [RunningSum]
mov ecx,13                   ; 我们将执行此操作 13 次 
WorkLoop:
	add word [RunningSum],3    ; 将 [RunningSum] 与 3 相加
	dec ecx                    ; 循环计数器减 1
	jz SomeWhereElse           ; 如果计数器的值为零，任务完成
	jmp WorkLoop
	
```

循环体非常简单，只有一条 ADD 指令，但是，它可以长达几十条甚至几百条指令。ecx 指定了循环次数，上述代码中，循环体共执行 13 次。

这种建立循环的方法非常差劲，我们需要在每次循环中真正查找的是什么时候(即零标志)没有被设置，以及那条完成该设置的指令。



### 9.4.3 条件 “缺席” 时进行跳转

每一个条件跳转指令都有一个 “密友”：当指定条件的值没有被设置为 1 时跳转。

JZ指令，如果零标志位(ZF)被设置为1，则  JZ 指令跳转到代码段中的一个新的位置。JZ 的“密友”是 JNZ(不为零跳转)。当 ZF=0 时，JNZ 跳转到某个标号处，ZF=1时，则跳转失败。

作为例子，我们把之前那个小循环改进一下(通过使用 JNZ 来改变循环逻辑)

```
mov word [RunningSum],0      ; 清零 [RunningSum]
mov ecx,13                   ; 我们将执行此操作 13 次 
WorkLoop:
	add word [RunningSum],3    ; 将 [RunningSum] 与 3 相加
	dec ecx                    ; 循环计数器减 1
	jnz WorkLoop               ; 如果计数器的值为零，任务完成
```

一旦计数器减小到0，我们就认为循环完成了。JNZ 执行失败，而退出循环。要点是，如果能够立即定位程序在 JNZ 指令之后将执行的下一个任务，我们根本不需要使用 JMP 指令。指令很自然地流入下一个需要执行的任务。程序将具有一个更为自然，不太费解的自顶向下流程，也就更容易理解和阅读了。



### 9.4.4 标志

进位标志(CF)，零标志(ZF)，方向标志(DF)，符号标志(SF)以及溢出标志(OF)，将会是新手用到的 99.9% 的标志位。

如前所述，当 ZF=1时，JZ 跳转，而当 ZF=0时，JNZ 跳转。大多数对于某个操作数执行某种操作的指令(例如 AND，OR，XOR，INC，DEC 以及所有的算术指令)都会根据操作结果设置 ZF 的值。另一方面，那些仅仅执行数据移动的指令(例如 MOV，XCHG，PUSH以及POP)并不会影响 ZF 或者任何其他标志。很明显，POPF 指令可通过将栈顶值弹出到标志寄存器中来影响它们。

一个奇怪的例外是 NOT 指令，它对操作数执行一个逻辑操作时，不设置任何标志——即使它会导致操作数的值变为零。在开始编写依赖于标志位的程序之前，最好查阅一下指令指南，以确保这些指令严格地正确遵守这些标志的规矩。



### 9.4.5 通过 CMP 进行比较操作

标志位的一个主要应用是控制循环。另外一个主要应用是对两个数进行比较。

CMP 指令的功能是进行两个数的比较，执行完设置相应的标志：

```asm
cmp <op1>,<op2>      ; 设置 OF, SF, ZF, AF, PF 以及 CF
```

`Result = <op1> - <op2>`CMP 是一个减法操作，但是却丢弃减法的结果，只影响标志位。第二个操作数被从第一个操作数中减掉。根据相减的结果，相关的标志位被设置成适当的值。

在 CMP 指令之后，可以根据若干个算术条件进行跳转。算术条件一般包括：等于，不等于，大于，小于，大于小于，小于等于。



### 9.4.6 转移指令的错综复杂之处

有一组令人费解的转移指令助记符，它们处理的数学关系一共分为 6 类：等于，不等于，大于，小于，大于小于，小于等于。由于每一条机器指令都有两个助记符，这使得情况有些复杂。例如 JLE(如果小于等于则跳转)和JNG(如果不大于则跳转)。这两个助记符是同义词，它们都产生相同的二进制操作码，具体选哪个，根据自己的习惯选择。

另一个复杂之处是针对有符号算术比较和无符号算术比较都有单独的指令系列。有符号数的最高位被认为是一个内置的，指示该值是否为负数的标志。如果该值为 1，那么这个数被认为是负数。如果该位的值为 0，那么这个数被认为是正数。

为了对有符号数算术理解得更深入一些，你需要知道的所有内容为：在有符号算术中，负数是合法的，而且一个值的最重要的位(即最高位)被当成符号位。(如果为 1，则认为该数为一个负数)。

另一方面，无符号算术运算并不识别负数，最高有效位只不过是哪个量所代表的二进制数中的一个普通位而已。



### 9.4.7 “大于” 与 “以上”

为了区分有符号转移指令和无符号转移指令，助记符使用两个不同的表达式来表示两个值之间的关系:

* 有符号数被视为大于或者小于。例如，为了测试一个有符号操作数是否大于另一个有符号操作数，需要在 CMP 指令后面使用 JG (如果大于则跳转)助记符。
* 无符号数被视为以上或者以下。例如，为了判断一个无符号数是否大于另一个(above)另外一个，需要在 CMP 指令后面使用 JA (如果以上则跳转)助记符。

下表总结了算术转移助记符以及对应的同义词。所有包含**以上或者以下的助记符都适用于无符号数**，而所有包含**大于或者小于的助记符则适用于有符号数**。

表9-6 转移指令助记符及其同义词

| 助记符 |                        | 同义词 |                            |
| ------ | ---------------------- | ------ | -------------------------- |
| JA     | 如果以上则跳转         | JNBE   | 如果不以下或者等于，则跳转 |
| JAE    | 如果以上或者等于则跳转 | JNB    | 如果不以下则跳转           |
| JB     | 如果以下则跳转         | JNAE   | 如果不以上或者等于，则跳转 |
| JBE    | 如果以下或者等于则跳转 | JNA    | 如果不以上则跳转           |
| JE     | 如果相等则跳转         | JZ     | 如果结果为零则跳转         |
| JNE    | 如果不相等则跳转       | JNZ    | 如果结果不为零则跳转       |
| JG     | 如果大于则跳转         | JNLE   | 如果不小于等于则跳转       |
| JGE    | 如果大于等于则跳转     | JNL    | 如果不小于则跳转           |
| JL     | 如果小于则跳转         | JNGE   | 如果不大于等于，则跳转     |
| JLE    | 如果小于等于则跳转     | JNG    | 如果不大于则跳转           |



表 9-7 根据逻辑条件和它们在有符号数和无符号数中的使用方法，将助记符进行了分类，还列出了每一条转移指令测试的标志位。注意，为了执行跳转操作，某些转移指令可能需要测试两个可能的标志之一，而有些则需要测试两个标志位。

表 9-7 CMP 指令执行后的有用算术测试

| 条件         | 操作符 | 无符号值 | 跳转条件       | 有符号数 | 跳转条件         |
| ------------ | ------ | -------- | -------------- | -------- | ---------------- |
| 等于         | =      | JE       | ZF=1           | JE       | ZF=1             |
| 不等于       | <>     | JNE      | ZF=0           | JNE      | ZF=0             |
| 大于         | >      | JA       | CF=0 并且 ZF=0 | JG       | ZF=0 或者 SF=OF  |
| 小于         | <      | JB       | CF=1           | JL       | SF<>OF           |
| 大于等于     | >=     | JAE      | CF=0           | JGE      | SF=OF            |
| 不小于       |        | JNB      | CF=0           | JNL      | SF=OF            |
| 小于或者等于 | <=     | JBE      | CF=1 或者 ZF=1 | JLE      | ZF=1 或者 SF<>OF |
| 不大于       |        | JNA      | CF=1 或者 ZF=1 | JNG      | ZF=1 或者 SF<>OF |

至于理解这些指令具体如何检验标志，可以等到我们已经具备了一些编程经验之后来完成。



### 9.4.8 使用 TEST 指令查找位 1

X86 指令系列意识到，汇编语言经常用到位检测操作，于是它提供了与 CMP 指令具有相同功能的指令：TEST。TEST 对两个操作数执行与逻辑操作，然后根据执行结果设置相应的标志位，但是不修改目标操作数。

```
test <操作数>,<位掩码>
```

例如，如果想判定 AX 的第 3 位是否为 1，可以使用如下指令:

```
test ax,08H    ; 用二进制表示第 3 位的值为 00001000B ,或 08H
```

操作完成后，目标操作数 AX 中的值并没有改变，但是二进制模式 00001000 和 AX 却的的确确按照逻辑与真值表的规则执行了本操作。如果 AX 的第 3 位值为 1，则零标志被设置成 0，如果 AX 的第 3 位值为1，则零标志被设置为1。为什么呢，如果把(位掩码中的)1 和 (AX 中的) 0 相与，将得到 0。如果所有的 8 个按位与操作结果都为 0，结果就是 0，零标志就会变为1，用以值示结果为零。

只能查找值为 1 的二进制位，如果需要查找值为 0 的二进制位，必须先通过非指令把每一位转换成相反的状态，然后就可以通过测试某个位是否为 1 来判断它是否为零。

**最后，TEST 不能一次可靠地测试两个或多个二进制位的值是否为 1。TEST 不检查位模式是否存在；它只检查一个单独的二进制位是否存在。**



### 9.4.9 使用 BT 指令查找位0

在 386 及较新的处理器中都有另外一条指令，它既能测试位 0，也能测试位 1。BT(位测试)执行的任务非常简单：它将指定的位从第一个操作数中拷贝到进位标志(CF) 中。

```
bt <value containing bit>, <bit number>
```

一旦执行了 BT 指令之后，我们应该立即检验 CF 中的值，根据它来进行分支运算。

```
bt eax,4   ; 检验 AX 中的第 4 位
jnc quit   ; 如果第 4 位=0，任务完成
```

上面所显示的字面常数所处理的编号(编号从 0 开始)，而非该二进制位的数值。

BT 指令的运算过程相当慢，在循环次数很大的循环内部，不宜使用该指令。快老掉牙的 TEST 指令则要快很多，但是 TEST只能检测二进制 1。



## 9.5 保护模式下内存寻址详解

386 CPU 下的保护模式引入了一个通用内存寻址模式，在该架构中，所有的通用寄存器都可以平等地参与寻址操作。如下图所示，该图也许是整本书中唯一一个最重要的图解了。内存寻址是汇编语言最关键的工作，如果对它不理解，其他工作根本无从谈起。

* 基址寄存器和索引寄存器可以是任意的 32 位通用寄存器，包括 ESP。
* 偏移地址可以是任意的 32 位常数。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-21 下午8.58.53.png" alt="截屏2021-06-21 下午8.58.53" style="zoom:67%;" />



* 缩放比例(scale) 必须是 1，2，4，8之中的一个。
* 在执行加法之前，索引寄存器与缩放比例(scale)相乘。
* 所有的元素都是可选的，而且几乎可以采用任意组合。
* 16 位 和 8 位寄存器可能不被用于内存寻址。

表 9-8 保护模式下的内存寻址方式

| 方式                                  | 举例                | 描述                                     |
| ------------------------------------- | ------------------- | ---------------------------------------- |
| [base]                                | [edx]               | 只有基址                                 |
| [displacement]                        | [0F3H]              | 位移量，或者是字面常数，或者是有符号地址 |
| [base+displacement]                   | [ecx + 033H]        | 基址 + 位移量                            |
| [base +index ]                        | [eax + ecx]         | 基址 + 索引                              |
| [index * scale]                       | [ebx * 4]           | Index * 缩放比例                         |
| [index * scale + displacement]        | [ebx * 8 + 65]      | 索引 * 缩放比例 + 位移量                 |
| [base + index * scall]                | [esp + edi * 2]     | 基址 + 索引 * 缩放比例                   |
| [base + index * scall + displacement] | [esp + ebp * 4 + 9] | 基址 + 索引 * 缩放比例 + 位移量          |



### 9.5.1 有效地址计算

上表中，除了前两行之外，其他均涉及一些对括号里的两个或多个表示地址的术语的数学计算。这种数学计算叫做有效地址计算，计算的结果叫做有效地址。其中术语"有效地址"指的是最终被用来读取或者写入的内存地址，不管它以何种方式表示。当指令被执行时，有效地址计算就由该指令来完成。

在基址寻址方式中，有效地址是简单的 32 位值，存放在括号里的通用寄存器中。不涉及任何计算，在源代码中看不到任何文字地址或者符号地址。所以，尽管该指令采用括号之间的寄存器名进行编码，但是当代码执行时，即将发给内存系统的是存放在该寄存器内部的地址。

唯一一种有效地址即为指令助记符显示内容的情况就是括号里的字面地址。这种情况几乎不会发生，因为在汇编时，精确地知道一个 32 位数字地址这种情况极不可能发生。

大多数情况会涉及一些算术运算，例如，在基址+索引这种寻址方式中，点那个指令被执行时，括号里的两个通用寄存器的值被相加以产生有效地址。



### 9.5.2 位移量

在合法地址的若干组成部分中，位移量这个术语实际上最难理解。位移量可以是一个字面地址，当位移量独立出来时，它实际上通常以符号地址的形式出现。例如:

```
mov eax,[HexStr]
```

这里，放入 EAX 中的就是当程序被加载到内存里时赋给变量 HexStr 的地址。像所有地址一样，它就是一个数字，但是是在运行时而不是汇编时确定的，就像字面常量一样。

当 NASM 在一个内存引用中看到两个(或多个)常数值时，它会在编译时将其组合成一个位移量。这里是实现过程：

```
mov eax,[HexStr + 3]
```

位移量的关键特性是它并不位于寄存器中。



### 9.5.3 基址+位移量寻址方式

一个很好的例子是：

```asm
mov byte [HexStr+edx+2],al 
```

这是一个非常好的例子，里面包含两个位移量，NASM 会将其合并成一个。名为 HexStr 的变量决定了一个数字(HexStr 的 32 位地址)，它很容易与字面常量 2 相加，所以，实际上只有一个基址(EDX)和一个位移量。



### 9.5.4 基址+索引寻址方式

也许最常使用的一种简单寻址方式就是：基址+索引寻址，通常将括号里的两个通用寄存器的值相加来计算有效地址，例如：

```asm
sub byte [ebx+ecx],20H
```

缓冲区的地址已经提前放入 EBP 中，ECX 中的数据是任意给定循环中相对于被处理的字符缓冲区的起始位置的位移。把缓冲区地址与位移量相加，将产生 SUB 指令处理的字符的有效地址。

想想为什么不用基址+位移量寻址方式呢？下面的指令也合法呀:

```
sub byte [Buff + ecx],20H
```

在之前的程序中，在开始循环之前，我们必须把缓冲区的地址减 1。但是且慢，我们能不能让 NASM 稍作调整，通过与另外一个位移量-1相加来实现呢？实际上可以，它同样会起作用。uppercaser2 程序的核心循环部分如下所示:

```asm
    mov ecx,esi             ; 将读入的字节数放入 ecx 寄存器中
    mov ebp,Buff            ; 将缓冲区的地址放入 ebp 寄存器中
;    dec ebp                 ; 调整偏移地址的计数值
    
; 详细检查缓冲区，并将小写字符转换为大写字符
Scan:
    cmp byte [Buff-1+ecx],61H  ; 测试输入字符，将其与小写字符 'a' 相比较
    jb Next                 ; 如果 ASCII 码值比 'a' 的 ASCII 码值小，则不是小写字符
    
    cmp byte [Buff-1+ecx],7AH  ; 测试输入字符，将其与小写字符 'z' 相比较
    ja Next                 ; 如果 ASCII 码值比 'z' 的 ASCII 码值大，则不是小写字符

    ; 此时我们拥有了一个小写字符
    sub byte [Buff-1+ecx],20H  ; 与 20H 相减，得到大写字符

Next:
    dec ecx                 ; 递减字符计数器
    jnz Scan                ; 如果仍然有字符，则继续循环
```



当程序被加载时，NASM 完成数学运算，有效地址表达式内的缓冲区地址被递减 1。这实际上是对一种对这一特定循环的正确编码方式。

在大多数情况下，位移量包含一个地址，而基址是一个包含了某一数据项相对于那个地址的偏移量地址的寄存器。



### 9.5.5 索引*缩放比例+位移量寻址方式

如果需要逐字节地扫描内存中的缓冲区，一般情况下需要使用基址+索引寻址方式，但是如果需要访问一个位于缓冲区中或者表中的数据项，而该数据项不是一个单字节，而是一个字，或者双字，该怎么办？这就需要更强大的内存寻址机制。

在本书中，数组这个词是我强调缓冲区或表时经常使用的术语，有些其他作者把表叫做数组，尤其是当讨论的上下文是高级语言时，但是所有以下 3 个条款都对同一定义适用: 内存中的一个连续数据项，数据项的大小相同，数据项的内部定义相同。

例如，下列是仅仅包含大小为一个字节的数值的表：

Digits: db "0123456789ABCDEF"

这是内存中某一行里的 16 个单字节字符，可以采用基址+位移量寻址的方式通过如下方式访问 Digits 表中的 "C" 字符: 

```asm
mov ecx,12
mov edx,[Digits+ecx]
```

如果表里包含 32 位的值呢？这样的表很容易定义：

```ams
Sums: dd "15,12,6,0,21,14,4,0,0,19"
```

修饰符 DD 告诉 NASM ，在表 Sums 中，每一个数据项都是 32 位双字。字面常量向表中每一个元素插入了一个数字。Sums 中的第一个元素(这里是 15)的地址就是整个表的地址，它包含在变量 Sums 中。

那么，第二个元素 12 的地址是多少呢？表中的第二个数据项相对于该表起始位置的 4 字节偏移处，不能通过简单地加 1 来索引第二项数据元素。

“缩放比例“这个概念就闪亮登场了。地址可能会包含缩放比例这一术语，它是一个乘数，可以是2，4，8中的任意一个字面常量。索引和缩放比例相乘的结果再与位移量相加，产生有效地址。这就是索引 * 缩放比例 + 位移量寻址方式。

一般情况下，缩放比例这个术语是表中某一单个元素的大小。如果表包含 2 个字节数值，那么缩放比例就是 2。如果表中包含 4 个字节双字数值，那么缩放比例就是 4.如果表中包含 6 字节 4 字数值，那么缩放比例就是8。

例如，下图的寻址方式为：[DDTable + ECX*4]。DDTable 是一个双字(32 位)表，DDTable 的地址是位移量。ECX 寄存器是索引值，在本例中，它的值为 2，代表你想访问的表元素的编号。因为它是一个 4 字节双字表，所以缩放比例为 4。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-21 下午11.52.26.png" alt="截屏2021-06-21 下午11.52.26" style="zoom: 50%;" />

因为每个表元素的长度都为 4，所以第二个元素相对于表的起始位置的偏移地址为 8。该元素的有效地址通过首先将索引和缩放比例相乘，然后将结果与 DDTable 的地址相加计算而来。



### 9.5.6 其他寻址方式

任何包含缩放比例的寻址方式都是按照这种方式都是按照这种方式工作的。不同之处在于采用什么其他术语来计算有效地址。基址+索引*缩放比例这种寻址方式将一个缩放后的索引与寄存器中的基址值相加，而不是与一个位移量相加：

```asm
mov ecx,2            	 ; 索引存放在 ecx 里
mov ebp,DDTable        ; 表地址存放在 ebp 里
mov edx,[ebp+ecx*4]
```

你一般不会经常处理向 DDTable 这样的预定义变量地址。有时，表的地址来自其他地方，更多情况是一张内存里的包含很多子表的二维表，每张表里包含一些元素。这样的表可通过两步来访问：第一步，推导出内部表在外部表中的地址：第二步，推导出所需元素在内部表中的地址。

DOS 下的25行 * 80字符的文本显存缓冲区就是一张二维表。25行中的每一行都是由 80 个字符组成的表，每一个字符都是由 2 个字节构成的字。(一个字节是 ASCII，另一个字节则指出诸如颜色，下划线之类的属性)因此，这个缓冲区从整体上来看就是一个由 25 张更小的表构成的总表，每一张小表包含 80 个两字节数值。

那种类型的视频访问系统早就随着 DOS 一起消亡了；Linux 不允许直接访问 PC 显存。

通过按比例缩放，我们可以非常容易地处理包含 2 字节，4 字节，8 字节元素的表。但是如果你的表里包含的是 3 字节元素呢？或者 5 字节元素呢？或者 17 字节元素呢？在这种情况下，为了瞄准某一特定的元素，不得不做一些额外的计算。有效地址本身不能完成所有的任务。

在程序 hexdump1.asm 中，每个元素的长度为 3 个字符，所以缩放操作不能在指令内部执行，必须单独处理。

这并不困难。缩放 hexdump1 程序中的 HexStr 表中的 3 字节元素可以通过如下指令完成：

```asm
mov edx,ecx    ;将字符计数器拷贝到 edx
shl edx,1      ; 通过左移位来实现将计数器*2
add edx,ecx    ; 完成与 3 相乘
```

缩放 5 倍可以通过将索引值左移 2 位，进而实现与 4 相乘，之后再与索引值的另一份拷贝相加，进而完成与 5 相加。

概括地讲，为了将一个索引值缩放 X 倍：

1. 找出比 X 小的那个最大的 2 的幂数
2. 将索引值左移那个 2 的幂数位
3. 不只一次地将原始索引值的一份拷贝与移位后的那个拷贝相加，直到完成与 X 相乘。

例如，如果 X 为11，则缩放计算可以通过如下所示代码完成：

```
mov edx,ecx        ; 将索引拷贝到 edx 中
shl edx,3          ; 通过左移 3 位实现与 8 相乘
add edx,ecx        ; 执行三次与索引拷贝值相加的第一次加法
add edx,ecx        ; 执行三次与索引拷贝值相加的第二次加法
add edx,ecx        ; 执行三次与索引拷贝值相加的第三次加法
```

这种方法对于缩放比例相对较小的情况非常有效；一旦超过 20，将会用到很多条加法指令。从这一点来讲，解决方案不是为了计算缩放比例，而是为了查找专门为某一给定缩放比例而定义的比例值。例如，假设表中每个元素长度都为 25 个字节。你可以定义一张 25 的倍数的表:

ScaleValues: dd 0,25,50,75,100,125,150,175,200,225,250,275,300

对于每一项大小为 25 个字节的表而言，为了得到索引值为 6 的表项的地址，我们可以通过如下方式在表中查找6 * 25的结果。

```
mov ecx,6
mov eax,[ScaleValues + ecx*4]
```

现在，EAX 中包含了第 6 个元素的第一个字节的有效地址。



### 9.5.7 LEA：最机密的数学机器

在 X86 体系结构中，有一条最古老但是从某个方面来讲又最神秘的指令：LEA，加载有效内存。从表面上看，它所做的事情非常简单：根据括号里给出的源操作数来计算有效地址，然后把该地址加载到它的目标操作数所指定的任意的 32 位通用寄存器中。

看看上面一段代码，如果想把索引值为 6 的那个数据项的有效地址放入寄存器中该怎么操作？

```asm
lea ebx,[ScaleValues + ecx*4]
```

这里发生的事情：CPU 根据方括号中给定的内容计算有效地址，然后将那个地址加载到 EBX 寄存器中。



LEA 还有一个特殊的作用：进行无需移位，相加或者迟钝的 MUL 操作的快速数学运算。例如，以下代码实现与 3 相乘运算：

```ams
mov edx,ecx     ; 把字符计数器拷贝到 edx 中
shl edx,1       ; 通过左移位实现将指针与 2 相乘
add edx,ecx     ; 完成与 3 相乘
```

使用 LEA 指令可以实现相同的功能:

```asm
mov edx,ecx     ; 把字符计数器拷贝到 edx 中
lea edx,[edx*2 + edx]   ； 将edx 乘以 3
```

EDX 中的值也许实际上并不是某些东西的合法地址，但是这一事实并不重要。**LEA 并不设法引用它计算出来的地址。它只是根据括号里的内容完成数学运算，然后将结果存入目标操作数。目标完成，不触及内存，也不影响标志位。**

当然，你被限制在那些能够对有效地址进行的数学运算里，但是稍稍超过这个范围一点点，那就是当放入一个常数的时候，你也可以实现将任意的通用寄存器与2，3，4，5，8，9相乘！**它不是任意的数学运算，但是在汇编中，经常会遇到有与2，3，4，5，6，8和9相乘的情况**，你可以把 LEA 和 移位指令以及加法指令组合在一起，完成更为复杂的数学运算。两个连续的 LEA 指令可以实现把一个值与 10 相乘，实际上这一点很有用：

```asm
lea ebx,[ebx*2]          ; 把 ebx 与 2 相乘
lea ebx,[ebx*4+ebx]      ; 把 ebx 与 5 相乘，以求取与 10 相乘的最终结果
```

**LEA 指令在一个机器周期里完成它的工作，X86 数学运算中没有比它更快的了！**



### 9.5.8 16 位寄存器的负担

在保护模式下，对 32 位寄存器进行分级管理，这存在着一定的负面效果：使用 16 位通用寄存器 AX，BX，CX，DX，SP，BP，SI和DI将会使运算速度减慢。由于 32 位寄存器规则，使用 16 位寄存器被认为是一种特例，它会增加汇编语言产生的操作码的尺寸，减慢程序代码的向下执行速度。例如：AX 寄存器仍然位于 CPU 的硅芯片内部(作为更大的 EAX 寄存器的一部分)，简单地把数据放入其中并不会使速度减慢。但是，只要将 AX 作为某个操作码的操作数，以这种方式放入 AX 中，执行速度肯定会减慢。以下的语法将产生一个执行速度比较慢的操作码:

```
mov ax,542
```

 我们可以采用如下的操作码完成同样的事情，而且 NASM  产生的操作码执行速度会更快:

```asm
mov eax,542
```

在代码中三三两两地使用 16 位寄存器并不会使这个程序变慢，我们需要避免的是在一个将会被执行几千次甚至成千上万次的紧密循环中使用 16 位寄存器。

但某些特殊情况下，不得不使用使用 16 位寄存器，例如：

```asm
mov byte [ebx],al
```

在现代的 CPU 中，单独的操作码的代码性能已经淹没在 CPU 的一些机制(如高速缓存，超线程，预取指令技术等)的性能之中。

只要简单记住：**凡事能使用 32 位寄存器的地方就使用 32 位寄存器。**



## 9.6 字符表转换

有一种类型的查表操作，它(或者曾经)非常普遍以至于 Intel 的工程师专门为它烤制一条单独的指令到 X86 体系结构中。这种普遍的表查找操作就是我们在第 8 章结尾的潜台词：字符转换。在 20 世纪 80 年代早期，我需要以各种方式转换字符序列，其中最简单的一种是把所有的字母从小写转换为大写。

仅仅把小写字母转换为大写字母很简单，因为它们的 ASCII 码值相差 20H(32)，通过简单的将小写字母减去 20H 来转换为大写字母。这样做是可靠的，但是在某种意义上来说是一种特例。如果需要把所有的 “竖线”(ASCII 124)字符转换为感叹号，该怎么做呢？(我必须这样做，因为有一种类型的傻瓜主机根本不“接纳”竖线)。可以为每一种必须处理的情况单独编写特定的代码，或者，也可以使用转换表。



### 9.6.1 转换表

转换表是一种特殊类型的表，它按照如下方式工作：建立一张数值表，并为每一个必须被转换的可能值创建一个表项。采用数字(或被当成数字的字符)作为该值在这张表中的索引。索引指定的表中位置是一个用于替换被用作索引的原值的数字。**简言之，原值被当作该值在查找表中的索引，然后根据索引在表中找到一个新的值在替换原来的值，这样就实现了将原来的值转换为一个新值。**

一个字节包含足够的位来表示 256 个不同的值，所以我们如果想要转换字节大小的值，需要一张具有 256 个条目的表。从技术上讲，ASCII 字符序列只使用前 128 个字符，”高“ 128 位通常被分配给特殊字符，如非英语字母，#字符，数学符号等。**字符转换的一个最常见的用途就是把值大于 128 的字符转换成某些小于 128 的字符，以避免在那些不能处理扩展 ASCII 值的老式系统中发生混乱。**

```asm
UpCase:
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h
db 20h,21h,22h,23h,24h,25h,26h,27h,28h,29h,2Ah,2Bh,2Ch,2Dh,2Eh,2Fh
db 30h,31h,32h,33h,34h,35h,36h,37h,38h,39h,3Ah,3Bh,3Ch,3Dh,3Eh,3Fh
db 40h,41h,42h,43h,44h,45h,46h,47h,48h,49h,4Ah,4Bh,4Ch,4Dh,4Eh,4Fh
db 50h,51h,52h,53h,54h,55h,56h,57h,58h,59h,5Ah,5Bh,5Ch,5Dh,5Eh,5Fh
db 60h,41h,42h,43h,44h,45h,46h,47h,48h,49h,4Ah,4Bh,4Ch,4Dh,4Eh,4Fh
db 50h,51h,52h,53h,54h,55h,56h,57h,58h,59h,5Ah,7Bh,7Ch,7Dh,7Eh,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
```

表 UpCase 被定义成 16 ，每一行由 16 个单独的十六进制值组成。表被分成 16 行仅仅是为了屏幕上或者打印页上的可读性，并不影响 NASM 在输出中产生的二进制表。一旦以二进制表形式表示，它是位于一行中的 256 个 8位值。

任何转换表都可被看作表达了一种或多种管理转换过程中发生的各种事情的“规则”。上面的UpCase 表表达了以下转换规则：

* 所有的小写 ASCII 字符被转换成大写。
* 所有小于 127 的非小写字母可打印 ASCII 字符被转换成它们自己。(严格来将，它们并没有被丢下不管，而是转换成了同样的字符)
* 所有 ASCII 码值位于 127～255 之间的 “高位”字符都被转换成 ASCII 空格字符(32 或者 20h)。
* 除了9和10之外，所有的不可打印 ASCII 字符(总的来说，值在 0~31之间，还有 127) 被翻译成空格。
* 字符值 9 和 10(tab 和 EOL) 被转换成它们本身。



### 9.6.2 用 MOV 或者 XLAT 进行转换

那么如何使用这张 UpCase 表呢？很简单：

1. 将即将被转换的字符加载到 AL 中
2. 通过使用 AL 作为基址，UpCase 作为位移量，创建一个内存引用，然后通过 MOV 指令将该内存引用处的字节存储到 AL 中，替换掉那个作为基址使用的原值。

MOV 指令如下：

```
mov al,byte [UpCase+al]
```

但是有一个问题：**NASM 不会允许这么做。AL 寄存器不能参与有效地址运算操作，所有的其他 8 位寄存器也不能参与，接下来进一步研究 XLAT 指令。**

XLAT 指令是被硬编码的，用于以特定的方式使用特定的寄存器。它的两个操作数是隐式的：

* 转换表的地址必须在 EBX 中
* 被转换的字符必须在 AL 中。
* 转换后的字符会被返回 AL，替代 AL 中的原始字符。

通过以上方式设置好寄存器后，XLAT 指令就可以独自使用了：

```
xlat
```

**XLAT被限制在 8 位量内**

**这里我诚实地交代，XLAT 再也不能像以前那样处于绝对获胜的地位了。在 32 位保护模式下，同样的事情也可以采用如下指令完成:**

```
mov al,[UpCase+eax]
```

这里有一个陷阱：你必须清除 EAX 高 24 位的所有剩余值，否则你很可能意外地访问远远超过转换表的边界的索引。因此，在加载即将被转换的值到 AL 中之前，一定要通过一条简单的 XOR EAX,EAX 指令将 EAX 清零。

事实上，在给定了使用使用 AL 和 EBX 的要求下，XLAT 指令只是一副淡水彩画，但是，我一直试图在这里介绍的，是一个通过表来实现字符转换的更大主题。

下列程序和程序 uppercase2 的功能完全相同：它强制把一个输入文件的所有小写字符转换为大写，然后再将其写入一个输出文件。我没有将其叫做 "uppercase3"，因为它是一个通用的字符转换程序。在这个特定程序里，它把所有的小写字符转换成大写，但是这只是 UpCase 表所表示的规则之一。修改这张表即可修改转换规则。你可以把任意一个值转换成 256 个值中的任意一个，甚至可以批量转换。

```asm
; 可执行程序名 XLAT1
; 版本：1.0
; 创建日期：22/6/2021
; 最后修改日期：22/6/2021
; 作者: wangjun
; 描述：用NASM 2.13.02 实现的一个运行在 Linux 下的简单汇编程序
; 示范了如何使用 XLAT 指令来修改文本流
; 通过以下方式执行本程序:
; xlat1 < (input file)
;
; 通过以下命令生成本程序
; nasm -f elf -g -F DWARF xlat1.asm -o xlat1.o
; ld -m elf_i386 -o xlat1  xlat1.o
;

SECTION .data                   ; 包含已初始化数据的段
    StatMsg: db "Processing...",10
    StatLen: equ $-StatMsg
    DoneMsg: db "...done!",10
    DoneLen: equ $-DoneMsg


; 下面的转换表把所有的小写字母转换为大写。
; 它还把所有的不可打印字符转换为空格。
; 住了 LF 和 HT 之外

UpCase:
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h
db 20h,21h,22h,23h,24h,25h,26h,27h,28h,29h,2Ah,2Bh,2Ch,2Dh,2Eh,2Fh
db 30h,31h,32h,33h,34h,35h,36h,37h,38h,39h,3Ah,3Bh,3Ch,3Dh,3Eh,3Fh
db 40h,41h,42h,43h,44h,45h,46h,47h,48h,49h,4Ah,4Bh,4Ch,4Dh,4Eh,4Fh
db 50h,51h,52h,53h,54h,55h,56h,57h,58h,59h,5Ah,5Bh,5Ch,5Dh,5Eh,5Fh
db 60h,41h,42h,43h,44h,45h,46h,47h,48h,49h,4Ah,4Bh,4Ch,4Dh,4Eh,4Fh
db 50h,51h,52h,53h,54h,55h,56h,57h,58h,59h,5Ah,7Bh,7Ch,7Dh,7Eh,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h

; 下面的转换表 “致力于”将所有的可打印字符转换成它们本身
; 除了 LF 和 HT 之外，将所有的不可打印字符转换成空格
; 你可以修改它，使之能够把你想转换的任意字符转换成任意你想要的结果

Custom:
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h,20h
db 20h,21h,22h,23h,24h,25h,26h,27h,28h,29h,2Ah,2Bh,2Ch,2Dh,2Eh,2Fh
db 30h,31h,32h,33h,34h,35h,36h,37h,38h,39h,3Ah,3Bh,3Ch,3Dh,3Eh,3Fh
db 40h,41h,42h,43h,44h,45h,46h,47h,48h,49h,4Ah,4Bh,4Ch,4Dh,4Eh,4Fh
db 50h,51h,52h,53h,54h,55h,56h,57h,58h,59h,5Ah,5Bh,5Ch,5Dh,5Eh,5Fh
db 60h,61h,62h,63h,64h,65h,66h,67h,68h,69h,6Ah,6Bh,6Ch,6Dh,6Eh,6Fh
db 70h,71h,72h,73h,74h,75h,76h,77h,78h,79h,7Ah,7Bh,7Ch,7Dh,7Eh,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h
db 20h,20h,20h,20h,20h,20h,20h,20h,20h,09h,0Ah,20h,20h,20h,20h,20h

SECTION .bss                    ; 包含未初始化数据的段
    READLEN equ 1024            ; 缓冲区的长度
    ReadBuffer: resb READLEN    ; 文本缓冲区本身

SECTION .text                   ; 包含代码的段

global _start                   ; 连接程序需要利用它找到入口点

_start:
    nop

; 通过标准错误 stderr 显示错误信息：“我正在工作....”
    mov eax,4                   ; 指定 sys_write 调用
    mov ebx,2                   ; 指定文件描述符2：标准错误
    mov ecx,StatMsg             ; 传递该信息的偏移地址
    mov edx,StatLen             ; 传递该信息的长度
    int 80H                     ; 进行内核调用

;从标准输入读入满满一缓冲区文本
Read:
    mov eax,3                   ; 指定 sys_read 调用
    mov ebx,0                   ; 指定文件描述符0：标准输入
    mov ecx,ReadBuffer          ; 传递需要读取的缓冲区的偏移地址
    mov edx,READLEN             ; 传递一次运行需要读入的字节数
    int 80H                     ; 进行内核调用
    mov ebp,eax                 ; 复制 sys_read 的返回值，并妥善保管
    cmp eax,0                   ; 如果 eax=0，则 sys_read 到达了文件结尾
    je Done                     ; 如果相等则跳转(通过与0比较)

; 为下面的转换步骤设置寄存器
    mov ebx,UpCase              ; 将表的偏移地址放入 ebx 中
    mov edx,ReadBuffer          ; 将缓冲区的偏移地址存入 edx 
    mov ecx,ebp                 ; 将缓冲区中的字节数存入 ecx
    dec edx                     ; 调整缓冲区指针
    
; 使用 xlat 指令转换缓冲区中的数据：
; (注意：添加注释的指令跟 XLAT 做同样的事情)
; 去掉注释，然后把 XLAT 注释掉，试试看：

Translate:
    ; xor eax,eax               ; 清除 eax 的高 24 位
    mov al,byte [edx+ecx]       ; 加载字符到 AL 中以备转换
    ; mov al, byte [UpCase+eax] ; 通过表来转换 AL 中的字符
    xlat
    mov byte [edx+ecx],al
    dec ecx                     ; 把字符计数器减1
    jnz Translate               ; 如果缓冲区里还有字符，重复执行
    
; 把装满缓冲区的文本的缓冲区写入标准输出：
Write:
    mov eax,4                   ; 指定 sys_write 调用
    mov ebx,1                   ; 传递文件描述符1：标准输出
    mov ecx,ReadBuffer          ; 传递缓冲区的偏移地址
    mov edx,ebp                 ; 传递字节数到缓冲区中
    int 80H                     ; 进行内核调用
    jmp Read                    ; 回去继续循环，加载另一个装满数据的缓冲区

; 通过标准错误显示信息“我做完了”:
Done:
    mov eax,4                   ; 指定 sys_write 调用
    mov ebx,2                   ; 指定文件描述符2：标准错误
    mov ecx,DoneMsg             ; 传递该信息的偏移地址
    mov edx,DoneLen             ; 传递该信息的长度
    int 80H                     ; 进行内核调用

; 全部完成
    mov eax,1                   ; 退出程序
    mov ebx,0                   ; 将 0 作为返回值
    int 80H                     ; 进行内核调用
```



custom 表代表了如下规则：

* 所有小于 127 的可打印 ASCII 字符被转换成它们自己。(严格来讲，它们并没有被丢下不管，而是转换成了同样的字符。)
* 所有 ASCII 码从 127～255 的“高位”字符都被转换成 ASCII 空字符(32 或 20H)
* 所有不可打印 ASCII 字符(总的来说，值在 0～31 之间，还有 127)被翻译成空格，除了 9 和 10 之外。
* 字符值9和10(tab 和 EOL)被转换成它们本身。



## 9.7 用表来代替计算

计算机的标准化使得字符转换不再像以前那样普遍，但是转换表在某些其他领域可以相当的有用。其中之一就是执行快速数学运算。看看以下的表：

Squares: db 0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225

Squares 是一张 0～15之间的数字的平方表。如果在某个计算中需要用到 14 的平方，可以使用 MUL 指令，但是它的运算速度非常慢，而且需要两个通用寄存器；或者你也可以简单地从 Squares 表中取出结果

```
mov ecx,14
mov al,byte[Squares+ecx]
```

现在 ecx 包含了 14 的平方。可以用 XLAT 完成同样的功能，虽然它要求使用特定的寄存器。**还要记住，XLAT 被限制在 8 位量内。**上面显示的 Squares 表是 XLAT 所能使用的最大的平方表，因为下一个平方值(16)是256，它不能用 8 位表示。

建立一张每个条目都是 16 位的平方值的查找表能够让你包含0～255之间的所有整数的平方。如果查找表的每一个条目都是 32 位，你就能包含0～65535 之间的所有整数的平方——但是那将是一张规模巨大的表。

使用表来查找一些诸如平方根之类的值曾经使用得非常频繁。近几年来，在 CPU 中直接包含一些诸如数学运算的处理器使得这类技术不再像以前那样具有竞争力了。但是，当面对一个整数运算的挑战时，你应该时刻在脑中想着使用查找表的可能性。



# 第 10 章 分治 使用进程和宏来对抗程序的复杂性

复杂性是程序的致命之伤，这是我的血泪教训。它不仅对于汇编语言是正确的，而且适用于 Java, C, Pacall 或者曾经出现过的任何其他编程语言。现在，你已经能够编写相当复杂的汇编程序了，**你最好学会如何管理这种复杂性，否则你会发现自己不得不放弃大量代码，仅仅是因为记不起来或者无法推算出它的工作原理。**



## 10.1 盒子里面的盒子

在编程中，管理复杂性是一项非常巨大的挑战。其关键技巧听起来有点像东方神秘主义，但它实际上不过是一个来自生活的观察结果：任何行动的里面都包含着一个个更小的行动。

任何一个盒子的内容仅需一点点仔细研究就应该能被理解。每个单个的盒子不应该包含比较微妙或者较大块的内容，而且也不应该让人们花费几个小时的时间盯着它，绞尽脑汁才能推算出来。



### 10.1.1 作为代码盒子的过程

在编写软件期间，我本应该时刻注意那些共同工作以完成某一可识别任务的代码序列。当看到这样的序列时，我本应该把它们设置为过程，并为每一个过程赋予一个描述性名称。那样的话，每个序列就会拥有一个记忆标号以标示该序列的功能了。如果实现调整一行位置的操作使用了十条语句，那么这十条语句应该被命名为 JustifyLine，等等。

施乐公司的传奇 APL 程序员吉姆 邓恩后来高速我，APL 过程不应该编写得过长，以至于不能在一个 25 行的中断屏幕上显示完全。“如果超过 25 行，你在一个过程中所做的事情就太多了。所以，要把它分开”它说。从此以后，每当使用 APL 工作时，我都坚持那条睿智的经验规则。

所有当今常用的计算机语言都执行这种或那种形式的过程，汇编语言也不例外。一个汇编程序可能拥有许多个过程。事实上，对于可以在一个程序中包含多少个过程没有任何限制，只要所有过程包含的代码加在一起的字节总数，加上它们使用的数据，不超过 Linux 分配给单个用户空间程序的两千兆不断变化的字节即可。

那是很多的代码，即使是最大的商业应用程序，如 OpenOffice 也没有那么大。无论编写的汇编语言程序多么复杂，我们都可以通过过程来进行管理。





## 10.2 调用和返回

call 首先将它本身后面的下一条指令压入堆栈。 然后 call 将执行转移到 call 后面的标号处。最后通过 RET 而终止。RET 指令弹出堆栈顶部的地址，并将执行流程转移到该地址。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/call.png" alt="截屏2021-06-23 下午11.10.24" style="zoom:67%;" />



### 10.2.1 调用中的调用

在过程内部可以做任何主程序本身能够做的事情，包括从一个过程内部调用其他过程以及通过 INT 80H 调用请求 Linux 内核服务。



### 10.2.2 意外递归的危险

在一个过程内部调用另外一个过程时，需要注意至少一件事情：堆栈空间。每个过程调用都将一个 32 位的返回地址压入堆栈，只有当该过程的 RET 指令得到执行时，这个返回地址才会从堆栈中移除。**调用过深可能会使堆栈与数据或代码段相撞**。

递归是一种自己调用自己的技术，它是一种合法的表达方式。对于每一个对自身的调用，递归过程必须最终执行一个 RET 。何时返回通常由一个条件转移指令来控制，如果没有遵循该条件转移指令的使用规则，或者对其标志规范理解有误，就可能发生栈溢出，Linux 将提交一个分段错误。



### 10.2.3 一个需要堤防的标志规范 BUG

dec 并不影响标志位。在循环中，不能使用 dec 来控制循环变量。



### 10.2.4 过程及其所需数据

在汇编中，根据访问方法的不同，一般分为两种类型的数据:全局数据和局部数据。

全局数据：可被程序中任意位置的代码访问。全局数据项在 .data 段 和 .bss 段中进行定义。CPU 寄存器也可以作为全局数据的容器。

对于简单的程序而已，向一个过程传递数据的显而易见的方式就是将数据放在寄存器中。



### 10.2.5 保存主调程序的寄存器

CPU 寄存器很常用，但数量又很少。为了解决这个矛盾，可以在过程中，将处于空闲状态的压入栈中，然后就可以作为临时变量使用，在返回前再将它们以相反的顺序弹栈，这样它们就恢复了原来的值。这个过程称为寄存器保护。

例如:

```
push ebx
push esi
push edi
...
pop edi
pop esi
pop ebx
```

也可以一次性把所有寄存器保护起来，在过程中使用，前提是**不需要寄存器向主调程序返回任何内容**。

```
pushad
...
popad
```

如果该指令只在过程中执行次数很少，即使使用pushad也不会对整个程序产生可感知的影响。



主调程序中也可以保存自己的寄存器。原理和过程中寄存器保护类似。

```
push ebx
push edx
call CalcSpace
pop edx
pop ebx
```



关于寄存器的一些忠告：**保存任何你知道的既不在全局范围内使用，也不用来向主调程序返回任何值的寄存器。与由于寄存器冲突而造成的漏洞恶化相比，保存寄存器所需的时间是微不足道的。**



### 10.2.6 局部数据

如果一个过程拥有局部数据，那么当该过程被调用时，这些数据几乎总是存放在堆栈上。在通过 CALL 指令将数据传递给过程之前，主调程序使用 PUSH 指令将局部数据压入堆栈中。但这些局部数据，被调用的过程不能通过 POP 来访问，因为栈顶最后存放的是 CALL 指令之后的地址。

这些局部数据仍然可以通过存储器寻址和堆栈指针 ESP 来访问。但是在没有将返回地址弹出和重新压入堆栈之前，你不能使用 POP 指令来获取它们。但这不是明智的选择。**堆栈帧的概念将在本书的后面部分讲解。**出于安全使用考虑，局部数据需要一些特殊的照顾和纪律。



### 10.2.7 更多的表格技巧

可以由多个表组成一个功能更强大的表，如下列代码所示：

```asm
DumpLin: db " 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
DUMPLEN EQU $-DumpLin
ASCLin: db "|................|",10
ASCLEN EQU $-ASCLin
FULLLEN EQU $-DumpLin
```

这样可以单独处理表DumpLin 和 ASCLin，也可以将它们作为一个整体进行处理，如打印等。C 语言中的结构体在本质上也以相同的方式进行处理。



### 10.2.8 在过程定义中加入常量数据

```asm
; 可执行程序名：newlines
; 功能：发送1到15个换行符到 Linux 控制台
; 输入：EDX 1到15之间
; 返回值：没有
; 修改：没有，所有主调程序的寄存器都被保护
; 调用：sys_write
; 描述：通过使用 INT 80h sys_write，将若干个换行符(0AH)发送到标准输出；其中，换行符的个数由 EDX 中的值决定
; 本过程演示了将常量数据存放到过程定义本身，而不是放到.data 段或者 .bss 段

Newlines:
    pushad
    cmp edx,15
    ja .exit
    mov ecx,EOLs
    mov eax,4
    mov ebx,1
    int 80H

.exit:
    popad
    ret

EOLs: db 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
```

EOLs 表往往会随着Newlines过程一起被拷贝和剪切，因为EOLs只为Newlines所用。EOLs 表不是局部的，但是它"看起来"是局部的。



## 10.3 局部标号和跳转长度

什么是标号？

标号本质上是内存地址。

1. 可以表示过程，通过**跳转指令**可以将指令执行流程跳转到某个标号指定的地址处。将一个过程作为一个外部库让其他程序调用，也是通过将某个过程声明位 GLOBAL 来实现，
2. 可以表示变量，将某些变量作为一个外部库资源供其他程序使用，也是通过将某个变量标号声明为 GLOBAL 实现。

一个源程序可以包含很多标号，一个不可避免的问题就是标号重复的问题，这在跳转时会产生矛盾，到底跳转到哪个标号，为了解决这个矛盾，NASM 创造了一个特性：局部标号。

局部标号与普通标号的区别：

1. 局部标号以 '.' 开始，例如 .modTest
2. 局部标号的所属全局标号是指源代码文件中该局部标号上面的第一个标号。

```asm
; Go through the buffer and convert binary byte values to hex digits:
Scan:
	xor eax,eax		; Clear EAX to 0
	mov al,byte[Buff+ecx]	; Get a byte from the buffer into AL
	mov edx,esi		; Copy total counter into EDX
	and edx,0000000Fh	; Mask out lowest 4 bits of char counter
	call DumpChar		; Call the char poke procedure

; Bump the buffer pointer to the next character and see if buffer's done:
	inc esi			; Increment total chars processed counter
	inc ecx			; Increment buffer pointer
	cmp ecx,ebp		; Compare with # of chars in buffer
	jb .modTest		; If we've processed all chars in buffer...
	call LoadBuff		; ...go fill the buffer again
	cmp ebp,0		; If ebp=0, sys_read reached EOF on stdin
	jbe Done		; If we got EOF, we're done
```

上述代码中，局部标号 .modTest 所属的全局标号是 Scan

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-25 上午11.39.29.png" alt="截屏2021-06-25 上午11.39.29" style="zoom:67%;" />



关于局部标号的注意事项：

* 局部标号至少对于定义它们的过程而言是局部的。
* 局部标号不能作为断点供 Gdb 调试。
* 在一个全局标号下面，不要尝试定义太多局部标号。
* 一条经验法则：局部标号和到它们的所有跳转应该发生在一屏代码之内。
* 一个代码风格约定：将局部标号的句号之后的第一个字符采用小写形式。



### 10.3.1 “强行”访问局部标号

如何从外部访问某个局部标号？

例如: Calc 是一个全局标号，.modTest 是 Calc 的一个局部标号，通过如下代码从外部调用局部标号：

```
jne Calc.modTest
```



### 10.3.2 短转移，近转移和远转移

短转移：跳转的目标标号在 127 个字节以内的条件转移指令。

近转移：跳转目标的距离超过 127 个字节，但是仍然在当前代码段中的条件转移指令。(最大可跳转到距离该指令 2GB 的位置)。

远转移：跳转目标不在当前代码段。

```asm
jne Scan         ; 短转移指令
jne near Scan    ; 近转移指令
```



## 10.4 生成外部库的过程

从编译角度来看，每个单独的 .asm 文件都被认为是一个模块。不管是包含一个 _start: 标号，还是简单地包含过程。

每个可执行文件只能包含一个 _start: 标号。



### 10.4.1 全局声明和外部声明

当一个过程想从外部引用时：应该在 .text 段开头将该过程声明为 GLOBAL，例如：

```
GLOBAL MyProc
```



如果想在一个程序中使用外部库中的过程，那么必须使用 EXTERNAL 来声明该过程，表示该过程存在于外部库中。例如：

```
EXTERNAL MyProc
```



<img src="/Users/wangjun/Desktop/截图/截屏2021-06-25 下午3.44.13.png" alt="截屏2021-06-25 下午3.44.13" style="zoom:67%;" />

### 10.4.2 全局过程和外部过程的机制

* 外部模块不包含主程序，因此没有起始地址。
* 外部模块并不返回 Linux。



### 10.4.3 连接库文件到程序中

将库文件编译为 .o 文件，在连接的时候，需要包含所有需要的 .o 文件。例如：

```
hexdump3: hexdump3.o
	ld -m elf_i386 -o hexdump3 hexdump3.o ../textlib/textlib.o
hexdump3.o: hexdump3.asm
	nasm -f elf -g -F DWARF hexdump3.asm
```



### 10.4.4 太多过程和库的危险

过犹不及。



## 10.5 自定义过程的艺术

过程的作用：**将那些服务于公共目标的指令集合在一起，将其做成一个命名实体，因而使代码更加容易维护。**可维护性在软件设计中可能是块最难啃的骨头，而且可维护性完全取决于可理解性。



### 10.5.1 可维护性和可重用性

过程的一个最重要的目的：**通过用一个描述性的名称来代替一个机器指令序列来管理程序的复杂性。**其次是代码重用。

代码重用主要通过以下几种方式帮助我们实现代码的可维护性：

* 重用意味着较少的代码总量。
* 重用维护了你话费在调试方面的时间和精力。
* 重用迫使你一直在项目中保持一定的编码约定(因为你的库需要它)。
* 重用意味着你将拥有较少的，只是以稍微不同的方式完成相同的事情的代码序列。

总结下：**通过简单地减少必须管理的复杂性的数量来管理复杂性。**



### 10.5.2 确定哪些代码应该成为一个过程

什么时候一个指令块应该被做成一个过程呢？

* 寻找经常在一个程序内部发生的行为。
* 寻找可能不会在任何单个程序发生很多次，但却往往以相同的方式在许多或者大多数程序中发生的行为。
* 当程序变得越来越大，查找可被做成过程的功能模块，以便使主程序的整个执行流程变得更加容易理解。
* 在程序中寻找哪些为了响应不可控的力量(如数据规格，第三方库，等等)而可能随着时间变化的行为，并将这些行为隔离到过程中(方便后期修改)。
* 不过指令有多短小，可能只包含3条或4条，也可以做成一个过程。

```asm
Start: 
	Call initialize             ; 打开指定文件，创建缓冲区
	call OpenFile               ; 打开目标数据文件
	
Input: 
	call GetRec                 ; 从打开的文件中取出一条记录
	cmp eax,0                   ; 在文件读取过程中 测试 EOF
	je Done                     ; 如果我们已经碰到 EOF ，就关闭程序
	call ProcessRec             ; 处理该条数据
	call VerifyRec              ; 验证这条修改后的数据
	call WriteRec               ; 将修改后的记录写出到文件中
	jmp Input                   ; 转回去做重复的事情
	
Done:
	call CloseFile              ; 关闭打开的文件
	call CleanUp                ; 删除临时文件
	mov eax,1                   ; 指定退出系统调用
	mov ebx,[StatusCode]        ; 将状态码传递给操作系统
	int 80H                     ; 返回 Linux
```



### 10.15.3 使用注释标头

必须将每个单个单独过程相关的本质事实形成文档，否则你将很快忘记它们或者将它们记错并按照错误的信息采取行动。

我强烈建议在每一个自己编写的过程中增加一个注释标头，无论这个过程有多简单，这样的标头至少应该包含以下信息：

* 过程的名称。
* 最后修改日期。
* 每个入口点的名称，如果该过程拥有多个入口点的话。
* 过程所做的事情。
* 主调程序必须向其传递哪些数据它才能正常工作。
* 哪些数据(如果有的话)被该过程返回，以及这些数据被返回到哪个地方(例如，到寄存器 ECX 中)
* 过程修改了哪些寄存器或者数据项。
* 哪些其他过程被该过程调用(如果有的话)
* 在编写使用该过程的程序代码时需要牢记的所有注意事项。

除此之外，注释标头中的其他信息有时对我们也是有所帮助的：

* 过程的版本，如果使用版本控制的话。
* 过程的创建日期。
* 编写该过程的人的姓名

一个典型的可行的过程标头看起来像这样：

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-25 下午3.46.24.png" alt="截屏2021-06-25 下午3.46.24"  />



## 10.6 Linux 控制台下的简单关闭啊控制

可以通过将特定的字符编码发送的标准输出，来实现光标控制：

清空控制台： `ClearTerm: db 27,"[2J"    ; <ESC>[2J `
\<ESC\>的ASCII 码值为 27



将光标移动到指定位置：`PosTerm: db 27,"01;01H ; <ESC>[<Y>;<X>H`  

例如通过 C 实现光标控制：

```c
#include <stdio.h>
int main(){
    printf("%c%c%c%c",27,'[','2','J');   // 清空控制台
    printf("%c%c%c%c%c%c%c%c%s",27,'[','1','2',';','3','5','H',"hello world");
    printf("%c%c%c%c%c%c%c%c%s",27,'[','2','3',';','0','3','H',"Enter:");
    getchar();
    return 0;
}
```



### 控制台注意事项

基于 Debian 的 Linux 发行版中而设计的两种最流行的控制台终端实用程序——GNOME Terminal 和 Konsole上。

在 Konsole 中 通过 GreenBack: db 27,"[42m"    可以将控制台的背景色转换为绿色。

关于这方面的内容(以 简洁 Unix 风格)的资料可在 Linux 手册中根据关键字 "console_codes"找到，我鼓励你去尝试，同时铭记不同的控制台(特别是在非Linux的Unix实现上)可能对不同的转义序列有不同的反应。

不过，控制控制台的输出并不是最糟糕的。控制台编程的最高境界是创造全屏文本应用程序，它能够在控制台上"绘制"一个表格，包括数据入口字段，并允许用户通过使用 TAB键从一个字段跳转到另一个字段域，而且可在每个字段域中输入数据。这在 Linux 中极为困难，因为需要通过一些名为原始模式的方式访问控制台键盘上的单个按键。仅仅说明原始模式的工作原理就将花费一章的大部分篇幅，而且会涉及很多我在本书没有空间讲解的比较先进的 Linux 话题。

处理控制台的标准 UNIX 方式是一个名为一个 ncurses 的 c 库并且虽然 ncurses 可以从汇编中进行调用，但是它实际上是一个既臃肿又丑陋的家伙。汇编程序员的更好的选择是一个比较新的，专门为 NASM 汇编语言而编写的库，名为 LinuxAsmTools。它的作者是杰夫-欧文斯，它几乎能做所有ncurses 能做的事情，而且没有 c 的硬性约定和令人讨厌的东西。LinuxAsmTools 是免费的，可以在 http://linuxasmtools.net/上找到它



## 10.7 创建和使用宏

![截屏2021-06-25 下午5.39.11](/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-25 下午5.39.11.png)



### 10.7.1 宏定义机制

 ; macroName 为宏名，n 为调用宏时必须传入的参数个数，参数在宏中通过使用%1，%2...%n来引用。

%MACRO macroName n     

...

%ENDMACRO



### 10.7.2 定义带参数的宏

观察下列宏

```
%macro WriteCtr 3	; %1 = row; %2 = String addr; %3 = String length
	push ebx	; Save caller's EBX
	push edx	; Save caller's EDX
	mov edx,%3	; Load string length into EDX
	xor ebx,ebx	; Zero EBX
	mov bl,SCRWIDTH	; Load the screen width value to BL
	sub bl,dl	; Calc diff. of screen width and string length
	shr bl,1	; Divide difference by two for X value
	GotoXY bl,%1	; Position the cursor for display
	WriteStr %2,%3	; Write the string to the console
	pop edx		; Restore caller's EDX
	pop ebx		; Restore caller's EBX
%endmacro
```



宏 WriteCtr 需要3个参数，这个 3 个参数分别在宏体中用 %1 %2 %3按传入顺序依次表示。



### 10.7.3 宏调用机制

以下是对 WriteCtr 宏的完全合法且合理的调用方法：

```
mov al,4
WriteCtr al,AdMsg,ADLEN
```

在 WriteCtr 中，在 NASM 用 AL 寄存器的名字取代了 %1 形参，所以：

```
GotoXY bl,%1   ; 定位贯标用于显示指定内容
```

变成了

```
GotoXY bl,al
```



类似地，可以将一个带括号的地址作为实参来传递

WriteCtr [RowValue],AdMsg,ADLEN

此时 %1 就表示地址，使用时需要指定条件限定符:byte,word ,dword



### 10.7.4 宏内部的局部标号

在宏定义内部的所有标号都被认为是宏的局部标号，并且被汇编编译器进行了特殊处理。

在宏内部定义的局部标号名称以 "%%" 开头

例如 

```
%%IsLC:
	cmp byte [edx+ecx-1],'z'
	....
	sub byte [edx+ecx-1],20H
```

需要引用时：

```
 jmp %%IsLC
```

在编译器编译的时候，NASM 会将宏内部的局部标号名称生成一个独一无二的名称(以..@为前缀，将一个4位数字和标号的名称相连)，防止不管宏被调用多少次都不会出现同名的标号。例如：

%%IsLC 标号，在一次给定的调用中，可能会成为 ..@1771.IsLC



### 10.7.5 像包含文件一样宏库文件

宏库文件 以 mac 作为扩展，例如：mylib.mac

在需要使用该宏的文件中，需要在程序中包含，例如：在 .text 段的开头包含 `%include "mylib.mac"`

如果宏库文件不在当前目录下，那就必须包含宏库文件的完整路径。



### 10.7.6 宏 vs 过程：优点和缺点

宏：

* 优点：执行速度快
* 缺点：占用更多内存空间

过程：

* 优点：占用空间少
* 缺点：执行速度慢：执行和控制进入一个过程的 CALL 指令和从一个过程中退出均需要时间。而在一个宏中，这两条指令一个也不使用。



# 第 11 章 字符串奏鸣曲 神奇的字符串指令

一些字符串指令有权以一种非常紧凑的方式处理大量的字节序列：像执行单条指令一样执行一个完整的循环指令，而且完全在 CPU 之内完成。



## 11.1 汇编语言中字符串的概念

字符串是在内存中的任意一组连续的字节，可以为操作系统允许的任意大小。汇编语言中的字符串的主要概念界定是：它的成员字节刚好排成一排，没有中断。



### 11.1.1 彻底颠覆你的 “字符串感觉”

当你将一个寄存器设置为指向一个字符串时，你就拥有了一个字符串。而一旦你指向了一个字符串，该字符串的长度将由存放在寄存器 ECX 中的值决定。在 CPU 的芯片上，硬编码了一组关于字符串和寄存器的假设。**当执行一条字符串指令，CPU 将使用这些假设来确定读取或写入哪些内存区域。**



### 11.1.2 源字符串和目标字符串

源字符串和目标字符串也可以重叠。

以下是 32 位保护模式下执行字符串指令时，CPU 对字符串所做的假设：

* ESI 寄存器指向源字符串。
* EDI 寄存器指向目标字符串。
* 这两种字符串的长度都等于存放在 ECX 寄存器中的值。至于这个长度如何对 CPU 起作用，取决于具体的指令及该指令的使用方法。
* 来自一个源字符串或者去往一个目标字符串的数据必须要么从寄存器 EAX 开始旅行，要么在寄存器 EAX 中结束旅行，要么通过寄存器 EAX

当同时使用源字符串和目标字符串时，它们的长度必须相等。



### 11.1.3 虚拟文本显示屏幕

在 Linux 下已经不能直接操作硬件，要操作硬件，必须通过操作系统。使用汇编语言为 Linux 控制台编写文本模式的应用程序已经根本不可能再像 DOS 下那么容易了。

不过我们可以通过一些技巧，其中之一就是在内存中创建我们自己的文件视频刷新缓冲区，并将其作为一个已命名变量，定期通过 INT 80H 指令写到 Linux 控制台上。本质上，就是显示一个很长的字符串。

```asm
;  Executable name : VIDBUFF1
;  Version         : 1.0
;  Created date    : 5/11/2009
;  Last update     : 5/13/2009
;  Author          : Jeff Duntemann
;  Description     : A simple program in assembly for Linux, using NASM 2.05,
;    demonstrating string instruction operation by "faking" full-screen
;    memory-mapped text I/O.
;
;    Note that the output to the console from this program will NOT display
;    correctly unless you have enabled the IBM850 character encoding in
;    the terminal program being used to display the console! For more on
;    this issue, and how to enable IBM850, see p. 177 in the book.
;
;  Build using these commands:
;    nasm -f elf -g -F stabs vidbuff1.asm
;    ld -o vidbuff1 vidbuff1.o
;

SECTION .data			; Section containing initialised data
	EOL 	equ 10		; Linux end-of-line character
	FILLCHR	equ 32		; ASCII space character
	HBARCHR	equ 196		; Use dash char if this won't display
	STRTROW	equ 2		; Row where the graph begins

; The dataset is just a table of byte-length numbers:
	Dataset	db 9,17,71,52,55,18,29,36,18,68,77,63,58,44,0

	Message db "Data current as of 5/13/2009"
	MSGLEN  equ $-Message

; This escape sequence will clear the console terminal and place the
; text cursor to the origin (1,1) on virtually all Linux consoles:
	ClrHome db 27,"[2J",27,"[01;01H"
	CLRLEN	equ $-ClrHome	; Length of term clear string
	
SECTION .bss			; Section containing uninitialized data	

	COLS	equ 81		; Line length + 1 char for EOL
	ROWS	equ 25		; Number of lines in display
	VidBuff	resb COLS*ROWS	; Buffer size adapts to ROWS & COLS

SECTION .text			; Section containing code

global 	_start			; Linker needs this to find the entry point!

; This macro clears the Linux console terminal and sets the cursor position
; to 1,1, using a single predefined escape sequence.
%macro	ClearTerminal 0
	pushad			; Save all registers
	mov eax,4		; Specify sys_write call
	mov ebx,1		; Specify File Descriptor 1: Standard Output
	mov ecx,ClrHome		; Pass offset of the error message
	mov edx,CLRLEN		; Pass the length of the message
	int 80H			; Make kernel call
	popad			; Restore all registers
%endmacro

;-------------------------------------------------------------------------
; Show: 	Display a text buffer to the Linux console
; UPDATED: 	5/13/2009
; IN: 		Nothing
; RETURNS:	Nothing
; MODIFIES: 	Nothing
; CALLS:	Linux sys_write
; DESCRIPTION:	Sends the buffer VidBuff to the Linux console via sys_write.
;		The number of bytes sent to the console is calculated by
;		multiplying the COLS equate by the ROWS equate.

Show:	pushad			; Save all registers
	mov eax,4		; Specify sys_write call
	mov ebx,1		; Specify File Descriptor 1: Standard Output
	mov ecx,VidBuff		; Pass offset of the buffer
	mov edx,COLS*ROWS	; Pass the length of the buffer
	int 80H			; Make kernel call
	popad			; Restore all registers
	ret			; And go home!


;-------------------------------------------------------------------------
; ClrVid: 	Clears a text buffer to spaces and replaces all EOLs
; UPDATED: 	5/13/2009
; IN: 		Nothing
; RETURNS:	Nothing
; MODIFIES: 	VidBuff, DF
; CALLS:	Nothing
; DESCRIPTION:	Fills the buffer VidBuff with a predefined character
;		(FILLCHR) and then places an EOL character at the end
;		of every line, where a line ends every COLS bytes in
;		VidBuff.

ClrVid:	push eax		; Save caller's registers
	push ecx
	push edi
	cld			; Clear DF; we're counting up-memory
	mov al,FILLCHR		; Put the buffer filler char in AL
	mov edi,VidBuff		; Point destination index at buffer
	mov ecx,COLS*ROWS	; Put count of chars stored into ECX
	rep stosb		; Blast chars at the buffer
; Buffer is cleared; now we need to re-insert the EOL char after each line:
	mov edi,VidBuff		; Point destination at buffer again
	dec edi			; Start EOL position count at VidBuff char 0
	mov ecx,ROWS		; Put number of rows in count register
PtEOL:	add edi,COLS		; Add column count to EDU
	mov byte [edi],EOL	; Store EOL char at end of row
	loop PtEOL		; Loop back if still more lines
	pop edi			; Restore caller's registers
	pop ecx
	pop eax
	ret			; and go home!


;-------------------------------------------------------------------------
; WrtLn: 	Writes a string to a text buffer at a 1-based X,Y position
; UPDATED: 	5/13/2009
; IN: 		The address of the string is passed in ESI
;		The 1-based X position (row #) is passed in EBX
;		The 1-based Y position (column #) is passed in EAX
;		The length of the string in chars is passed in ECX
; RETURNS:	Nothing
; MODIFIES: 	VidBuff, EDI, DF
; CALLS:	Nothing
; DESCRIPTION:	Uses REP MOVSB to copy a string from the address in ESI
;		to an X,Y location in the text buffer VidBuff.

WrtLn:	push eax	; Save registers we change
	push ebx
	push ecx
	push edi
	cld		; Clear DF for up-memory write
	mov edi,VidBuff	; Load destination index with buffer address
	dec eax		; Adjust Y value down by 1 for address calculation
	dec ebx		; Adjust X value down by 1 for address calculation
	mov ah,COLS	; Move screen width to AH
	mul ah		; Do 8-bit multiply AL*AH to AX
	add edi,eax	; Add Y offset into vidbuff to EDI
	add edi,ebx	; Add X offset into vidbuf to EDI
	rep movsb	; Blast the string into the buffer
	pop edi		; Restore registers we changed
	pop ecx
	pop ebx
	pop eax
	ret		; and go home!


;-------------------------------------------------------------------------
; WrtHB: 	Generates a horizontal line bar at X,Y in text buffer
; UPDATED: 	5/13/2009
; IN: 		The 1-based X position (row #) is passed in EBX
;		The 1-based Y position (column #) is passed in EAX
;		The length of the bar in chars is passed in ECX
; RETURNS:	Nothing
; MODIFIES: 	VidBuff, DF
; CALLS:	Nothing
; DESCRIPTION:	Writes a horizontal bar to the video buffer VidBuff, 
;		at the 1-based X,Y values passed in EBX,EAX. The bar is
;		"made of" the character in the equate HBARCHR. The
;		default is character 196; if your terminal won't display
;		that (you need the IBM 850 character set) change the
;		value in HBARCHR to ASCII dash or something else supported
;		in your terminal.

WrtHB:	push eax	; Save registers we change
	push ebx
	push ecx
	push edi
	cld		; Clear DF for up-memory write
	mov edi,VidBuff	; Put buffer address in destination register
	dec eax		; Adjust Y value down by 1 for address calculation
	dec ebx		; Adjust X value down by 1 for address calculation
	mov ah,COLS	; Move screen width to AH
	mul ah		; Do 8-bit multiply AL*AH to AX
	add edi,eax	; Add Y offset into vidbuff to EDI
	add edi,ebx	; Add X offset into vidbuf to EDI
	mov al,HBARCHR	; Put the char to use for the bar in AL
	rep stosb	; Blast the bar char into the buffer
	pop edi		; Restore registers we changed
	pop ecx
	pop ebx
	pop eax
	ret		; And go home!


;-------------------------------------------------------------------------
; Ruler: 	Generates a "1234567890"-style ruler at X,Y in text buffer
; UPDATED: 	5/13/2009
; IN: 		The 1-based X position (row #) is passed in EBX
;		The 1-based Y position (column #) is passed in EAX
;		The length of the ruler in chars is passed in ECX
; RETURNS:	Nothing
; MODIFIES: 	VidBuff
; CALLS:	Nothing
; DESCRIPTION:	Writes a ruler to the video buffer VidBuff, at the 1-based
;		X,Y position passed in EBX,EAX. The ruler consists of a
;		repeating sequence of the digits 1 through 0. The ruler
;		will wrap to subsequent lines and overwrite whatever EOL
;		characters fall within its length, if it will noy fit
;		entirely on the line where it begins. Note that the Show
;		procedure must be called after Ruler to display the ruler
;		on the console.

Ruler:  push eax	; Save the registers we change
	push ebx
	push ecx
	push edi
	mov edi,VidBuff	; Load video address to EDI
	dec eax		; Adjust Y value down by 1 for address calculation
	dec ebx		; Adjust X value down by 1 for address calculation
	mov ah,COLS	; Move screen width to AH
	mul ah		; Do 8-bit multiply AL*AH to AX
	add edi,eax	; Add Y offset into vidbuff to EDI
	add edi,ebx	; Add X offset into vidbuf to EDI
; EDI now contains the memory address in the buffer where the ruler
; is to begin. Now we display the ruler, starting at that position:
        mov al,'1'	; Start ruler with digit '1'
DoChar: stosb		; Note that there's no REP prefix!
	add al,'1'	; Bump the character value in AL up by 1
        aaa		; Adjust AX to make this a BCD addition
	add al,'0'	; Make sure we have binary 3 in AL's high nybble
        loop DoChar	; Go back & do another char until ECX goes to 0
	pop edi		; Restore the registers we changed
	pop ecx
	pop ebx
	pop eax
	ret		; And go home!

;-------------------------------------------------------------------------
; MAIN PROGRAM:
	
_start:
	nop		; This no-op keeps gdb happy...

; Get the console and text display text buffer ready to go:
	ClearTerminal	; Send terminal clear string to console
	call ClrVid	; Init/clear the video buffer

; Next we display the top ruler:
	mov eax,1	; Load Y position to AL
	mov ebx,1	; Load X position to BL
	mov ecx,COLS-1	; Load ruler length to ECX
	call Ruler	; Write the ruler to the buffer

; Here we loop through the dataset and graph the data:
	mov esi,Dataset	; Put the address of the dataset in ESI
	mov ebx,1	; Start all bars at left margin (X=1)
	mov ebp,0	; Dataset element index starts at 0
.blast:	mov eax,ebp	; Add dataset number to element index
	add eax,STRTROW	; Bias row value by row # of first bar
	mov cl,byte [esi+ebp]	; Put dataset value in low byte of ECX
	cmp ecx,0	; See if we pulled a 0 from the dataset
	je .rule2	; If we pulled a 0 from the dataset, we're done
	call WrtHB	; Graph the data as a horizontal bar
	inc ebp		; Increment the dataset element index
	jmp .blast	; Go back and do another bar

; Display the bottom ruler:
.rule2:	mov eax,ebp	; Use the dataset counter to set the ruler row
	add eax,STRTROW	; Bias down by the row # of the first bar
	mov ebx,1	; Load X position to BL
	mov ecx,COLS-1	; Load ruler length to ECX
	call Ruler	; Write the ruler to the buffer

; Thow up an informative message centered on the last line
	mov esi,Message	; Load the address of the message to ESI
	mov ecx,MSGLEN	; and its length to ECX
	mov ebx,COLS	; and the screen width to EBX
	sub ebx,ecx	; Calc diff of message length and screen width
	shr ebx,1	; Divide difference by 2 for X value
	mov eax,24	; Set message row to Line 24
	call WrtLn	; Display the centered message

; Having written all that to the buffer, send the buffer to the console:
	call Show	; Refresh the buffer to the console

Exit:	mov eax,1	; Code for Exit Syscall
	mov ebx,0	; Return a code of zero	
	int 80H		; Make kernel call
```



## 11.2 REP STOSB 软件机枪

虚拟文本显示缓冲区只是一块位于 .bss 段中的，通过使用 RESB 指令预留的内存区域。缓冲区的大小由两个等值来定义，这两个等值指定想要的行数和列数。



### 11.2.1 机枪扫射虚拟显示器

为了将某个字符串(EDI) 的所有值初始化为空格，可以这么做：

目的字符串放入:EDI 寄存器，将字节数放入 ECX 寄存器中，将空格值放入 AL 中，然后通过如下方式编码实现紧密循环：

```asm
Clear:
	mov byte [edi],AL       ; 将 AL 中的值写入内存
	inc edi                 ; 将 EDI 指向缓冲区中的下一个字节
	dec ecx                 ; 将 ECX 递减一个位置
	jnz Clear               ; 再次循环直到 ECX 中的值变为零
```

上面的代码与以下汇编字符串指令等价，它们完成同样的事情。

```asm
rep stosb
```

* rep 叫做前缀，它改变了 CPU 处理它后面的指令助记符的方式：递减 ecx 以及跳转。如果没有 rep 就得手动完成这些指令。

* stosb，这个助记符的意思是按字节存储字符串，它仅适用于目标字符串，它的功能需要以下寄存器的参与：

  * 目标字符串加载到 EDI 中(可以这样认为：EDI 和 D 既为目标(destination)的第一额字符，I即为索引(index)的第一个字母)。

  * 需要存取 AL 值的次数存入 ECX 中。

  * 将需要存入字符串的字符放入 AL 中。



### 11.2.2 执行 STOSB 指令

 设置了那 3 个寄存器，就可以安全地执行 STOSB 指令了。当这样做时，将发生以下事情：

1. AL 中的字符值被复制到存放在 EDI 中的内存地址中。
2. EDI 被递增 1，这样，它现在指向内存中刚刚写入的字节的下一个字节。

但是，它没有自动执行指定的次数，换句话说，它并没有递减 ECX 和跳转。只有把 rep 前缀放在 STOSB 的前面，ECX才会自动递减。

如果没有 rep，我们必须显式通过 DEC 指令 或者通过 LOOP 指令。这样也是有好处的，可以更改 AL 的值，以使在一个循环中写入不同的值。

REP 所做的事非常简洁：**它建立一个所有紧密循环中最紧密的循环，而且完全在 CPU 内部，并且重复地将 AL 中的副本发送到内存，每次将 EDI 递增 1，同时将 ECX 递减 1，直到 ECX 递减为 0。然后它就停止。**当善后工作处理完毕，我们会看到整个目标字符串已经添满了 AL 的副本，无论它有多大。

REP STOSB 的使用方法如下：

```
cld                 ; 清零 DF，从内存地址递增的方向开始循环
mov al,FILLCHR      ; 将缓冲区过滤器字符放入 AL 中
mov edi,VidBuff     ; 指向缓冲区中的目标索引
mov ecx,COLS*ROWS   ; 将存储的字符的数量放到 ECX 中
rep stosb           ; 在缓冲区中 “爆炸” 字符
```

FILLCHR 默认被设置为 32，代编空格字符。



### 11.2.3 STOSB 和方向标志(DF)

DF 被清除(为 0)：edi 往内存地址递增的方向变化，即越来越大

DF 被设置(为 1)：edi 往内存地址递减的方向变化，即越来越小



### 11.2.4 在显示缓冲区中定义行

由于虚拟显示器的宽度小于实际显示器的宽度，我们可以在希望虚拟显示器的每行结束的位置放入 EOL 字符(行结束符)。例如 ，由以下的每一行就组成一个虚拟显示器：

1 2 3 4 5 6 7 EOL

1 2 3 4 5 6 7 EOL

1 2 3 4 5 6 7 EOL

该虚拟显示器，本质上就是以下字符串，每一个字符都是一个 ASCII 码(空格不算)：

1 2 3 4 5 6 7 EOL 1 2 3 4 5 6 7 EOL 1 2 3 4 5 6 7 EOL



### 11.2.5 将缓冲区发送到Linux 控制台

通过 INT 80H 对内核服务 sys_write 进行单次调用，将字符串1 2 3 4 5 6 7 EOL 1 2 3 4 5 6 7 EOL 1 2 3 4 5 6 7 EOL发送到控制台，就完成了一个虚拟显示器的现实。



## 11.3 半自动武器：不带 REP 的 STOSB

不带 REP 的好处：可以存储不同值到目标字符串中。

缺点：我们会在自己处理 CPU 外面的循环上浪费一点时间，因为必须花费一些时间从内存中获取循环指令字节。不过，**如果能让循环尽可能紧密，速度不会降低到令人反感的程度。**特别是在现代处理器上，我们可以非常有效地利用缓存，因而不必每次执行时都从内存中取值。



### 11.3.1 是谁递减了 ECX 

当使用REP STOSB(或任何带有 REP 前缀的字符串指令)时，在每个内存访问指令发生时，ECX 都被自动减 1.而且一旦 ECX 将自身递减到 0，REP STOSB 将检测到 ECX 的当前值为 0，进而会停止对内存的射击。

如果拿走了 REP ，ECX 将停止自动递减。因而对于 “ECX” 中的计数值是否已经减到 0 的自动检测也会停止。所以，没有 REP，就必须手动递减 ECX，例如`DEC ECX`，然后使用 JNZ(不为零跳转)指令。



### 11.3.2 LOOP 指令

观察以下代码：

```asm
DoChar:
	stosb                ; 此时没有 REP 前缀
	add al,'1'           ; 将 AL 中的字符加 1
	aaa                  ; 调整 AX 使之成为 BCD 加法
	
	dec ecx              ; 将计数器递减 1
	jnz DoChar           ; 如果 ECX > 0,继续循环
```

这个循环等价于以下代码：

```asm
DoChar: 
	stosb                ; 此时没有 REP 前缀
	add al,'1'           ; 将 AL 中的字符的值加 1
	aaa                  ; 调整 AX 使其成为一个 BCD 加法
	add al,'0'           ; 确保我们已经把二进制 3 放入到 AL 的高半字节
	loop DoChar          ; 回去继续处理另一个字符，直到 ECX 变为 0
```



Loop 指令首先将 ECX 递减 1，然后它检查零标志，看看该递减操作是否迫使 ECX 变为零。



### 11.3.3 在屏幕上显示一个标尺

Ruler 过程在屏幕上某一可选位置上显示一个从 1 开始递增的，数字的，可以为任意长度的重复序列。换句话说，你可以在任意你想要的地方显示这样一个数字字符串：

12345678901234567890123456789012345678901234567890

一个典型的对 Ruler 过程的调用看起来这样：

```asm
mov eax,1           ; 加载 Y 的位置到 AL 中
mov ebx,1           ; 加载 X 的位置到 BL 中
mov ecx,COLS-1      ; 加载标尺的长度到 ECX 中
call Ruler          ; 将标尺写入缓冲区中
```

为什么长度要小一个字符，因为每一行的末尾都必须有一个 EOL 字符。



### 11.3.4 MUL 并非 IMUL

用来确定任一给定的X Y 值在缓冲区中的，以字节为单位的偏移地址的算法看起来是这样的：

```asm
Offset = ((Y * 以字节为单位的显示器的一行的宽度) + X)
```



显然，我们必须在屏幕缓冲区中向下移动 Y 行，然后在从屏幕的左边距处向右移动 X 个字节才能到达(X,Y)位置。在 Rular 过程中，计算过程如下：

```asm
mov edi,VidBuff   ; 加载视频地址到 EDI 中
dec eax           ; 将 Y 值往下调整 1，用于做地址计算
dec ebx           ; 将 X 值往下调整 1，用于做地址计算
mov ah,COLS       ; 将屏幕的宽度放入 AH 中
mul ah            ; 执行 8 位 乘法：AL * AH，并将结果存回 AX 寄存器中
add edi,eax       ; 将 Y 在 VidBuff 中的偏移地址放入 EDI 中
add edi,ebx       ; 将 X 在 VidBuff 中的偏移地址放入 EDI 中 
```



MUL 不能替换为 IMUL，因为IMUL 是有符号乘法指令，当操作数是 128 时，MUL 认为是 128，而 IMUL 则认为 128 是 -1。因为对于有符号数老说，最高一位为符号位。



### 11.3.5 添加 ASCII 数字

指令 MOV AL,'1' 中，这个 '1' 并不是阿拉伯数字 1，而是 ASCII 码 31H，在显示数元 '1' 后，我们需要显示数元 '2'，并且为了做到这一点，我们需要将存储在 AL 中的值从 '1' 改为 '2'。通常情况下，我们不是简单地将 '1' 和 ‘1’ 相加来得到‘2’。31H + 31H 会得到 62H，这是小写字母 b，而不是 ’2‘。在这种情况下，我们可以使用一个名为 AAA 的，有点特殊的指令，在 BCD 码加法后对 AL 进行调整。

AAA 指令是 BCD 指令族中的一员，之所以叫这个名字是因为它们支持 二-十进制编码运算。BCD 码只是另外一种表达一个数值的方法，有点介于纯粹的二进制值(如 1 ) 和 ASCII (如 '1')码数字之间。

BCD 码值是一个占用一个字节的低半字节的 4 位值。它只能表达介于 0 和 9 之间的值。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-28 下午4.56.27.png" alt="截屏2021-06-28 下午4.56.27" style="zoom:67%;" />



如果有一种方法可在 X86 处理器上执行 BCD 加法，将'1' 和 '1' 相加确实会带给我们 '2' ，因为 '1' 和 '2' 都可被作为合法的 BCD 码值来操作。

AAA 注意到 ADD 指令的结果，并迫使它们按照 BCD 码算术出现。从根本上来讲，AAA 能够做到以下两件事情：

* 如果 AL 中低半字节的值大于9，它将其强制转换为 0 到 9 之间的值。这是通过将 AL 与 6 相加，然后迫使高半字节变为 0 来实现的。显然，如果 AL 的低半字节包含一个有效的 BCD 码数字，那么这低半字节的数字不需要任何处理。
* 如果 AL 中的值必须调整，则表明有一个加法进位，因此 AH 地址1。此外，进位标志 CF 被设置为 1，辅助进位标志 AF 也被设置。同样地，如果当 AAA 指令被执行时，AL 的低半字节包含一个有效的 BCD 码，那么 AH 不被递增，这两个标志位都被清零(强制为 0)，而不是被置为 1。

因此，AAA 可使对 AL 低半字节进行，基于 10(decimal)的加法更为便利。当 AL 被 AAA 指令调整后，低半字节包含一个有效低 BCD 码，而高半字节则包含0。(但是，只有当 AAA 前面的加法是在两个有效的 BCD 码操作数上执行，这才为真)。基于此，我们可以使用 ADD 指令来将诸如 1 和 2 之类的 ASCII 数元相加。Rular 过程在 STOSW 指令之后立即做了这两件事:

```
add al,'1'      ; 将 AL 中的字符数值增大1
aaa               ; 调整 AX 使之 成为一个 BCD 码加法
```

如果在加法之前，AL 的低半字节的内容为9，将其与 1 相加将会产生一个 0AH值，这不是合法的 BCD 码值。AAA 将会通过将其与 6 相加并清除高半字节的内容来调整 AL 的值。将 0A 与 6 相加将会产生结果 10，所以一旦高半字节被清零，AL 中的新值将是0，另外，AH 将被递增 1。



### 11.3.6 调整 AAA

将 ‘1’ 和 ‘1’ 相加不完全等同于可显示数字 '2'，相反，AL 变成了二进制 2。为了使 AL 中的内容再次成为一个可显示的 ASCII 数字，我们需要将 AL 中的值与 30H 相加，即与 '0' 相加，这样 AX 的值变为32H，即'2'。

当执行多列 BCD 码数学运算时，你必须考虑进位，这涉及小心使用辅助进位标志 AF。还有 AAD，AAM，AAS指令分别用于在 BCD 码除法，BCD码乘法，BCD码减法后调整 AL 的值。同样的一般思想依然适用：**所有的 BCD 码调整指令都强制标准的二进制算术指令同意支持有效的 BCD 码操作数。**



### 11.3.7 Ruler 过程的教训 

Rular 过程是一个关于 LOOP 指令如何与 STOSB 共同工作以实现向下调整 ECX 和 控制返回到循环顶部的很好示例。从某种意义上来讲，LOOP 指令在 CPU 之外完成 REP 在 CPU 之内所做的事情：调整 ECX 的值和关闭循。在使用任何字符串指令时，尽量把它的工作原理搞清楚。



### 11.3.8 STOS 指令的 16 位版本和 32 位版本

STOS 字符串指令有三种尺寸：字节，字和双字。分别是：STOSB，STOSW，STOSD。它们分别将特定大小的寄存器的值 存储到内存中。

它们的工作方式几乎相同，主要的不同之处是对 EDI 的修改方式，对于STOSB，改变 1 个字节，对于 STOSW ，改变 2 个字节，对于 STOSD 改变 4 个字节。



## 11.4 MOVSB：快速块拷贝

MOVS 也有三种尺寸：处理字节(MOVSB)，处理 16 位字(MOVSW)和处理 32 位双字(MOVSD)。

MOVSB 指令的特点：一块存放在 ESI 指定的内存地址中的内存数据被复制到存放在 EDI 寄存器中的内存地址，即将移动的字节数存放在 ECX 寄存器中。每当一个字节被复制之后，ECX 中的计数值递减 1，而且将 ESI 和 EDI 中的地址调整 1。对于MOVSB，ESI/EDI调整 1，对于MOVSW，ESI/EDI调整 2，对于MOVSD，ESI/EDI调整 4。具体调整方向，是增大还是减小，取决于 DF 的状态。DF 为0时，地址往增大方向调整，DF 为 1，地址往减小方向调整。

下列过程，演示了 MOVSB 的工作过程: 它将 一个字符串 复制到显示缓冲区 VidBuff 的某一给定的 (X,Y) 位置

```asm
cld               ; 清除 DF，以便进行上内存写入工作
mov edi,VidBuff   ; 将缓冲区地址作为目标索引加载到 EDI 寄存器
dec eax           ; 将 Y 的值下调 1，用于地址计算
dec ebx           ; 将 X 的值下调 1，用于地址计算
mov ah,COLS       ; 将显示器的宽度放入 AH 中
add edi,eax       ; 将 Y 在 VidBuff 中的偏移地址放入 EDI 中
add edi,ebx       ; 将 X 在 VidBuff 中的偏移地址放入 EDI 中 
rep movsb         ; 将这个字符串 "爆炸" 到缓冲区中
```

在 vidbuff1 的主程序部分，需要执行一些额外的计算，以实现在任一可显示的中央而不是在某一特定的(X,Y)位置显示一个字符串：

```asm
mov esi,Message     ; 将消息的地址加载到寄存器 ESI 中
mov ecx,MSGLEN      ; 将消息的长度加载到 ECX 寄存器中
mov ebx,COLS        ; 将屏幕的宽度加载到 EBX 寄存器中
sub ebx,ecx.        ; 计算消息的长度和屏幕的宽度之间的差值
shr ebx,1           ; 将该差值除以1，以求得 X 的值
mov eax,24          ; 将消息的行设置为第 24 行
call WrtLn
```



### 11.4.1 DF 和重叠块移动

没有人规定 ESI 和 EDI 必须指向完全独立的内存区域。源内存块和目标内存块可能会重叠。将我们想把某个字符串往后移动 1 个字符，使用 rep movsb。

```asm
Section .data
	EditBuff: db 'abcdefghijklm '
	ENDPOS equ 12
	INSRTPOS equ 5

section .text
	global _start
_start_:
	nop
; 将你的实验放到两个nop 指令之间
	std               ; 向内存地址减小的放下改变 EDI 和 EDX
	mov ebx,EditBuff+INSERTPOS
  mov esi,EditBuff+ENDPOS
  mov edi,EditBuff+ENDPOS+1
  mov ecx,ENDPOS-INSERTPOS+1
  rep movsb
  mov byte [ebx],' '

  nop
section .bss

```



## 11.5 将数据存储不连续的字符串中

除了可以在 STOSB 指令执行期间更改存放在 EAX 寄存器中的值外，我们还可以更改目标地址。因此在一个非常紧密的循环内将数据存储到不同的内存区域。

### 11.5.1 显示一个 ASCII 表

程序主要部分：

```asm
.DoLn: 
	mov bl,CHRTLEN         	  ; 每行将包含 32 个字符
.DoChr:
	stosb                     ; 注意，没有 REP 前缀
	jcxz ALLDone              ; 当整个序列被打印完毕，退出
	inc al                    ; 将 AL 中的字符值增大 1
	dec bl                    ; 将计数器的值减1
	Loopnz .DoChr             ; 回去并处理另外一个字符直到 BL 变为 0
	add edi,(COLS-CHRTLEN)    ; 将 EDI 挪到下一行的开始位置
	jmp .DoLn                 ; 开始显示下一行
```



### 11.5.2 嵌套指令循环

一旦所有寄存器都根据 STOSB 所做的假设正确设置之后，showchar 的实际工作由两个指令循环来实现，一个指令循环在另一个指令循环的内部。内层循环显示一个由 32 个字符组成的行。外层循环将显示分解成 7 个这样的行。

```asm
.DoLn: 
	mov bl,CHRTLEN         	  ; 每行将包含 32 个字符
.DoChr:
	stosb                     ; 注意，没有 REP 前缀
	jcxz ALLDone              ; 当整个序列被打印完毕，退出
	inc al                    ; 将 AL 中的字符值增大 1
	dec bl                    ; 将计数器的值减1
	Loopnz .DoChr             ; 回去并处理另外一个字符直到 BL 变为 0
```

如果没有 REP 将循环拉到 CPU 内部，那么我们必须自己设置循环。请记住，每次 STOSB "开火"都发生什么：在 AL 中的字符被写入 EDI 寄存器所指向的内存位置，EDI 递增 1。在循环的另一端，LOOPNZ 指令将 ECX 递减1，并关闭循环。



### 11.5.3 当 ECX 变为 0 时进行跳转

JCXZ 是另一种 JMP 指令，但是它是一条不观察任何标志，或递减任何寄存器的指令。相反，JCXZ  观察 ECX 寄存器。当看到 ECX 变为零的时候，它跳转到指定的标签处。

大多数 JMP 指令有一些当控制标志不为真时进行跳转的搭档。当进位标志等于 1 时，JC 进行跳转。它的搭档，JNC ，当进位标志不是 1 时进行跳转。但是，JCXZ 是一条喜欢孤独的指令，不存在 JCXNZ 指令。



### 11.5.4 关闭内层循环

LOOP 观察 ECX 寄存器的状态，直到 ECX 寄存器变为 0 时关闭循环。

LOOPNZ 既观察 ECX 寄存器的状态，也观察零标志寄存器 ZF 的状态，只有当 ECX<>(不等于)0 并且 ZF = 0时，LOOPNZ 才会关闭循环。



只有显示完每行的 32 字符，即当bl 减为 0 时，跳出 LOOPNZ 循环，继续外层循环。



### 11.5.5 关闭外层循环

```asm
.DoLn: 
	mov bl,CHRTLEN         	  ; 每行将包含 32 个字符
.DoChr:
	stosb                     ; 注意，没有 REP 前缀
	jcxz ALLDone              ; 当整个序列被打印完毕，退出
	inc al                    ; 将 AL 中的字符值增大 1
	dec bl                    ; 将计数器的值减1
	Loopnz .DoChr             ; 回去并处理另外一个字符直到 BL 变为 0
```



JCXZ指令，当 ECX 变为 0 时，无论内存循环还是外层循环都执行完了，完整的 ASCII 表已被写入了 VidBuff。



### 11.5.6 Showchar 小节

使用不带 REP 前缀的 STOSB 指令，当每一个字符被发射到屏幕后，内存循环修改了 AL 中的，这使得每次 STOSB 发射时可以显示一个不同的字符。每当一行字符完成显示后，外层循环修改 EDI 寄存器(目标索引寄存器)的值。这使得我们能够将目标字符串分成 7 个独立的，非连续的行。



## 11.6 命令行参数和堆栈检查

在 Linux 控制台的命令提示符下启动一个程序时，我们可以选择在可执行程序的路径名之后包含任意合理数量的参数。例如：

```
$ ./showargs1 time for tacos
```

堆栈是命令行参数的存储位置。



### 11.6.1 两块虚拟内存

Linux 操作系统经常使用虚拟内存机制来管理计算机中的物理内存。虚拟内存从某一高度来看，它是这样工作的：Linux 可以拔出计算机物理内存系统中的任意一个区域，然后说，“你应该认为这块内存的第一个地址是 08048000H，并应据此对所有的内存进行相应的处理。”

这是一个谎言，但却是一个有益的谎言。程序可以自由使用 Linux 分配给它的内存块，并假定它是唯一使用该内存块的程序。其他程序可能会被赋予自己的“虚拟”内存块，并且可以与你的程序同时运行，而且它们之间都互不干涉。

这是真正奇怪的部分：每个获得内存块的程序都可能被告知，它的内存块地址从 08048000H 开始。即使对于同时的程序而言，也是这样。每个程序都认为，它运行在自己的小宇宙中，并且每个程序都自以为其内存地址开始于同一个地方。

远在后台，Linux 内核接受任意程序代码发出的每一个单独的内存寻址尝试，并将那个虚拟地址转换成 RAM 中的某处物理内存的地址。这涉及很多与物理内存表相关的工作，甚至(必要时)在硬盘驱动器上的存储位置"伪造" RAM 中的物理内存。但是底线是，程序将得到它自己的内存小宇宙，并且可以假定任意它拥有的内存真正为他自己所拥有。而那个内存在物理内存系统中的精确位置对于该程序而言，是不明确的，而且也不重要。

当程序开始运行时，Linux 实施他的虚拟内存魔术，为该程序的代码和数据预留内存区域。对于基于 X86 的 Linux 系统而言，这样的内存块总是始于 08048000H 处。从那里开始，它一路运行，一直到 0BFFFFFFFH(或附近的某个地方)；顶端地址并不总是相同的。现在，那是一个很大的内存：超过 3 GB。如果只安装了 2GB内存的话，Linux 将如何交给每个程序 3GB 的内存来运行？

很简单：在这 3GB 的虚拟地址空间中，并不是每一个虚拟地址都映射到物理地址上。事实上，一个 Linux 程序的虚拟地址被划分为两块，如图 11-3，较低的块始于 08048000H 并且包含程序的代码，以及在 .data 段 和 .bss 段中定义的数据。它只是本身实际需要的那么大，由代码和已定义的数据来决定。

较高的块可被认为几乎正好相反：它从高内存开始，并且一路向低内存运行。这个较高的块的地址并不总是相同的，但不能高于 0BFFFFFFFH。称为堆栈。



### 11.6.2 Linux 堆栈剖析

堆栈可能比你想象中的要大得多，也复杂得多。当 Linux 加载程序时，在开始执行程序的代码之前，它将大量的信息放到堆栈里。这包括正在运行的可持续文件的完全合法的路径，用户执行程序时输入的任何命令行参数以及 Linux 环境的当前状态，它是以文本配置字符串的集合，定义了 Linux 是如何配置的。

Linux 从高内存向低内存生成堆栈，从堆栈的底部开始，去往下面的内存。

* 存放在 ESP 中的是一个 32 位的数字，用于指出存放在堆栈上的命令行参数的个数。此值始终至少为1。
* 位于 ESP 上面的内存中下一个 32 位项是调用文本的地址，可执行文件通过它得到运行。该路径可能是完全路径。
* 该命令行参数的地址列表终止于一个空指针，这是 32 位的二进制 0 的术语。
* 从空指针上面的内存开始，是一个较长的 32 位地址列表。具体取决于特定的 Linux 系统，但是它可达近 200 个这些地址每一个都指向一个以空(null)为终止字符的字符串，每一个里面都转载着一个属于 Linux 环境的定义
* 在Linux 环境变量地址列表的末尾处，是另一个 32 位的空指针，它标志着堆栈“目录”的结束。除此之外，你还可以使用之前在堆栈中找到的地址来访问上内存中更远一些位置上的数据项。



### 11.6.3 为什么堆栈的地址是不可预测的

几年前，分配给一个正在运行的程序的虚拟空间的最高地址总是 0BFFFFFFFH，并且它总是堆栈的底部。从 Linux 内核的 2.6 版本开始，内核随机化了堆栈的界限。每次程序运行时，它的堆栈地址都会有所不同，通常相差数百万字节。此外，在地址列表的末尾和那些地址所指向的实际字符串数据的起始地址之间，还有一个可变数量的未使用的内存“垫料。”

这主要是为了防止 缓冲区溢出攻击，它可以强迫代码进入堆栈，使之作为数据存在，然后恶意软件就能够执行该行代码。这种执行取决于该恶意代码的硬编码内存地址(因为没有加载器来调整代码地址)，但是如果堆栈(几乎)从来没有在同一个地方出现两次，那么这个硬编码地址将不能工作，并且在堆栈上执行恶意代码会十分困难。

这就是 Linux 天生比那些较老的 Windows 版本(包括 XP 和 2000)更安全的诸多原因之一，后者的堆栈地址可以被很容易地猜到。



## 11.7 使用 SCASB 进行字符串搜索

由于每一个参数都以一个0字节结束，所以挑战很简单：我们需要寻找 0。这可以通过一种非常明显的方式来实现，在一个循环里从内存地址中读取一个字节，然后将计数器值递增以读取下一个字节之前，将该字节与 0 进行比较。好消息是，X86 指令集在一个字符串指令中就可以实现这样一个循环，该指令并不存储数据(如 STOSB)或复制数据(如 MOVSB)，取而代之的是，它能搜索内存以查找某一特定的数值。这条指令就是 SCASB (按字节扫描字符串)。

```asm
;  Executable name : SHOWARGS1
;  Version         : 1.0
;  Created date    : 4/17/2009
;  Last update     : 5/19/2009
;  Author          : Jeff Duntemann
;  Description     : A simple program in assembly for Linux, using NASM 2.05,
;    demonstrating the way to access command line arguments on the stack.
;
;  Build using these commands:
;    nasm -f elf -g -F stabs showargs1.asm
;    ld -o showargs1 showargs1.o
;

SECTION .data			; Section containing initialised data

	ErrMsg db "Terminated with error.",10
	ERRLEN equ $-ErrMsg
	
SECTION .bss			; Section containing uninitialized data	

; This program handles up to MAXARGS command-line arguments. Change the
; value of MAXARGS if you need to handle more arguments than the default 10.
; In essence we store pointers to the arguments in a 0-based array, with the
; first arg pointer at array element 0, the second at array element 1, etc.
; Ditto the arg lengths. Access the args and their lengths this way:
; 	Arg strings: 		[ArgPtrs + <index reg>*4]
;	Arg string lengths:	[ArgLens + <index reg>*4]
; Note that when the argument lengths are calculated, an EOL char (10h) is
; stored into each string where the terminating null was originally. This
; makes it easy to print out an argument using sys_write. This is not
; essential, and if you prefer to retain the 0-termination in the arguments, 
; you can comment out those lines as indicated.

	MAXARGS   equ  10	; Maximum # of args we support
	ArgCount: resd 1	; # of arguments passed to program
	ArgPtrs:  resd MAXARGS	; Table of pointers to arguments
	ArgLens:  resd MAXARGS	; Table of argument lengths

SECTION .text			; Section containing code

global 	_start			; Linker needs this to find the entry point!
	
_start:
	nop			; This no-op keeps gdb happy...

; Get the command line argument count off the stack and validate it:
	pop ecx 		; TOS contains the argument count
	cmp ecx,MAXARGS		; See if the arg count exceeds MAXARGS
	ja Error		; If so, exit with an error message
	mov dword [ArgCount],ecx ; Save arg count in memory variable

; Once we know how many args we have, a loop will pop them into ArgPtrs:
	xor edx,edx		; Zero a loop counter
SaveArgs:
	pop dword [ArgPtrs + edx*4]  ; Pop an arg into the memory table
	inc edx			; Bump the counter to the next argument
	cmp edx,ecx		; Is the counter = the argumemt count?
	jb SaveArgs		; If not, loop back and do another

; With the argument pointers stored in ArgPtrs, we calculate their lengths:
	xor eax,eax		; Searching for 0, so clear AL to 0
	xor ebx,ebx		; Pointer table offset starts at 0
ScanOne:
	mov ecx,0000ffffh	; Limit search to 65535 bytes max
	mov edi,dword [ArgPtrs+ebx*4] ; Put address of string to search in EDI
	mov edx,edi		; Copy starting address into EDX                                                                                                                                                                                                                                                                                                             
	cld			; Set search direction to up-memory
	repne scasb		; Search for null (0 char) in string at edi
; Comment out the following line if you need mull-terminated arguments:
	mov byte [edi-1],10	; Store an EOL where the null used to be
	sub edi,edx		; Subtract position of 0 from start address
	mov dword [ArgLens+ebx*4],edi	; Put length of arg into table
	inc ebx			; Add 1 to argument counter
	cmp ebx,[ArgCount]	; See if arg counter exceeds argument count
	jb ScanOne		; If not, loop back and do another one

; Display all arguments to stdout:
	xor esi,esi		; Start (for table addressing reasons) at 0
Showem:
	mov ecx,[ArgPtrs+esi*4]	; Pass offset of the message
	mov eax,4		; Specify sys_write call
	mov ebx,1		; Specify File Descriptor 1: Standard Output
	mov edx,[ArgLens+esi*4]	; Pass the length of the message
	int 80H			; Make kernel call
	inc esi			; Increment the argument counter
	cmp esi,[ArgCount]	; See if we've displayed all the arguments
	jb Showem		; If not, loop back and do another
	jmp Exit		; We're done! Let's pack it in!

Error: 	mov eax,4		; Specify sys_write call
	mov ebx,1		; Specify File Descriptor 2: Standard Error
	mov ecx,ErrMsg		; Pass offset of the error message
	mov edx,ERRLEN		; Pass the length of the message
	int 80H			; Make kernel call

Exit:	mov eax,1		; Code for Exit Syscall
	mov ebx,0		; Return a code of zero	
	int 80H			; Make kernel call
```

showargs1 程序首先从堆栈中弹出参数数量到 ECX 中，如果不超过 MAXARGS 中的值，那么 ECX 中的计数值就被用于管理一个循环，该循环将参数本身的地址弹出到双字表 ArgPtrs 中。

REPNE SCASB 指令用来查找每个参数结尾的 0 字节。设置 SCASB 与设置 STOSB 大致相同：

* 对于"上内存"搜索，使用 CLD 指令确保方向标志 DF 被清除
* 将要进行搜索的字符串的第一个字节的地址放入 EDI 中，在这里，它是一个堆栈上的命令行参数的地址。
* 即将被查找的值放入 AL 中(这里，它是 0)
* 将最大计数值放入 ECX 中。这样，如果我们查找的字节实际不在那里的话，就可以在内存中搜索过远的范围了。

REPNE SCASB  创建一个紧密循环，在每一轮循环中，[EDI] 处的字节都与 AL 中的值进行比较。如果相等，则循环结束，REPNE SCASB 停止执行。如果不相等，则 EDI 被递增 1，ECX 被递减 1，继续循环，测试另一个位于[EDI] 处的字节。

当 REPNE SCASB 找到 AL 中的字符并结束后，EDI 将指向字符串中那个被搜到的字符后面位置的字符。要想访问找到的字符，必须从 EDI 中减去 1

mov byte [edi-1],10         ; 在 null 曾经存在的位置存储一个 EOL



### 11.7.1 REPNE v.s. REPE

REPNE ： 查找与 AL 中的值相匹配的字节时

REPE：查找与 AL 中的值不匹配的字节时



REPNE SCASB 可以由两种原因结束：

1. 找到了与 AL 中的值匹配的字节。
2. 计数 ECX 已经减少到 0。

有一种侥幸的可能性：即 ECX 刚好递减到零时，[EDI] 中包含与 AL 中的值相匹配的字节。

每次 SCASB “射击”时，它都做一次比较，该比较或者设置零标志 ZF 或者 将其清零。当 REPNE 指令的比较将 ZF 设置为 1 时，该指令将会结束。当 REPE 指令的比较操作将 ZF 设置为 0 时，该指令将会结束。要想确保绝对捕获搜索失败的结果，我们必须在 SCASB 指令结束后立即测试 ZF

对于 REPNE SCASB  使用 JNZ

对于 REPE SCASB 使用 JZ



### 11.7.2 从堆栈中弹出，还是对堆栈寻址

这有一个问题：是将数据从堆栈中弹出到寄存器或者变量中这种方式好一些？还是通过内存引用来访问存储在堆栈中的数据，将数据本身留在原地好一些呢？

另一方面，从堆栈中弹出数据，它就不在堆栈上了，因为 ESP 已经向上内存的方向移动了数据项大小那么远，当有数据压入堆栈时，最近一次弹出的数据，它在堆栈上的位置就被覆盖了。

在大多数应用中，一个更好的方法是：只要程序一开始运行，就将 ESP 复制到一个 32 位的指针寄存器中，创建一个不变的堆栈指针的副本，完成这件事的一个不错选择是 EBP。BP 最初被设计用来做的事情就是保存堆栈指针，从而使以后 “非破坏性的”堆栈数据寻址不会因为堆栈操作而变得更加困难。



如果我们将 EBX 寄存器用作一个基于 0 的参数计数器，那么任意给定参数的地址可以这样计数：

```
[EBP + 4 + EBX*4]
```



### 11.7.3 额外的学分

重写 showargs2.asm，让它能够显示出 Linux 环境变量的完整列表，而不是只是显示程序的命令行参数。

```asm
; 可执行文件        : showargs1
; 版本              : 1.0
; 创建日期          : 27/6/2021
; 最后更新日期      : 27/6/2021
; 作者              : wangjun
; 描述              : 一个用汇编语言编写的运行在 Linux 下的简单程序，使用 NASM 2.13.02，
;                     演示了访问堆栈中的数据，打印 Linux 环境变了的完整列表。
; 
; 使用这些命令生成:
; nasm -f elf -g -F DWARF showargs1
; ld -m elf_i386 -o showargs1 showargs1.o
;

SECTION .data       ; 包含已经初始化数据的段
    ErrMsg db "Terminated with error.",10
    ERRLEN equ $-ErrMsg

SECTION .bss        ; 包含未初始化数据的段

; 从本质上讲，我们将参数的指针保存到一个基于 0 的数组中，
; 第一个参数指针是数组的第 0 号元素
; 第二个参数是数组的第 1 个元素，等等。
; 访问参数及其长度的方式是这样的:
;       参数字符串：[ArgPtrs + <index reg>*4]
;       参数字符串的长度：[ArgLens + <index reg>*4]
; 注意，当计算出参数长度之后，一个 EOL 字符(10h)被存放到每个字符串中的原本是空终止的地方。这使得通过
; sys_write 打印一个参数变得非常容易。
; 这不是必要的，如果喜欢在参数中保留 0 终止的话，你就可以注释掉该行
; 记住，如果在结尾处没有 EOL 字符，参数就不会正确地显示。

    MAXARGS equ 10           ; 我们最多支持 10 个参数
    ArgCount: resd 1         ; 传递给程序的参数的个数
    ArgPtrs: resd MAXARGS    ; 参数指针表
    ArgLens: resd MAXARGS    ; 参数长度表

SECTION .text                ; 包含代码的段

global _start

_start:
    nop                      ; 这个空操作让 gdb 非常高兴
    mov ecx,[esp]            ; 将初始堆栈指针的值保存到 EBP 中
    lea ebp,[esp+ecx*4+8]    ; 定位到 环境变量1 的地址
    xor ebx,ebx              ; 堆栈地址偏移从 0 开始
    xor eax,eax              ; 我们要查找 0，所以将 AL 清零
Scan:
    cmp dword [ebp+ebx*4],0000H    ; 判断是否到空指针区域
    je Showem
    mov ecx,0000ffffH        ; 将查找限制在最多 65535 个字节之内
    mov edi,dword [ebp + ebx*4]        ; 将要搜索的字符串地址放入 EDI
    mov edx,edi                        ; 将起始地址复制到 edx 中
    cld                                ; 将查找方向，沿着地址增大的方向
    repne scasb                        ; 在 edi 中的字符串中查找null (0 字符)
    jnz Error                          ; REPNE SCASB 以没有找到 AL 中的值而结束
    mov byte [edi-1],10                ; 在 null 曾经存在的地方放入一个 EOL 字符
    sub edi,edx                        ; 从开始地址减去起始地址，得到字符个数
    mov dword [ArgLens +ebx*4],edi     ; 将参数的长度加入表中
    inc ebx                            ; 将参数计数器加 1
    jmp Scan


; 将所有的参数显示到标准输出
    xor esi,esi              ; 从零开始(出于寻址的原因)
    mov dword [ArgLens],ebx
    

Showem:
    mov ecx,[ebp+esi*4]             ; 传递消息的偏移量
    mov eax,4                       ; 指定 sys_write 调用
    mov ebx,1                       ; 指定文件描述符1：标准输出
    mov edx,[ArgLens + esi*4]       ; 传递消息长度
    int 80H                         ; 进行内核调用
    inc esi                         ; 递增参数计数器
    cmp esi,dword [ArgLens]         ; 判断以下参数计数器是否超过了参数个数
    jb Showem                       ; 如果没有，回去继续循环，进行另一轮处理
    jmp Exit                        ; 正常退出

Error:
    mov eax,4                ; 指定 sys_write 调用
    mov ebx,1                ; 指定文件描述符2：标准错误
    mov ecx,ErrMsg           ; 传递错误消息的偏移地址
    mov edx,ERRLEN           ; 传递错误消息的长度
    int 80H                  ; 进行内核调用

Exit:
    mov eax,1                ; 退出系统调用的代码
    mov ebx,0                ; 返回一个零代码
    int 80H                  ; 进行内核调用
```



# 第 12 章 C 语言 调用 C 语言编写的外部函数

几乎所有针对 Linux 的，不涉及诸如 Perl 或 Python 之类的解释语言的编程示例都是 C 编写的。**最重要的是，C 运行时库包含了很多非常有用的函数，但是在调用这些函数时我们需要学习 C 协议。**



## 12.1 什么是 GNU

早在 70 年代末期，一个名叫理查德 托斯曼的狂妄的 Unix 黑客希望拥有自己的 Unix 副本，后来，他编写了自己的版本。理查德 托斯曼将他的 Unix 版本命名为 Unix 。他创立了自由软件基金会作为 GNU 工具开发的大本营，还有一个激进的软件许可协议，名为 GNU 公共许可(GPL)，有时被非正式地称为“开放版权”。托斯曼在 GPL 下发布了 GNU 工具，这不仅需要该软件是免费的(包括所有的源代码)，而且阻止人们对该软件作了轻微的修改便将其衍生作品称为自己所有。修改和改进都必须归还给 GUN 社区。

在这种潮流中，Linux 诞生了，Linux 采用 GNU 工具集构建和维护。



### 12.1.1 “瑞士军刀” 编译器

托斯曼的“遗产”主要包含在 GNU 编译器系列。这类“遗产”很多，但现在必须竭尽全力去了解的应该是 GNU 的 C 编译器: gcc。(Unix 世界有点盲目崇拜小写字母)

在使用汇编语言工作时为什么要用到 C 编译器呢？主要是这样：gcc 所做的事情不仅限于简单地编译 C 代码。它是瑞士军刀式的开放工具。事实上，将它所做的事情描述为生成软件而不仅仅是编译软件，会更为恰当些。除了将 C 代码编译为目标代码之外，gcc 既管理编译步骤，又管理连接步骤。

gcc 使用 gas 来编译生成的汇编代码，使用 GNU ld 来连接代码。



### 12.1.2 以 GNU 的方式生成代码

gcc 在做的所有的工作，但实际上 gcc 真正做的事情是作为几种 GNU 工具的主控制器，监督除了你特别想看的之外的，根本不需观察的代码装配线。

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-30 上午11.15.44.png" alt="截屏2021-06-30 上午11.15.44" style="zoom:67%;" />



程序员通常在终端窗口中通过 shell 命令行调用 gcc。gcc 接管了系统控制之后，立即调用了一个名为 c 预处理器的实用工具：cpp。预处理器获得了最初的 c 源代码文件，并处理某些诸如 #include 和 #define 之类的项。

每当 cpp 完成它的工作后，gcc 会认真地接管过来。gcc 从预处理 c 源代码文件生成一个 .s 为扩展名的汇编语言源代码文件。以人类可读的形式来看，它几乎是与原来的 .c 文件中的 C 语句相等的汇编代码。

当 gcc 已经完全生成了与 C 源代码文件相等的汇编语言文件后，它调用 GNU 汇编编译器，gas，将 .s 文件编译为目标代码文件。然后这个目标代码文件被写入到一个 .o 为扩展名的文件中。

最后一步涉及连接器: ld。.o 文件包含二进制代码，这只是从最初的 .c 文件生成的二进制代码。该 .o 文件不包含来自在 C 编程中非常重要的标准 C 函数库代码。这些库已经被编译好，只有在需要时才连接到应用程序中。连接器 ld 在 gcc 的指导下完成这项工作。好的部分：gcc 能够清楚地知道应用程序需要连接到哪些标准的 C 函数库才能工作，并且它始终包括正确版本中的正确的库。虽然 gcc 并没有做实际的连接工作，但是它知道需要连接什么——随着程序变得越来越复杂，这一点确实很有价值。

在行的结尾，ld 给出了充分连接的，可执行的程序文件。此刻，生成工作已经完成，gcc 将控制返回给 Linux shell。



### 12.1.3 如果在汇编工作中使用 gcc

我们需要的是 gcc 在连接方面的专长，因而首先使用 NASM 生成一个包含二进制目标代码的 .o 文件：

```asm
nasm -f elf -g -F DWARF hello.asm
```

我们调用 gcc 来连接程序。

```
gcc -m32 hello.o -o hello 
```

该命令显示的唯一输入文件是一个名为 .o 的包含目标代码的文件，告诉 gcc 所有需要做的事情就是将该文件与 C 运行时库连接，产生最后的可执行程序。-o hello 部分告诉 gcc，最终的可执行文件的名称为 "hello"



### 12.1.4 为什么不用 gas

GNU 汇编编译器 gas 使用一种特殊的语法，它与所有在 X86 世界里使用的其他我们熟悉的汇编编译器完全不同，这就是 AT&T 的语法，创建一种可移植式汇编表示法，目的是使 Unix 系统能够更加容易地由一种底层 CPU 移植到另外一种上。



## 12.2 连接到标准的 C 库函数

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-07-03%20%E4%B8%8A%E5%8D%889.43.06.png" alt="截屏2021-07-03 上午9.43.06" style="zoom:67%;" />



启动代码像调用过程一样(通过 CALL 指令)调用你的程序，而你的程序则通过 RET 指令将控制返回给 C 代码库。从技术上讲，程序是一个过程。当汇编语言程序通过 RET 指令将控制返回给吊椅哦那个它的程序时，关闭代码开始执行，实际上，正是关闭代码通过必要的 INT 80H 内核调用，将控制权返回给 Linux。

在此期间，想做多少对 glibc 的调用都可以。当使用 gcc 连接你的程序时，你所调用的包含 C 库例程的代码被连接到程序中。一定要注意，启动，关闭代码以及所有用于库调用的代码实际上存在于 gcc 生成的可执行文件中。



### 12.2.1 C 调用公约

glibc 并不是唯独挑出汇编语言程序来特殊对待的。纯粹的 C 程序也以相同的方式工作，这就是为什么 C 程序的主程序部分被称为主函数饿原因。它的确是一个函数，标准的 C 库代码调用通过一条 CALL 指令来调用它，然后它执行 RET 指令将控制返回给标准 C 代码库。

* 过程(这是 C 调用函数的更为通用的术语)必须保存 EBX，ESP，EBP，ESI和EDI这些32位寄存器，这些寄存器必须与调用之前相同。
* 如果返回值是 32 位或者更小位数，这些值将被返回到 EAX 中。如果是 64 位整数值，则返回到 EDX 和 EAX 中，其中低 32 位放到 EDX 中，高 32 位放在 EAX 中。如果是浮点型返回值，则返回到浮点堆栈的顶部。如果是字符串，结构或者其他位数大于 32 位的数据项，则通过引用返回，即该过程返回一个指向它们的 32 位指针到 EAX 中。
* 传递给程序的参数被以相反的顺序压入堆栈中。例如，给定 MyFunc(foo, bar, bas)，则 bas 被第一个压入堆栈，bar 第二个压入堆栈，foo 第三个压入堆栈。
* 过程本身并不从堆栈中移除参数。主调程序必须在过程返回之后做这件事情。最常见的方法是向堆栈指针寄存器 ESP 上添加一个偏移地址。
* 命名汇编程序的起始点的标签必须是"main:"，而不是 "start:"，而且"main:"必须被声明为全局的。



### 12.2.2 建立一个框架

对于每一个连接到 glibc(或连接到几乎任何其他用 c 编写的函数库)的程序而言，其开始处和结束处的代码完全一样。

```asm
;  Source name     : BOILER.ASM
;  Executable name : BOILER -- though this isn't intended to be run!
;  Version         : 2.0
;  Created date    : 10/1/1999
;  Last update     : 5/26/2009
;  Author          : Jeff Duntemann
;  Description     : A "skeleton" program in assembly for Linux, using NASM 2.05,
;	demonstrating the necessary code to preserve and restore EBP, EBX, ESI,
;	and EDI. The program does nothing and is provided as boilerplate for
;	assembly projects that link to functions written in C.
;
;  Build using these commands:
;    nasm -f elf -g -F stabs boiler.asm
;    gcc boiler.o -o boiler


[SECTION .data]			; Section containing initialised data
	
[SECTION .bss]			; Section containing uninitialized data


[SECTION .text]			; Section containing code
					
global main			; Required so linker can find entry point
extern puts
	
main:
  push ebp		; Set up stack frame for debugger
	mov ebp,esp
	push ebx		; Program must preserve ebp, ebx, esi, & edi
	push esi
	push edi
	;;; Everything before this is boilerplate; use it for all ordinary apps!	


	;;; Everything after this is boilerplate; use it for all ordinary apps!
	pop edi			; Restore saved registers
	pop esi
	pop ebx
	mov esp,ebp		; Destroy stack frame before returning
	pop ebp
	ret			; Return control to Linux

```



### 12.2.3 保存和恢复寄存器

连接到 C 函数的 Linux 应用程序不能更改的寄存器由 EBX，ESP，EBP，ESI和EDI。当程序开始时，boiler.asm 将这些寄存器保存到堆栈中，然后在将控制返回到 Linux 之前再回复他们。

而其他寄存器，就有可能被修改。即当调用其他人编写的过程时，那些过程可能会改变 EAX, ECX和 EDX 中的值。



### 12.2.4 建立堆栈帧

在 Linux 上承担汇编语言编译工作的编译机制是堆栈帧机制。编译器依赖堆栈帧来常见函数的局部变量，虽然堆栈帧在纯粹的汇编工作中的用处很小，但是如果想调用某种高级语言编译器编写的函数，就必须了解。

堆栈帧是堆栈上一个属于某一特定函数的位置，它基本上是指包含在两个寄存器——基址指针寄存器 EBP 和堆栈指针 ESP 寄存器之间的位置。如下图所示：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-07-03%20%E4%B8%8A%E5%8D%8810.25.18.png" alt="截屏2021-07-03 上午10.25.18" style="zoom: 50%;" />



堆栈帧是通过将主调程序的 EBP 寄存器的副本压入堆栈以将其保存，然后将主调程序的堆栈指针寄存器 EBP 拷贝到寄存器 EBP 来创建的。任何履行了 C 调用公约的汇编程序的前两条指令都必须是这些：

```asm
push ebp
mov ebp,esp
```

在此之后应该不去干预 EBP，或者在紧要时刻必须使用它， 在任何违背 C 库假设的改变之前，必须确保能够恢复它。(强烈建议不干预它)。EBP 被认为是新堆栈帧的锚。在堆栈帧之上(即在更高的地址)将会存储一些往往需要在代码中引用的内容，EBP 是引用它们的唯一安全方法。

一个不太明显的事实，EBP 也是一个能够藏匿主调程序的堆栈指针值(ESP)的“小洞”。这也是你一旦建立了堆栈帧就不能改变 EBP 值的另外一个理由。

一旦 ESP 被作为堆栈帧的一端而安全地锚定后，堆栈指针寄存器 ESP 就可以根据需要自由地上下移动了。但是，需要做的第一件事是将主调程序的 EBX，ESI 和 EDI 的值放入堆栈。当堆栈帧在程序结尾被销毁时，他们被从堆栈中弹回到主调程序(在上面的例子中，它是来自标准 C 库的启动/关闭代码)，他们的值与当启动代码将你的程序作为 main 函数调用时的值相同。

一旦 EBX，ESI和EDI 已经就位，你就可以把任何需要暂存的内容压入和弹出堆栈了。



### 12.2.5 销毁堆栈帧

在过程结束之前，它们的堆栈帧必须被销毁。所有留在堆栈中的值应该是主调程序的 EBP，EBX，ESI和EDI的值。从根本上来讲，如果 EDI 是我们必须保存到堆栈上的最后一个值，那么 ESI(堆栈指针寄存器)的值最好指向那个保存的 EDI值，否则会有麻烦。

一旦清理干净堆栈，为了销毁堆栈帧，我们必须首先将主调程序的寄存器值弹回到相应的寄存器中，一定要确保这些弹出操作采用正确的顺序。最后将主调程序的 EBP 值弹出堆栈

```
mov esp,ebp
pop ebp
```

就这样，堆栈帧消失了，堆栈和神圣的寄存器现在和启动代码将控制权交给我们的程序时处于同一状态。现在可以安全地执行将控制权发送给 C 库关闭代码的 RET 指令了。



### 12.2.6 通过 puts() 输出字符

glibc 中最简单的有用函数是 puts()，它能够向标准输出发送字符。而汇编语言中调用 puts() 非常简单，仅需 3 行代码即可实现。

```
;  Source name     : BOILER.ASM
;  Executable name : BOILER -- though this isn't intended to be run!
;  Version         : 2.0
;  Created date    : 10/1/1999
;  Last update     : 5/26/2009
;  Author          : Jeff Duntemann
;  Description     : A "skeleton" program in assembly for Linux, using NASM 2.05,
;	demonstrating the necessary code to preserve and restore EBP, EBX, ESI,
;	and EDI. The program does nothing and is provided as boilerplate for
;	assembly projects that link to functions written in C.
;
;  Build using these commands:
;    nasm -f elf -g -F stabs boiler.asm
;    gcc boiler.o -o boiler


[SECTION .data]			; Section containing initialised data
HelloWorld: db "hello world",0
	
[SECTION .bss]			; Section containing uninitialized data


[SECTION .text]			; Section containing code
					
global main			; Required so linker can find entry point
extern puts
	
main:
    push ebp		; Set up stack frame for debugger
	mov ebp,esp
	push ebx		; Program must preserve ebp, ebx, esi, & edi
	push esi
	push edi
	;;; Everything before this is boilerplate; use it for all ordinary apps!	
    push HelloWorld
    call puts
    add esp,4



	
	;;; Everything after this is boilerplate; use it for all ordinary apps!
	pop edi			; Restore saved registers
	pop esi
	pop ebx
	mov esp,ebp		; Destroy stack frame before returning
	pop ebp
	ret			; Return control to Linux
```



## 12.3 使用 printf() 格式化文本输出

puts 只能发送一个简单的文本字符串到一个文件(默认情况下，标准输出)，更糟糕的是，puts()始终在它的显示的内容的结尾包含一个 EOL 字符，无论在字符串数据中是否包含更多字符。

几乎所有的字符串输出需求，我们最好使用一个功能更为强大的库函数——printf()。printf()函数使我们仅仅使用一个函数调用就能完成很多真正有用的事情:

* 输出带有终止字符 EOL 的文本或者不带终止字符 EOL 的文本。
* 在输出数值型数据时，通过指定格式化代码，可将其转换成各种数字格式的文本。
* 输出文件到一个包含多个分别存储的字符串文件。

例如，以下格式化字符串：

"I am %d years old."

%d 告诉 printf() 有一个符号整数值需要被转换为文本，并且用该文本替换基字符串中相应的格式化文本。如果传递的是 12，那么字符串将是：

"I am 12 years old."

| 格式化代码 | 基字符串 | 描述                               |
| ---------- | -------- | ---------------------------------- |
| %c         | n/a      | 输出单个字符                       |
| %s         | n/a      | 输出字符串                         |
| %x         | 16       | 转换一个整数，并将其以十六进制显示 |
| %%         | n/a      | 显示一个百分号符号                 |
| %d         | 10       | 转换一个整数，并将其以十进制显示   |

我们还可以在 '%'和代码字母之间放一个整数值：`%5d`此代码告诉 printf()，右对齐显示一个 5 个字符宽的值。如过这个值没有包含宽度值，那么 printf() 将按它的实际宽度来显示它。



### 向printf 传递参数

printf() 函数调用方法如下：

`printf("I am %d years old",23);` 该函数的参数有两个，分别为23,"I am %d years old"。将参数从右到左依次压入堆栈中

```
push 23
push Msg
call printf
add esp,8
```



需要记住以下三个关键方面：

* 参数被由右至左压入堆栈。
* 调用 printf() 之后，必须将 ESP 与压入的所有参数的字节总数相加。
* printf(()能够破坏除了神圣寄存器之外的一切内容。 
* 小心地使用每一个神圣寄存器(ESI，EDI或者 EBX 寄存器)，显然，不要尝试使用 ESP或EBP

我们应该小心地确保所有字符串参数都正确地以一个二进制 0 终止，这是唯一一种告诉 puts() 和 printf() 之类的 glibc 函数知道字符串从哪里结束。



## 12.4 使用 fgets() 和 scanf() 进行数据输入

gets() 可以输入字符串，但它是危险的函数，因为它不能控制输入的字符，当输入的字符大于缓冲区的大小时，将会导致缓冲区溢出。fgets() 的好处是可以指定接收字符的个数。

下面是 fgets() 函数的使用方法：

1. 在程序段的顶部声明 extern fgets 和 extern stdin。
2. 在程序的 .bss 段通过使用 RESB 指令在程序的 .bss 段声明一个足够大的缓冲区为变量，以确保你想让用户输入的字符串数据。
3. 为了调用 fgets ，首先将文件句柄压入堆栈，必须压入句柄本省，而不是句柄的地址，因此使用这种格式：`push dword [stdin]`
4. 把用于指明想要 fgets() 接收的最大字符数的值压入堆栈。一定要确保它不比你在 .bss 段中定义的缓冲区变量大。
5. 把 fgets() 即将用于存储用户输入字符的缓冲区变量的地址压入堆栈。
6. 调用 fgets 本省。
7. 清理堆栈

```
push dword [stdin]          ; 将标准输入的文件句柄压入堆栈
push 100                    ; 从键盘接收不多于 100 个字符
push MyStr                  ; 用于存放字符的缓冲区的地址
call fgets                  ; 调用 fgets
add esp,12                  ; 清理堆栈
push MyStr                  ; 将打算输出的字符串地址压入堆栈
push testStr                ; 将格式化字符串压入堆栈
call printf                 ; 调用 printf
add esp,8                   ; 清理堆栈
```



### 使用 scanf() 输入数字值

scanf() 函数从键盘上接收字符数据流，并将其转换为数字数据，存储在数字型变量中。一个典型的 scanf() 调用代码是这样的:

```asm
push IntVal       ; 将整形缓冲区的地址压入堆栈
push Iformat      ; 将整形格式化字符串的地址压入堆栈
call scanf        ; 调用 scanf 来输入数字数据
add esp,8         ; 清理堆栈
```

注意：如果用户输入代表一个数字值的 ASCII 太大，以至于无法包含在一个 32 位整数中，或者输入了某些不能代表一个数字值的字符混合物，scanf() 函数将返回给程序的值将是一个垃圾值。



## 12.5 驾驭时间

标准 C 库包含了一组数量众多的能够操作如期和时间的函数。



### 12.5.1 C 库的时间机制

在标准 C 库内部深处的某个地方，有一个代码块，当被调用时，该代码块能够查看计算机的实时时钟，读取当前的日期和时间，并将其转换为一个标准的 32 位无符号整数值。这个值(理论上来讲)是已经在(始于 1970年 1 月 1 日 00:00:00 通用时间的)"Unix 时代"度过的秒数。每度过一秒，该值就会加 1。当通过 C 库读取当前时间或日期，我们检索的是这个数字的当前值。

这个数字叫做 time_t。time_t 值于世界标准时间(UTC)2001 年 9 月 9 日上午 07 时 46分 40秒翻转到了 10 位(自1970年 1 月 1 日 00:00:00 以来的 10亿秒 ) 。在不久的将来暂时还没有千年虫式的危险，但是在 2038 年 1 月 19 日上午 03 点 14 分 07 秒，将 time_t 作为一个有符号整数处理的计算机将会看到它翻转到 0，因为一个 32 位有符号整数能够表达的最大量是 2147483647。

当 32 位不足以表示当前时间时，就使用 64 位来表示。那将推迟到 292 亿年之后。

另一种由标准 C 库实现的标准数据类型要更有用些: tm 结构，它是一组 9 个 32 位的数字值，分别以不同的有用块来表达当前时间和日期。在 Linux 中，它更像是一个数组，因为它们连续，且类型相同。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-07-03%20%E4%B8%8B%E5%8D%884.44.11.png" alt="截屏2021-07-03 下午4.44.11" style="zoom:67%;" />



有些 C 函数能够将 time_t 值转换为 tm 值，并能再转换回来。



### 12.5.2 从系统时钟中取出 time_t 值

通过 time() 函数实现

```asm
push dword 0       ; 将一个 32 位空指针压入堆栈，我们不需要缓冲区
call time          ; 将日期值返回到 eax 中
add esp,byte 4     ; 为一个参数清理堆栈
mov [oldtime],eax  ; 将时间值保存到内存变量中
```

如果要把 time_t 值存储到缓冲区中，需要传递指向缓冲区的指针。如果不想将 time_t 值存储到缓冲区中，必须在堆栈上给他传递一个空指针。

### 12.5.3 将 time_t 值转换为一个格式化字符串

使用 ctime() 将 time_t 值转换为如下字符串：该字符串指针指向一个埋藏在运行时库深处的字符串指针。

Wed June 3 12:13:21 2009

调用方法:

```
push OldTime     ; 将日历时间值的地址压入堆栈
call ctime       ; 返回一个指向 ASCII 时间字符串的指针到 EAX 中 
add esp,4        ; 为一个参数进行堆栈清理
```

注意，传递的是 time_t 的地址，而不是 time_t 值本身。为了扩展上的灵活性。



### 12.5.4 生成单独的本地时间值

使用 localtime()，可以将组成日期和时间的各个部分分割为单独的值，以便我们单独使用它们。

```
push OldTime      ; 将日历时间的地址压入堆栈
call localtime    ; 返回指向静态时间结构的指针到 EAX 中
add esp,4         ; 为 1 个参数清理堆栈
```

得到静态时间结构的指针后，通过偏移量就可以访问特定的字段。例如，下列代码获取年字段的偏移量:

```
mov edx, dword [eax+20]   ; 年份的值在 tm 中的偏移量是 20 个字节
push edx                  ; 将该值压入堆栈
push yrmsg                ; 将基字符串的地址压入堆栈
call printf               ; 用 printf 显示字符串和年份值
add esp,byte 8            ; 堆栈清理
```



### 12.5.5 通过使用 MOVSD 复制 glibc 的 tm 结构

有时保存一份单独的 tm 结构的副本会很方便，尤其是当我们一次需要处理几个日期/时间值时。

需要借助 REP MOVSD(Repeat Move String Double) 指令。借助该指令，将被复制的数据——放入 ESI 中，将目标位置的指针放入 EDI 中，将被移动的项的数量放入 ECX 中，然后，确保方向标志 DF 被清零，并执行 REP MOVSD

```
mov esi,eax           ; 将静态 tm 的地址从 EAX 复制到 ESI 中
mov edi,tmcopy        ; 将本地 tm 的副本的地址放入 edi 中
mov ecx,9             ; 在 Linux 下，一个 tm 结构的大小是 9 个双字
cld                   ; 将 DF 清零
rep movsd
```

上述功能，我们将 C 库的 tm 结构移到一个在程序的 .bss 段中分配的缓冲区中。分配方式如下：

```
TmCopy resd 9         ; 为时间结构 tm 保留 9 个 32 位字段
```

其他系统，time_t 值已经有了不同于 32 位整数值的其他定义。这里，glibc 将 time_t 定义为一个 32 位整数。对于其他的非 GNU 实现的 Unix，最好使用 C 库函数 difftime() 来返回两个 time_t 值之间的差值。



## 12.6 理解 AT&T 指令助记符

为了理解 gcc 编译器和标准 C 库，最好了解下 AT&T。



### 12.6.1 AT&T 助记符公约

* **AT&T 助记符和寄存器名称总是采用小写形式。**
* 寄存器名称总是以百分比符号 % 开头。每一个具有操作数的 AT&T 机器指令都有一个表明其操作数尺寸的单字符后缀。后缀字母有 b, w和l。表明字节(8位)，字(16 位)，或更长的 (32位)。
* **在 AT&T 语法中，源操作数和目标操作数存放的顺序刚好与英特尔语法相反。**
* 在 AT&T语法中，立即数操作数前面总是带有一个美元符号($)。
* 并非所有的 AT&T 指令助记符都由 gcc 产生。与 Intel 的 JCXZ , JECXZ, LOOP, LOOPZ, LOOPE, LOOPNZ 和 LOOPNE 等值的相关指令只是最近才被添加到 AT&T 助记符集合中，gcc 从来不产生需要用到它们的代码。
* 在 AT&T 语法中，内存引用中的位移是有符号量，放在包含基址，索引和缩放比例值的括号外面。



### 12.6.2 查看 gcc 常见 gas 源文件

使用下列命令生成 .s 汇编文件

```
gcc dateis.c -S
```

现有一个 .c 文件 dateis.c

```
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

int main()
  {
    time_t timeval;
    
    (void)time(&timeval);
    printf("The date is: %s", ctime(&timeval));
    exit(0);
  }
```

现在将它编译为 .s 文件 `gcc -S dateis.c`

dateis.c

```
	.file	"dateis.c"
	.text
	.section	.rodata
.LC0:
	.string	"The date is: %s"
	.text
	.globl	main
	.type	main, @function
main:
.LFB5:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp            ; sub rsp,16
	movq	%fs:40, %rax         
	movq	%rax, -8(%rbp)
	xorl	%eax, %eax
	leaq	-16(%rbp), %rax       ; lea rax, rbp-16
	movq	%rax, %rdi
	call	time@PLT
	leaq	-16(%rbp), %rax
	movq	%rax, %rdi
	call	ctime@PLT
	movq	%rax, %rsi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax           
	call	printf@PLT
	movl	$0, %edi
	call	exit@PLT
	.cfi_endproc
.LFE5:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0"
	.section	.note.GNU-stack,"",@progbits
```



* 当被引用时，消息字符串的名称带有一个美元标志($)前缀，就像立即数一样。而在 NASM 中，一个已命名的字符串变量则被认为是一个变量而不是立即值
* 在 AT&T 中，注释是 '#' 开始的一行



### 12.6.3 内存引用语法

在 Intel 助记符中，引用一个内存位置可以通过将该位置放在方括号内部来实现，例如：

```
mov ax,dword [ebp]
```

更为复杂的寻址如下：

```
mov eax,dword [ebx-4]         ; 基址减去位移量
mov al, byte [bx+di+28]				; 基址加上索引加上位移量
mov al,byte [bx+di*4]         ; 基址加上索引乘以缩放比例
```



而在 AT&T 助记符中，则很大不同

```
movb (%ebx), %al         # mov byte al,[ebx]  在 Intel 语法中
```

如果存在基址，索引，缩放比例，则将它们放到括号内，如果有一个位移的话，该位移必须放在小括号的前面，并且放在小括号的外面：

```
movl -4(%ebx),%eax       # mov dword eax, [ebx-4]  在 Intel 语法中
movb 28(%ebx,%edi),%eax  # mov byte eax, [ebx+edi+28] 在 Intel 语法中
```

AT&T 内存引用架构如下

+- disp(base,index,scale)



## 12.7 产生随机数

研究表明，没有任何可证明的方式能够严格从软件产生真正的随机性以及随机数。从理论上，要想实现真正的随机，你的确需要从某种量子现象中获得一些触发机制(放射现象是最经常提及的)。但是，由于缺乏一个核动力随机数产生器，我们将退而求其次，选择伪随机数。



标准 C 库包含两个与伪随机数相关的函数：

* srand() 函数传递一个新的种子值给随机数生成器。该值必须是一个 32 位整数。如果没有传递种子值，则该值默认为 1。
  * rand() 函数返回一个 31 位的随机数。最高位一直为 0，因此，如果作为 32 位有符号整数处理的话，该值始终为正。



### 12.7.1 利用 srand() 为随机生成器“播种”

```
push 0            ; 将一个 32 位空指针压入堆栈，因为不需要将时间保存到缓冲区中
call time         ; 返回 time_t 值(一个 32 位整数)到 eax 
add esp,4         ; 清理堆栈
push eax          ; 将 eax 中的时间值压入堆栈
call srand        ; 时间值就是随机生成器的种子
add esp,4         ; 清理堆栈
```



### 12.7.2 产生伪随机数

```asm
;  Source name     : RANDTEST.ASM
;  Executable name : RANDTEST
;  Version         : 2.0
;  Created date    : 12/1/1999
;  Last update     : 5/22/2009
;  Author          : Jeff Duntemann
;  Description     : A demo of Unix rand & srand using NASM 2.05
;
;  Build using these commands:
;    nasm -f elf -g -F stabs randtest.asm
;    gcc randtest.o -o randtest
;

[SECTION .data]			; Section containing initialised data

Pulls	   dd 36		;  How many numbers do we pull?
Display    db 10,'Here is an array of %d %d-bit random numbners:',10,0
ShowArray  db '%10d %10d %10d %10d %10d %10d',10,0		
CharTbl db '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-@'

[SECTION .bss]		; Section containing uninitialized data

BUFSIZE  equ 70		; # of randomly chosen chars
RandVal  resd 1		; Reserve an integer variable
Stash    resd 72	; Reserve an array of 72 integers for randoms
RandChar resb BUFSIZE+5	; Buffer for storing randomly chosen characters

[SECTION .text]		; Section containing code

extern printf	
extern puts
extern rand
extern scanf	
extern srand
extern time			
		
;------------------------------------------------------------------------------
;  Random number generator procedures  --  Last update 5/22/2009
;
;  This routine provides 5 entry points, and returns 5 different "sizes" of
;  pseudorandom numbers based on the value returned by rand. Note first of 
;  all that rand pulls a 31-bit value. The high 16 bits are the most "random"
;  so to return numbers in a smaller range, you fetch a 31-bit value and then
;  right shift it zero-fill all but the number of bits you want. An 8-bit
;  random value will range from 0-255, a 7-bit value from 0-127, and so on.
;  Respects EBP, ESI, EDI, EBX, and ESP. Returns random value in EAX.
;------------------------------------------------------------------------------
pull31: mov ecx,0		; For 31 bit random, we don't shift
	jmp pull
pull16: mov ecx,15		; For 16 bit random, shift by 15 bits
	jmp pull
pull8:	mov ecx,23		; For 8 bit random, shift by 23 bits
	jmp pull
pull7:  mov ecx,24		; For 7 bit random, shift by 24 bits
	jmp pull
pull6:	mov ecx,25		; For 6 bit random, shift by 25 bits
	jmp pull
pull4:	mov ecx,27		; For 4 bit random, shift by 27 bits
pull:	push ecx		; rand trashes ecx; save shift value on stack
	call rand		; Call rand for random value; returned in EAX
	pop ecx			; Pop stashed shift value back into ECX
	shr eax,cl		; Shift the random value by the chosen factor
				;  keeping in mind that part we want is in CL
	ret			; Go home with random number in EAX

;---------------------------------------------------------------------------
;  Newline outputter  --  Last update 5/22/2009
;
;  This routine allows you to output a number of newlines to stdout, given
;  by the value passed in EAX.  Legal values are 1-10. All sacred registers
;  are respected. Passing 0 in EAX will result in no newlines being issued.
;---------------------------------------------------------------------------
newline:
	mov ecx,10	; We need a skip value, which is 10 minus the
	sub ecx,eax	;  number of newlines the caller wants.
	add ecx,nl	; This skip value is added to the address of
	push ecx	;  the newline buffer nl before calling printf.
	call printf	; Display the selected number of newlines
	add esp,4	; Stack cleanup for one parm
	ret		; Go home
nl	db 10,10,10,10,10,10,10,10,10,10,0
	
		
	;; This subroutine displays numbers six at a time
	;; Not intended to be general-purpose...
shownums:	
	mov esi, dword [Pulls]	; Put pull count into ESI
.dorow:	mov edi,6		; Put row element counter into EDI
.pushr:	dec edi			; Decrement row element counter
	dec esi			; Decrement pulls counter
	push dword [Stash+esi*4]; Push number from array onto stack
	cmp edi,0		; Have we filled the row yet?
	jne .pushr		; If not, go push another one
	push ShowArray		; Push address of base display string
	call printf		; Display the random numbers
	add esp,28		; Stack cleanup: 7 items X 4 bytes = 28
	cmp esi,0		; See if pull count has gone to 0
	jnz .dorow		; If not, we go back and do another row!
	ret			; Done, so go home!
	
	;; This subroutine pulls random values and stuffs them into an
	;; integer array.  Not intended to be general purpose.  Note that
	;; the address of the random number generator entry point must
	;; be loaded into edi before this is called, or you'll seg fault!
puller:
	mov esi,dword [Pulls]	; Put pull count into ESI
.grab:	dec esi			; Decrement counter in ESI
	call edi		; Pull the value; it's returned in eax
	mov [Stash+esi*4],eax   ; Store random value in the array
	cmp esi,0		; See if we've pulled 4 yet
	jne .grab		; Do another if ESI <> 0 
	ret			; Otherwise, go home!

; MAIN PROGRAM:
					
global main			; Required so linker can find entry point
	
main:
        push ebp		; Set up stack frame for debugger
	mov ebp,esp
	push ebx		; Program must preserve EBP, EBX, ESI, & EDI
	push esi
	push edi
;;; Everything before this is boilerplate; use it for all ordinary apps!	

; Begin by seeding the random number generator with a time_t value:	
Seedit:	push 0		; Push a 32-bit null pointer to stack
	call time	; Returns time_t value (32-bit integer) in EAX
	add esp,4	; Stack cleanup for one parm
	push eax	; Push time_t value in EAX onto stack
	call srand	; Time_t value is the seed value for random # gen
	add esp,4	; Stack cleanup for one parm

; All of the following code blocks are identical except for the size of
; the random value being generated:
	
; Create and display an array of 31-bit random values
	mov edi,pull31	; Copy address of random # subroutine into EDI
	call puller	; Pull as many numbers as called for in [pulls]
	push 32		; Size of numbers being pulled, in bits
	push dword [Pulls] ; Number of random numbers generated
	push Display	; Address of base display string
	call printf	; Display the label
	add esp,12	; Stack cleanup: 3 parms X 4 bytes = 12
	call shownums	; Display the rows of random numbers
	
; Create and display an array of 16-bit random values
	mov edi,pull16	; Copy address of random # subroutine into edi
	call puller	; Pull as many numbers as called for in [pulls]
	push 16		; Size of numbers being pulled, in bits
	push dword [Pulls] ; Number of random numbers generated
	push Display	; Address of base display string
	call printf	; Display the label
	add esp,12	; Stack cleanup: 3 parms X 4 bytes = 12
	call shownums	; Display the rows of random numbers
	
; Create and display an array of 8-bit random values:
	mov edi,pull8	; Copy address of random # subroutine into edi
	call puller	; Pull as many numbers as called for in [pulls]
	push 8		; Size of numbers being pulled, in bits
	push dword [Pulls] ; Number of random numbers generated
	push Display	; Address of base display string
	call printf	; Display the label
	add esp,12	; Stack cleanup: 3 parms X 4 bytes = 12
	call shownums	; Display the rows of random numbers

; Create and display an array of 7-bit random values:
	mov edi,pull7	; Copy address of random # subroutine into edi
	call puller	; Pull as many numbers as called for in [pulls]				
	push 7		; Size of numbers being pulled, in bits
	push dword [Pulls] ; Number of random numbers generated
	push Display	; Address of base display string
	call printf	; Display the label
	add esp,12	; Stack cleanup: 3 parms X 4 bytes = 12
	call shownums	; Display the rows of random numbers

; Create and display an array of 4-bit random values:
	mov edi,pull4	; Copy addr. of random # subroutine into EDI
	call puller	; Pull as many #s as called for in [pulls]
	push 4		; Size of numbers being pulled, in bits
	push dword [Pulls] ; Number of random numbers generated
	push Display	; Address of base display string
	call printf	; Display the label
	add esp,12	; Stack cleanup: 3 parms X 4 bytes = 12
	call shownums	; Display the rows of random numbers

; Clear a buffer to nulls:
Bufclr:	mov ecx, BUFSIZE+5  ; Fill whole buffer plus 5 for safety
.loop:	dec ecx		    ; BUFSIZE is 1-based so decrement first!
	mov byte [RandChar+ecx],0     ; Mov null into the buffer
	cmp ecx,0	    ; Are we done yet?
	jnz .loop	    ; If not, go back and stuff another null

; Create a string of random alphanumeric characters:
Pulchr:	mov ebx, BUFSIZE	; BUFSIZE tells us how many chars to pull
.loop:	dec ebx			; BUFSIZE is 1-based, so decrement first!
	mov edi,pull6		; For random in the range 0-63
	call puller		; Go get a random number from 0-63
	mov cl,[CharTbl+eax]	; Use random # in eax as offset into table
	                        ;  and copy character from table into CL
	mov [RandChar+ebx],cl	; Copy char from CL to character buffer
	cmp ebx,0		; Are we done having fun yet?
	jne .loop		; If not, go back and pull another

; Display the string of random characters:
	mov eax,1	; Output a newline
	call newline	;  using the newline procedure
	push RandChar	; Push the address of the char buffer 
	call puts	; Call puts to display it
	add esp,4	; Stack cleanup for one parm
	mov eax,1	; Output a newline
	call newline	;  using the newline subroutine
		
;;; Everything after this is boilerplate; use it for all ordinary apps!
	pop edi		; Restore saved registers
	pop esi
	pop ebx
	mov esp,ebp	; Destroy stack frame before returning
	pop ebp
	ret		; Return control to Linux
```



### 10.7.3 有些位比其它位更具随机性

有关 rand() 和 srand() 的 Unix 文档表明，由 rand() 产生的值的低序位总是不如高序位随机性强。如果要获取指定位数的随机数，例如 要获得一个 6 位随机数，可将其右移25位。

若要获得 n 位随机数，就将生成的随机数右移 (32-n-1) 位



### 12.7.4 调用寄存器中的地址

将过程的地址存入寄存器中，就可以通过寄存器来进行过程调用。例如：下列两次 call 调用等价：

```
mov ebx,pull8       ; 将 pull8 标签代表的地址加载到 EBX 中
call pull8          ; 调用由 pull8 所代表的地址
call ebx            ; 调用存放在 EBX 中的地址
```



## 12.8 C 如何看待命令行参数

之前 Linux 程序访问命令行参数是通过 ESP，在 glibc 中连接和调用标准 C 库中的函数时，这一过程将发生显著变化，因为 glibc 的启动代码会把一些其他内容压入栈中。但幸运的是，可以通过 EBP 来访问命令行参数，其原理如下图：

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-07-03 下午11.15.22.png" alt="截屏2021-07-03 下午11.15.22" style="zoom: 67%;" />



可以通过如下代码访问 命令行参数：

```
	mov edi,[ebp+8]       ; 将参数数量加载到 EDI 中
	mov ebx,[ebp]         ; 将指向参数表的指针加载到 EBX 中
	xor esi,esi           ; 将 ESI 清零
.showit:
	push dword [ebx+esi*4] ; 将第一个参数的地址压入堆栈
	push esi               ; 将参数编号压入堆栈
	push ArgMsg            ; 将显示字符串的地址压入堆栈
	call printf            ; 显示实参编号和实参
	add esp,12             ; 堆栈清理：3 个参数*4个字节=12
	inc esi                ; 跳到下一个参数
	dec edi                ; 将参数计数器的值减 1
	jnz .showit            ; 如果参数计数器的值为零，我们的任务完成。
```



## 12.9 简单文件输入/输出

最后一个示例，将实现以下功能：

* 创建一个新文件，如果已经存在，则覆盖该文件
* 提供 2 个参数，第 1 个是数字，第 2 个是一个字符串，数字指出程序将在文件中插入字符串多少行。
* 如果缺少数字，则程序出错退出。
* 如果缺少字符串，则写入随机字符。



### 12.9.1 通过 sscanf() 将字符串转换为数字

strtod() 函数只能将字符串转换为整数，而 sscanf() 几乎能够将任何一个合法数字值的文本表达式转换为一个适当的数字表达形式。

sscanf() 函数需要三个参数，必须按照以下顺序将它们压入堆栈。

1. 数字型变量的地址，保存转换之后的数字。
2. 格式化代码字符串的地址压入堆栈，它告诉 sscanf()  将输入的文字转换成哪种数字格式。例如：`%d`可以转换为 32 位整数。
3. 最后，将数字值的文本字符串的地址压入堆栈。

它还返回一个编码到 EAX 中，以指示转换是否成功。如果 EAX 的值是 0，代表发生了一个错误，如果 EAX 的值是 1，则指示转换成功。这是最基本的用法，也可以一次转换多个数字文本。

下列演示转换一个数字文本：

```
mov ebx,[ebp+12]         ; 将指向参数表的指针放入 ebx 中
push LineCount           ; 为了调用 sscanf，将代表行数的整数的地址压入堆栈。
push IntFormat           ; 将整数格式化代码的地址压入堆栈
push dword [ebx+4]       ; 将arg(1) 的地址压入堆栈
call sscanf              ; 调用 sscanf 将 arg(1) 转换成一个整数
add esp,12               ; 堆栈清理
cmp eax,1                ; 检查返回值，返回值为 1，说明得到了一个有效的数字
je chkdata               ; 如果我们得到了一个有效的数字，则继续，否则，异常终止
```



### 12.9.2 创建和打开文件

使用 fopen() 函数，我们可以创建或者打开文件。在调用它之前，必须把以下参数按以下顺序压入堆栈：

1. 打开模式，经常使用的有："r","w"和 "a"。

   WriteCode db 'w',0

   OpenCode db 'r',0

2. 即将打开的文件的名字的地址。

调用 fopen() 之后，将会返回一个文件句柄到 EAX 中，句柄为 Linux 分配给一个文件的 32 位数字，如果打开失败，EAX 的值将为 0。

以下是打开文件示例：

```
push opencode    ; 将以只读("r")的方式打开，将字符串的地址压入堆栈
push ebx         ; 帮助文件的名字的地址存放在 EBX 中，压入堆栈中
call fopen       ; 尝试以只读的方式打开
add esp,8        ; 清理堆栈
cmp eax,0        ; 如果打开操作失败，fopen() 返回一个空值。
<根据需要进行跳转>
```

![截屏2021-07-04 上午12.03.07](/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-07-04 上午12.03.07.png)



### 12.9.3 使用 fgets() 从文件中读取文本

将一个文件以读取当方式打开，就可以使用 fgets() 函数从中顺序读取文字行了。每次调用 fgets(),从文件中读取一行，行被定义为一直到下一个 EOL(“换行”)字符(ASCII 码 10)。

必须向 fgets() 传递一个极限值，当到达比极限值少 1 时，停止读取字符。然后，增加一个 EOL 字符到缓冲区中，将其作为最后的字符并返回。

调用方式：

1. 将从 fopen() 函数返回的文件句柄压入堆栈。
2. 将该字符的计数极限值压入堆栈。
3. 将用于存放 fgets() 从文件中读出的字符的字符缓冲区的地址压入堆栈。

所有工作完成，调用 fgets() , 如果 fgets() 返回一个 0 到 EAX 中，那么已经到达了文件末尾，或者可能在读取过程中发生了文件错误。相反，如果 EAX 没有返回 0，那么可以假设在缓冲区的地址处已经出现了有效文本。

```
diskhelp:
	push OpenCode         ; 将指向 "以读取方式打开" 的代码 "r" 的指针压入堆栈
	push ebx              ; 指向帮助文件的名字的指针被传递到 ebx 中
	call fopen            ; 尝试打开，用于读取操作
	add esp,8             ; 清理堆栈
	cmp eax,0             ; 如果尝试打开操作失败，fopen 返回空值
	jne .disk             ; 从磁盘文件中读取帮助信息
	call memhelp          ; 如果在磁盘上有帮助文件，从内存中读取
	ret
.disk:
	mov ebx,eax           ; 将打开文件的句柄保存到 ebx 中
.rdln:
	push ebx              ; 将文件句柄压入堆栈
	push dword HELPLEN    ; 限制读取文本行的长度
	push HelpLine         ; 将帮助文本行缓冲区的地址压入堆栈
	call fgets            ; 从文件中读取一行
	add esp,12            ; 清理堆栈
	cmp eax,0             ; 如果返回空值，表明发生了错误，或到达了文件末尾
	jle .done             ; 如果 EAX 中的值为0，关闭返回
	push HelpLine         ; 将帮助行的地址压入堆栈
	call printf           ; 显示帮助行
	add esp,4             ; 清理堆栈
	jmp .rdln
.done:
	push ebx              ; 把即将关闭的句柄压入堆栈
	call fclose           ; 调用 fclose 关闭文件
	add esp,4             ; 清理堆栈
	ret                   ; 返回
```



### 12.9.4 使用 fprintf() 写文本到文件中

fprintf() 能够做 printf 能做的所有事，它需要一个放在堆栈上的额外参数：已打开文本文件的文件句柄。fprintf() 使用方法：

1. 将变量的地址压入堆栈中。
2. 将包含格式化代码的基字符串的地址压入堆栈。
3. 将文本应该写入的目标文件的句柄压入堆栈中。

然后调用 fprintf()，调用后，如果 EAX 值变为负数，则表示遇到错误。

```
push esi                ; ESI 是指向文本行的指针
push 1                  ; 将第一行的行号压入堆栈
push WriteBase          ; 将基字符串的地址压入堆栈
push ebx                ; 将打开文件的文件句柄压入堆栈
writeline:
	cmp dword edi,0       ; 行计数器已经变为零了吗
	je donewrite          ; 退出并清理堆栈
	call fprintf          ; 将文本行写入文件
	dec edi               ; 递减即将被写入的行的计数值
	add dword [esp+8],1   ; 更新堆栈上的行号
	jmp writeline         ; 继续下一轮循环
donewrite:
	add esp,16            ; 完成 fprintf ，清理堆栈
```



### 12.9.5 关于收集过程到库中的注解

下面是一个关于如何收集过程到库中的概述：

* 不是必须得进入入口点定义或者寄存器保存。只需要创建一个新的源代码文件，并将过程的源代码复制到该文件中，然后确保该文件必须以 .asm 为扩展名即可。
* 将在库中定义的所有过程的可调用入口点，以及任何可能被其他过程和库使用的标识符定义为 global。
* 如果过程需要调用任何 C 函数或者任何位于你拥有或者创建的其他库中的过程，或者使用在库外定义的变量或其他标识符，将所有的这类外部标识符声明为 extern。
* 当从程序中调用库中的过程时，更新该程序的生成文件，以便最终的可执行文件拥有一个对于该库的依赖条件。



## 结论：不是结束，而是刚刚开始

旅程才是目标。问题不在于征服，而是与它一起成长，不断发展这方面的相关知识。

一般学习方法：

* 学习 Linux 
* 学习汇编语言
* 编写代码
* 编写更多代码

关于 Linux 方面的书：

Ununtu 8.10 Linux Bible 作者 William von Hagen(Wiley, 2009)

Beginning Linux Programming 第四版 作者：Neil Matthew 和 Richard Stones(Wrox Press, 2008)

关于 汇编语言

The Art of Assembly Language 作者: Randall Hyde (No Starch Press , 2003)

这可能是写的最好的汇编语言书籍。

Professional Assembly Language 作者：Richard Blum(Wrox Press,2005)

不错的中级书，单是关于数字编程方面的第 3 章就非常值得买一本。



计算的复杂性似乎每两年就增加一倍。不过不要怕，一定要坚持告诉自己：我能做到的！相信此话的真理，便是离开起点的本质——而其余的路，像所有的路一样，要踏踏实实地，一步一个脚印地走下去。

# 
