# 第10章 多进程服务器端

## 1、进程的概念及应用

### 1.1 两种类型的服务器端

单进程下，每次只能受理一个客户端的请求，第1位连接请求的受理时间是0秒，第50位连接请求的受理时间是50秒，第100位连接请求的受理时间是100秒。很显然这种方式是不合理的，没有多少人有耐心为了一个页面请求等待几分钟。



多进程下，为每个请求新建一个进程，在宏观上相当于同时受理所有客户端的连接请求，每个客户端连接请求的受理时间为2～3秒，这种技术更加合理一些。



### 1.2 并发服务器端的实现方法

网络程序中数据通信时间比CPU运行时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。下面是具有代表性的并发服务器端实现模型和方法：

* 多进程服务器：通过创建多个进程提供服务。
* 多路复用服务器：通过捆绑并统一管理I/O对象提供服务。
* 多线程服务器：通过生成与客户端等量的线程提供服务。

本章重点介绍多进程服务器。

### 1.3 理解进程

#### 进程的概念

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

简单说："进程就是占用空间的正在运行的程序!"

一个可执行程序，在开始运行前只是一个普通程序，即存放在磁盘中，包含二进制代码的文件。当运行该程序后，系统将该程序调入内存，就变为一个进程(包含二进制代码，及所使用的各种计算机资源)，该进程可以申请或释放计算机资源。

#### 单核和多核

单核cpu一次只能运行一个进程，当现代操作系统都采用分时使用cpu资源，即每个进程轮流使用cpu，只不过每个进程执行时间很短，所以造成了进程同时执行的错觉。

#### 进程查询

多核cpu可以同时执行多个进程，但进程数量往往大于核心数，所以进程往往都需要分时使用CPU资源。

```shell
$ ps au
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
gdm       1450  0.0  0.2 212136  6056 tty1     Ssl+ Apr29   0:00 /usr/lib/gdm3/gdm-x-sessio
root      1452  0.0  0.7 275792 16044 tty1     Sl+  Apr29   0:28 /usr/lib/xorg/Xorg vt1 -di
gdm       1514  0.0  0.6 558988 13992 tty1     Sl+  Apr29   0:00 /usr/lib/gnome-session/gno
gdm       1532  0.0  6.5 3101252 133240 tty1   Sl+  Apr29   1:45 /usr/bin/gnome-shell
gdm       1555  0.0  0.3 435100  7836 tty1     Sl   Apr29   0:00 ibus-daemon --xim --panel 
gdm       1558  0.0  0.2 280748  5912 tty1     Sl   Apr29   0:00 /usr/lib/ibus/ibus-dconf
gdm       1562  0.0  1.0 344012 20832 tty1     Sl   Apr29   0:00 /usr/lib/ibus/ibus-x11 --k
gdm       1589  0.0  1.0 494596 21748 tty1     Sl+  Apr29   0:00 /usr/lib/gnome-settings-da
gdm       1594  0.0  0.2 278160  5788 tty1     Sl+  Apr29   0:00 /usr/lib/gnome-settings-da
gdm       1596  0.0  0.9 343612 20112 tty1     Sl+  Apr29   0:00 /usr/lib/gnome-settings-da
```

使用ps命令可以查看当前系统正在运行的进程，每个进程都具有唯一的编号(PID)，一个系统能使用的PID数量是有限的，因而一个系统能使用的进程是有限的。



### 1.4 进程创建方法

创建进程的方法有很多，此处介绍用fork函数创建子进程。

```shell
#include <unistd.h>

pid_t fork(void);
//成功时返回进程IP，失败时返回-1
```

fork函数将创建调用的进程副本。也就是说：并非完全根据不同的程序创建进程，而是复制正在运行的，调用fork函数的进程。另外，两个函数都将执行fork函数调用后的语句（准确地说是在fork函数返回之后）。但因为通过同一个进程，复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分。即利用fork函数的如下特点区分程序的执行流程。

* 父进程：fork函数返回子进程ID
* 子进程：fork函数返回0

此处“父进程”指原进程，即调用fork函数的主体，二“子进程是通过父进程调用fork函数”复制出的进程。下图表示fork函数后的程序运行流程。

<img src="/Users/wangjun/computer-system/计算机网络原理/TCP-IP-网络编程/ch10/fork函数的调用.png" alt="fork函数的调用" style="zoom: 33%;" />



子进程和父进程都拥有执行fork函数之前的变量，但它们的运行不会相互影响。

下面给出例子验证之前的猜想：

```

```

